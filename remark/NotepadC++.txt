Директива: #include <iostream> {//Просим С++ скопировать и вставить содержимое другого исходного файла С++, который называется <iostream>, прямо в наш файл кода.
	#include <foo.h> //библиотечный заголовочный файл
	#include "bar.h" //локальный заголовочный файл
}//Конец области "Директива: #include <iostream>"
#pragma once //этот файл нужно только один раз добавить.

make и Makefile | qmake{
	
make{
//Если запустить
make
//то программа попытается найти файл с именем по умолчание Makefile в текущем каталоге и выполнить инструкции из него. 
//Если в текущем каталоге есть несколько мейкфайлов, то можно указать на нужный вот таким образом:
make -f MyMakefile
	
Самый простой Мейкфайл:
	В нем должны быть такие части:
		цель: зависимости
		[tab] команда
		
Пример:
all:
	g++ main.cpp hello.cpp factorial.cpp -o hello
	
//Обратите внимание, что строка с командой должна начинаться с табуляции!
//В первом примере цель называется all. 
//Это цель по умолчанию для мейкфайла, которая будет выполняться, если никакая другая цель не указана явно. 
//Также у этой цели в этом примере нет никаких зависимостей, так что make сразу приступает к выполнению нужной команды. 
//А команда в свою очередь запускает компилятор.

//Использование переменных и комментариев
	//Переменные широко используются в мейкфайлах. 
	//Например, это удобный способ учесть возможность того, что проект будут собирать другим компилятором или с другими опциями.
	# Это комментарий, который говорит, что переменная CC указывает компилятор, используемый для сборки
	CC=g++
	#Это еще один комментарий. Он поясняет, что в переменной CFLAGS лежат флаги, которые передаются компилятору
	CFLAGS=-c -Wall
	
	hello.o:
		$(CC) $(CFLAGS) hello.cpp
	//Создаем переменную и после этого можно подставлять их значение в нужное место вот таким способом: $(VAR)

}//Конец Области make	
	
qmake{
//qmake способна создавать не только make файлы, но и сами рго-файлы:
//Допустим, вы указали, что в каталоге есть исходные файлы C++, выполнив:
qmake -project
//В результате будет реализована попытка автоматического создания pro-файла.

//Создать из рго-файла make-файл:
qmake file.pro -о Makefile
//file.pro — это имя pro-файла, a Makefile — имя для создаваемого платформозависимого make-файла.


Таким образом, имея в распоряжении только исходные файлы на C++, можно создать исполняемую программу, выполнив всего лишь три команды:
	qmake -project
	qmake
	make
//Для ручного создания, можно посмотреть стр 75 (QT 5.3 Профессиональное программирование на С++ Макс Шлее 2015) 


}//Конец области "qmake"
	
}//Конец Области make и Makefile | qmake

GCC ( GNU Compiler Collection ){
//набор компиляторов для различных языков программирования, разработанный в рамках проекта GNU
язык и имя компилятора:{GCC для Ada, или GNAT
C++ для GCC, или G++
GCC для Fortran, или gfortran
GCC для Java, или GCJ
GCC для Objective-C, или gobjc
GCC для Objective-C++, или gobjc++
GCC для Go, или gccgo (с версии 4.6[5])
}

g++ -mwindows //возможно уберет консоль.
Хотя команда gcc самостоятельно определяет используемый язык программирования, она не считает нужным в данном случае по умолчанию линковать наш файл со стандартной библиотекой C++.

gcc ./first.cpp -lstdc++ //Просим явно слинковать файл со стандартной библиотекой
//Или
g++ ./first.cpp  //Команда g++ явно указывает на то, что мы используем язык C++ и по умолчанию линкует стандартную библиотеку этого языка.
g++ ./first.cpp -o helloworld //файл будет не a.out, а helloworld
//указать, какого стандарта нужно придерживаться при компиляции можно, используя ключ компиляции -std, присваивая ему значения, обозначающие тот или иной стандарт, например:
gcc ./first.cpp -lstdc++ -std=c++98 //Или расширения: -std=gnu++98 или -std=gnu++0x
//Есть с пару десятков предупреждений, возможно -Wall и -Wextra, не проверял.
//Если есть несколько файлов, можно попросить компилятор только препроцессор вызвать и посмотреть, что получиться:
g++ -E MyFile.ccp -o EndFile.cpp
//Можно скормить файл компилятору:
g++ -с MyFile.ccp //g++ -c f.cpp создает объектный файл f.
//на выходе получим MyFile.о . Это объектный файл
//скомпоновать один или несколько объектных файлов, полученных из исходного кода C++ - F1.o, F2.o, ... - в единый исполняемый файл F
gcc -o F F1.o F2.o 
//можно так же в виде ассамблера посмотреть файл:
g++ -S MyFile.ccp  //. Он создаст файл MyFile.s , в котором будет ассамблер
//Компилировал код и только так смог его запустить на другом компе: //
-static-libgcc -static-libstdc++ //не пойму как, но файл был 300кб, а стал 2185. И тогда он запустился,
//хотя до этого требовал три dll,один из которых я не смог найти у себя в система:
g++ w.cpp -static-libgcc -lgdi32 -static-libgcc -static-libstdc++   
libgcc -это какая-то библиотека о типах. В 64 битных и 32 числа там складывать. Числа с плавающей точкой.
libstdc++ Динамическая библиотека (RTL) содержащая классы и функции С++, определенные как часть стандарта языка.
g++ -v //версия компилятора и его данные:
//В системах UNIX командой для сборки статичной библиотеки обычно является ar, и библиотечный файл, который при этом получается, имеет расширение *.a. Также эти файлы обычно имеют префикс «lib» в своём названии и они передаются компоновщику с опцией "-l" с последующим именем библиотеки без префикса и расширения (т.е. :
-lfred // подхватит файл «libfred.a»).
//библиотеки привлекаются только, когда нормальная компоновка завершена, и они обрабатываются в порядке слева на право. Это значит, что если объект, извлекаемый из библиотеки в последнюю очередь, требует наличие символа из библиотеки, стоящей раньше в строке команды компоновки, то компоновщик не найдёт его автоматически.
#pragma comment(lib, "sqlite3.dll") //Похоже так можно dll подключать.
g++ w.cpp -L. -lsqlite3 //Указываем, что dll в этой же папке

vasa019@C:/mnt/project$ g++ -v{ //https://www.sourcelair.com/workspace/C
Using built-in specs.
COLLECT_GCC=g++
COLLECT_LTO_WRAPPER=/usr/lib/gcc/x86_64-linux-gnu/4.8/lto-wrapper
Target: x86_64-linux-gnu
Configured with: ../src/configure -v --with-pkgversion='Ubuntu 4.8.4-2ubuntu1~14.04.3' --with-bugurl=file:///usr/share/doc/gcc-4.8/README.Bugs --enable-languages=c,c++,java,go,d,fortran,objc,obj-c++ --prefix=/usr --program-suffix=-4.8 --enable-shared --enable-linker-build-id --libexecdir=/usr/lib --without-included-gettext --enable-threads=posix --with-gxx-include-dir=/usr/include/c++/4.8 --libdir=/usr/lib --enable-nls --with-sysroot=/--enable-clocale=gnu --enable-libstdcxx-debug --enable-libstdcxx-time=yes --enable-gnu-unique-object --disable-libmudflap --enable-plugin --with-system-zlib --disable-browser-plugin --enable-java-awt=gtk --enable-gtk-cairo --with-java-home=/usr/lib/jvm/java-1.5.0-gcj-4.8-amd64/jre --enable-java-home --with-jvm-root-dir=/usr/lib/jvm/java-1.5.0-gcj-4.8-amd64 --with-jvm-jar-dir=/usr/lib/jvm-exports/java-1.5.0-gcj-4.8-amd64 --with-arch-directory=amd64 --with-ecj-jar=/usr/share/java/eclipse-ecj.jar --enable-objc-gc --enable-multiarch --disable-werror --with-arch-32=i686 --with-abi=m64 --with-multilib-list=m32,m64,mx32 --with-tune=generic --enable-checking=release --build=x86_64-linux-gnu --host=x86_64-linux-gnu --target=x86_64-linux-gnu
Thread model: posix
gcc version 4.8.4 (Ubuntu 4.8.4-2ubuntu1~14.04.3)
}

Обзор книги: GCC настольная книга пользователей, программистов и системных администраторов{
Меня в этой книги интересуют моменты:
	1-Глава 16: "ПО умолчанию gcc генерирует код для той же вычислительной ситемы, на которой он используется. Но его можно установить и сконфигурировать таким образом, чтобы код генерировался для других машин."
	2-опции командной строки
	2-совмещение языков "Вызовы функций Х из кода на языке С++"
	3-поиск библиотек и размещение библиотек.
	4-Директивы препроцессора.

Приложение Б-опции командной строки
Глава 5-примеры компиляции и компоновки С++
Глава 12-примеры создания и применения библиотек.
Глава 14- описание make
Глава 16- комляция программ для другой машины
Глава 18- генерация компилятором полезной информации

Между опцией и параметром пробел необязателен:
-omuxit.o равно -o muxit.o
Опции указывающие на выполнение только определенных действий-компоновка (linking) или предобработка (preprocessing), так же означает, что остальные фраги, будут проигнорированы-распознает флаги, но не будет их приминять.
	
} //Конец области //Обзор книги: GCC настольная книга....

Проверить:{
гугл:
	gcc включить каталог библиотек
	Использование GCC
	Опции компиляторов  //http://parallel.uran.ru/book/export/html/15
	https://uzverss.livejournal.com/57883.html //Про библиотеки неплохо описано
Опция -Iпуть/к/каталогу/с/заголовочными/файлами - добавляет указанный каталог к списку путей поиска заголовочных файлов. Каталог, добавленный опцией -I просматривается первым, затем поиск продолжается в стандартных системных каталогах. Если опций -I несколько, заданные ими каталоги просматриваются слева на право, по мере появления опций.

Опция -Wall - выводит предупреждения, вызванные потенциальными ошибками в коде, не препятствующими компиляции программы, но способными привести, по мнению компилятора, к тем или иным проблемам при её исполнении. Важная и полезная опция, разработчики gcc рекомендуют пользоваться ей всегда. Например масса предупреждений будет выдана при попытке компиляции вот такого файла:


}//Конец области проверить	

Библиотеки{
набор объектных файлов, содержащих функции, которые могут быть использованы в разных программах, собирается в библиотеку (программного кода), представляющую собой единый файл, который содержит весь код объектных с некоторой дополнительной информацией (наподобие индекса в настоящих библиотеках). Последнее может ускорять процесс линковки при использовании библиотеки по сравнению с обычной сборкой программы из большого числа объектных файлов.

Виды:
	статические: код из библиотеки добавляется в исполняемый файл на стадии линковки, и после её окончания файл библиотеки больше не нужен полученной программе;
	динамические: код из библиотеки не добавляется в исполняемый файл, а загружается в память во время запуска программы, таким образом, он должен быть доступен при каждом запуске;
	
Бесспорное преимущество динамических библиотек состоит в том, что если несколько программ используют одну библиотеку, то она загружается в память только один раз. Иными словами, сразу несколько программ могут (и будут) использовать один загруженный экземпляр библиотеки «одновременно». В то же время использование статической библиотеки заставит добавлять части её кода в каждый исполняемый файл по отдельности. Обновление динамической библиотеки потребует перезапуска, использующих её программ, статической — их перелинковки (что обычно занимает немало времени).

Статические библиотеки{
Для создания библиотеки такого типа из набора объектных файлов используется утилита ar.
g++ -c ./third.cpp //создает объектный файл
ar crs libfirst.a ./second.o ./third.o //видим в папке libfirst.a
Опции ar означают следующее:
c — создать (create) библиотеку,
r — заменить (replace) совпадающие объектные файлы внутри библиотеки указанными новыми (в случае, если библиотека существовала),
s — создать индекс внутри библиотеки (может быть, у вас получится догадаться о происхождении имени ключа...).
Важным является формат имени файла библиотеки:
префикс ‘lib’,
расширение ‘.a’.
Для указания GCC на библиотеки, которые нужно использовать при сборке, понадобятся ещё два ключа:
l — для имени библиотеки,
L — для указания пути к ней.
Компиляция нашей программы с использованием созданной библиотеки может выглядеть так:
g++ ./first.cpp -L. -lfirst //см строку ниже
//С помощью -L. текущий каталог добавляется в список каталогов для поиска библиотек 
//(чтобы добавить несколько каталогов, нужно использовать ключ -L несколько раз).
//Обратите внимание, что именем библиотеки считается подстрока имени ‘.a’-файла между ‘lib’ слева и ‘.a’ справа. 
 //Здесь, в отличие от рассмотренных ранее случаев, порядок аргументов g++ важен, поскольку -L и -l это опции линковщика, который вступает в работу после компилятора, обрабатывающего первый аргумент (имя файла).
}

Динамические библиотеки{
При компиляции исходных файлов в объектные, которые станут основой для будущей библиотеки, нужно указать один дополнительный ключ:
$ g++ -fPIC -c ./second.cpp //создадим библиотеку из одного файла || у меня на выходе получился объектный файл .о
//Ключ -fPIC позволяет создавать независимый от размещения в оперативной памяти код (position independent code), что позволяет использовать один библиотечный код из разных программ (находящихся, очевидно, в разных местах оперативной памяти) во время их выполнения.
Файлы динамических библиотек должны, как и раньше, иметь префикс ‘lib’ и расширение ‘.so’ (shared object).
Сложность состоит в том, что для одной библиотеки надо иметь в виду четыре имени, причем три из них соответствуют объектам файловой системы:
1-«Реальное имя» (real name): имя файла на диске, содержащего код библиотеки. Должно иметь форму:
	libимя.so.n.m.k
		где
			n это номер версии библиотеки,
			m это номер промежуточной («минорной») версии данной версии библиотеки,
			k это номер «релиза» промежуточной версии библиотеки.
			Номер релиза с предшествующей точкой можно опускать, что мы и будем делать в дальнейшем.

2-«so-имя» (soname) получается из реального имени удалением минорной версии и релиза (если он указан):
	libимя.so.n
	В одном каталоге с файлом библиотеки (для которого используется «реальное имя») должна существовать мягкая ссылка (soft link) на него, имеющая so-имя этой библиотеки. Эти мягкие ссылки создаются для всех библиотек в указанном каталоге с помощью запуска утилиты ldconfig либо вручную для конкретной библиотеки с помощью утилиты ln:
		$ ldconfig -n /путь/к/каталогу
		$ ln -s /путь/к/каталогу/libимя.so.n.m /путь/к/каталогу/libимя.so.n
3-Имя, используемое линковщиком при создании исполняемого файла. Не содержит информации о версиях:
	libимя.so
	Обычно в каталоге с файлом библиотеки создаётся мягкая ссылка с этим именем на so-имя (ссылка с so-именем должна уже существовать) либо на реальное имя (первый вариант часто удобней):
		$ ln -s /путь/к/каталогу/libимя.so.n /путь/к/каталогу/libимя.so
4-Имя библиотеки для передачи при вызове компилятора (линковщика) с ключом -l. 
	Аналогично статическим библиотекам, это подстрока между ‘lib’ и ‘.so’.

	
Рассмотрим команду получения файла библиотеки (который должен носить «реальное имя», п. 1 списка выше) из объектного pic-файла (g++ -fPIC -c ./second.cpp):
g++ -shared -Wl,-soname,libfirst.so.1 -o libfirst.so.1.0 ./second.o  //появился файл libf.so.1.0 в папке
Ключ -shared имеет вполне понятное значение: мы сигнализируем GCC о том, что хотим получить динамическую библиотеку («разделяемый объект»). После ключа -o идёт имя выходного файла («реальное имя» файла нашей библиотеки), а затем список файлов, которые должны в эту библиотеку войти: в нашем случае это всего один объектный файл ‘second.cpp’.
//между ключами -shared и -o: Ключ -Wl говорит о том, что далее пойдут опции, которые предназначаются непосредственно линковщику. 
В соответствии с синтаксическими правилами, в списке этих опций не должно присутствовать пробелов: мы передаём GCC что-то, 
на что он должен «закрыть глаза» (опции предназначены не ему, а линковщику) и в этом случае мы договариваемся о том, 
что он откроет глаза только когда встретит первый пробел. 
В качестве символа-разделителя в списке этих опций вместо пробела выступает запятая. 
То есть: между ключами -shared и -o стоит опция, передаваемая линковщику, которая указывает на «so-имя» (п. 2 списка выше) создаваемой библиотеки.
}
Более прозрачное решение текущей задачи (получение библиотечного файла из объектного(ых) pic-файла(ов)(g++ -fPIC -c ./second.cpp)) состоит в прямом вызове линковщика, минуя g++:
$ ld -shared -soname libfirst.so.1 -o libfirst.so.1.0 ./second.o
Результат в данном случае будет аналогичным.

Процесс загрузки библиотек в память: Он происходит при запуске первой программы, которая использует данную динамическую библиотеку.
Загрузка необходимых библиотек при запуске программы осуществляется специальной программой, являющейся частью операционной системы — динамическим линковщиком. 
Он ищет файлы библиотек в некоторых заранее определённых каталогах, список которых на многих Unix-подобных операционных системах хранится в файле /etc/ld.so.conf. Почти наверняка в этом списке имеются каталоги /lib и /usr/lib. Возможно, сюда входит и /usr/local/lib. Как это часто бывает, разные авторитетные организации и специалисты советуют использовать для динамических библиотек разные папки. Мы остановим свой выбор на /usr/lib.
Создание необходимой инфраструктуры библиотечных файлов: одного реального, ссылки с so-именем и ссылки с именем для линковщика — в каком-то из системных каталогов для хранения библиотек часто называют установкой библиотеки.

Теперь, наконец, посмотрим на весь путь от создания динамической библиотеки до запуска программы, её использующей:

$ g++ -fPIC -c ./second.cpp
$ ld -shared -soname libfirst.so.1 -o libfirst.so.1.0 ./second.o
$ sudo cp ./libfirst.so.1.0 /usr/lib/libfirst.so.1.0
$ sudo ldconfig -n /usr/lib/
$ sudo ln -s /usr/lib/libfirst.so.1 /usr/lib/libfirst.so
$ g++ ./first.cpp -lfirst -o hw-dinamic
$ ./hw-dinamic 
Здравствуй, Мир!
42
что исчезла необходимость в указании пути для поиска файла библиотеки с ключом -L: это и понятно, все библиотечный файлы находятся теперь в системных каталогах). Выполняя эту операцию, мы использовали четвёртое имя библиотеки (п. 4 списка выше).

Обращает на себя внимание необходимость наличия администраторских прав (вызов sudo) для установки библиотеки. Во время тестовых запусков программы можно обойтись без копирования в системный каталог /usr/lib/, если использовать переменную окружения LD_LIBRARY_PATH, которая содержит пути для поиска библиотек. В этом случае перед запуском программы её нужно модифицировать, а также снова (как в случае со статической библиотекой) указать ключ -L:
$ g++ -fPIC -c ./second.cpp
$ ld -shared -soname libfirst.so.1 -o libfirst.so.1.0 ./second.o
$ ldconfig -n .
$ ln -s ./libfirst.so.1 ./libfirst.so
$ g++ ./first.cpp -L. -lfirst -o hw-dinamic
$ LD_LIBRARY_PATH=.:$LD_LIBRARY_PATH ./hw-dinamic 
Здравствуй, Мир!
42
}

Три этапа компиляции{
	
	*1 этап: пропроцессор{ язык препроцессора это специальный язык программирования, встроенный в С++.
	Препроцессор работает с кодом на С++ как с текстом.
	Команды препроцессора называются директивами, все директивы начинаются со знака #.
	Пример: Препроцессор заменяет директиву '#include "bar.h"' на содержимое файла bar.h
	
	У Препроцессора есть директивы:
	Директива #define получает имя и определяет его как переменную препроцессора.
	Директива #ifdef истинна, если переменная была определена.
	Директива #ifndef истинна, если переменная не была определена. 
	В случае истинности проверки выполняется все, что расположено после директивы #ifdef или #ifndef и до соответствующей директивы #endif{
	#ifndef SALES_DATA_H //Если не определена SALES_DATA_H тогда
	#define SALES_DATA_H
	#include <string>
	struct Sales_data // {
		std::string bookNo;
		unsigned units_sold=0;
		double revenue =0.0;
	// };
	#endif
		
	
	При первом включении заголовка Хххх.h директива #ifndef истина и препроцессор обработает строки после нее до директивы #endif. В результате будет определена переменная SALES_DATA_H и содержимое заголовка скопировано в программу. При следующих включениях, директива видит, что переменная SALES_DATA_H уже существует и возвращает false и препроцессор пропускает строки между ней и #endif.
		
	}//Конец примера против множественного включения.
	
	Чтобы избежать конфликта с другими сущьностями программы, имена переменных препроцессора, обычно пишут в верхнем регистре

	
	
	}//Конец Области \\1 этап препроцессор.
	*2 этап: компиляция
	*3 этап: линковка(компоновка)
}//Конец области "Три этапа компиляции"

}//Конец области "GCC ( GNU Compiler Collection )"

/* С образный коммент */
using namespace std; // 
#include "stdafx.h"/* visual studio 15 проект ConsoleApplication без этого не работает:*/ #include "stdafx.h" //Для более быстрой компиляции.
|| или or
&& И   and
! логическое отрицание.Результатом выражения !A является значение true, если операнд A равен false. Если операнд A равен true, значение выражения !A равно false
xor ^ (A||B) &&!(A&&B) //вернет true только если один равен false, а другой true
Приведение типов: (type)//(int)X
Тернарный условный оператор: vasa=(a>0)? 4:1; условие?выражение1:выражение

Альтернативные имена операторов С++{
and		&&
and_eq	&=
bitand	&
bitor	|
compl	~
not		!
not_eq	!=
or		||
or_eq	|=
xor		^
xor_eq	^=
}//Конец области "Альтернативные имена операторов С++"

Типы:{
string//-строковая переменная. #include <string> //для использования строковых переменных
char -Единственная буква как 'a','b','+'. ОДИНАРНЫЕ КАВЫЧКИ //char x[]="this is string";
	префикс L- wchar (широкий символ)
short -целое от -32.767 до +32.768
int -целое от -2.147.483.647 до +2.147.483.468
	1234567890L-суффикс L соответствует типу Long
	1703U- соотвествует unsigned int
	2128506UL- unsigned long
float -любое десятичное значение от -1х1038 до 1х1038
	2.71F- суффикс F соответствует типу float
double -любое десятичное значение от -1х10308 до 1х10308
	3.0E8 -это 3.0*10 в 8 степени.
bool -true or false
void -пустой тип
void * -указатель на нетипизированную память (раньше использовали char *).
Строки задаются в двойных кавычках: "Text string".
Приставки:
short — приставка укорачивает тип данных, к которому применяется, путём уменьшения размера занимаемой памяти;
long — приставка удлиняет тип данных, к которому применяется, путём увеличения размера занимаемой памяти;
Есть беззнаковые (unsigned перед типом)версии каждого типа. Содержат ноль. беззнаковый short имеет значения от 0 до 65535:
unsigned (без знака)  — приставка увеличивает диапазон положительных значений в два раза, при этом диапазон отрицательных значений в таком типе данных храниться не может.
size_t-специальный целочисленный беззнаковый тип, может вместить в себя размер любого типа в байтах//Не понимаю его.
Тип size_t используется для указания размеров типов данных, для индексации массивов и пр. //В 64 системе, тип инт 4 байта, а массив в оперативную память может влезть большой, и типа int не хватит для его индексации

const -именованные ячейки памяти, значения  фиксируются и затем не могут быть изменены. 
Интерпритация чисел: целочисленные литералы, начинающиеся с нуля (0), интерпритируются как восьмиричные, а начинающиеся с 0x или 0X -как шестнадцатиричные:
20//десятичная форма
024// восьмиричная форма, это тоже двадцать. Оно равно 20.
0x14//шестнадцатиричная форма//Тоже двадцать и оно равно другим формам
}

Приведение типов (для windiws api){
LPSTR это char*
LPCSTR это const char*
LPWSTR это wchar_t*
это типы данных для WinApi и сделанно это изза того что у каждого языка спецификация типов данных своеобразна а функции WinApi одни. поетому для совместимости языка и WinApi переопределяются только типы


int WINAPI GetWindowText(
  _In_  HWND   hWnd,
  _Out_ LPTSTR lpString, // Это по идее типо  const char*
  _In_  int    nMaxCount
);
int a1=std::stoi(lpString);//Получаем число
//Строка в функциях виндовс апи-просто в начале ставим L:
CreateWindow(L"edit", L"0",WS_CHILD | WS_VISIBLE | WS_BORDER | ES_RIGHT, 50, 50, 60, 20, hwnd, 0, hInst, NULL);	
Есть строка, обозначающая число:
std::string a = "53";
int a1 = std::stoi(a); //Получаем число
std::string www = std::to_string(a1);//Обратно в строку
char const * qwe = www.c_str(); //в char *, чтобы скормить:
SetWindowTextA(hStat, (LPCSTR)qwe);
SetWindowText(hStat, (LPCWSTR)qwe);

}

Осторожно с k=i++ и k=--i они изменят переменную i{
i=3;
k=i++
cout<<i<<" "<< k<<endl;
k=--i
cout<<i<<" "<< k<<endl;
}

Условные операторы:
if(a>0){
	//do something
} else if  (a>0){
	//do something
}else{
	//do something
}

switch(выражение){   //Результатом выражения может быть целое число или символ. 
	case значение1:	 //Значение, возвращаемое выражением, сравнивается со значением case
		операторы
		break;	//Если не поставить break, то будут выполняться все операторы, начиная с совпадающего
	case значение2:
		операторы 
		break; // Операторы выполняются до конца оператора switch() или пока не встретится инструкция break (в общем случае инструкция break используется для выхода из оператора цикла и перехода к следующему оператору)	
	default:	// Если совпадения нет, выполняются операторы после инструкции default
		операторы 
		}Можно и так использовать switch{
			 cin>>n; 
			 switch(n){
				 case 0: 
				 cout<<"The number is zero!\n"; 
				 break;  
				 case 1: 
				 case 2: 
				 case 3: 
				 case 5: 
				 case 8: 
				 cout<<"This is Fibonacci number!\n"; 
				 break; 
				 default:
				 cout<<"This is integer number!\n"; 
		}}

while (a<0){
	//do something
	
	
	Цикл do while схож с предыдущим. Однако при выполнении нового цикла один проход будет проведен вне зависимости от заданных условий.
	 do {// выполняем цикл.
        i++;
        sum += i;
    } while (i < 1000); // пока выполняется условие.
	Существенной разницы нет, однако при указании переменной значения i, превышающего 1000, код все равно будет выполнять одну итерацию.
	
	
	
}

for (int k=0; k<10;k=k+1){
	//после выполнения команд в фигурных скобках выполняются команды третьего блока
	//Далее снова проверяется условие (второй блок)
	//for(инициализация; условие; изменение переменных){команды}
	//for(char x='a';x!='z';)
	//for(;i<=n;)
	
	//do something

	for (действие до начала цикла;
     условие продолжения цикла;
     действия в конце каждой итерации цикла) {
         инструкция цикла;
         инструкция цикла 2;
         инструкция цикла N;		}

for (счетчик = значение; счетчик < значение; шаг цикла) {
    тело цикла;
}

for ( for-range-declaration : expression )  
   statement   
Пример:
int m[10] = { 11,22,33,44,55 };
for (int y : m) {
	cout << y << "\n";
}
При работе с циклами for, основанными на диапазонах, рекомендуется учитывать следующие факты.
Такие циклы автоматически распознают массивы.
Такие циклы автоматически распознают контейнеры с методами .begin() и .end().
Для всех остальных итераторов в них используются поиск, зависящий от аргументов (begin() и end()).

} //for (;;){} //бесконечны	цикл

Функции: {//При передаче параметра (переменной) в функцию, она копируется. Только значение передается.
//доступность переменных определяется простым правилом: переменные доступны в пределах того блока, где они объявлены. Напомним, что блок в C++ ограничивается парой фигурных скобок.
В качестве параметров в функции могут передаваться не только ссылки на "обычные" переменные, но и ссылки на массивы. Следующая функция принимает ссылку на массив из трех значений типа int:
void foo(int (&a)[3]) { /* ... */ }

Рекурсия{
Под рекурсией подразумевают вызов в теле функции этой же самой функции.
Рекурсивный вызов может быть как прямым (функция вызывается в теле этой же функции),
так и непрямым (в функции вызываются другие функции, в теле которых, в свою очередь, вызывается исходная функция)
}

Перегрузка{
Под перегрузкой подразумевают создание и использование функций с разными прототипами, но одинаковыми названиями.
Перегрузка функции является механизмом реализации концепции полиморфизма.
}

Аргументы функции main(){
//main() могут быть аргументы: число параметров командной строки и массив с текстовыми значениями этих параметров. Обычно параметры называют argc (размер массива) и argv (символьный двумерный массив)
Пример:
int main(int argc, char* argv[])//argv[0] всегда содержит строку, использованную для запуска программы (либо пустую строку).например// "/tmp/tmp.iuRedPfLyr" в онлайн ide.
Если запустить: mytest.exe Alexei Vasilev 2008
то получим, что argc будет равен 4, а str[1]=Alexei, str[3]=2008
Если запустить без аргументов, то argc будет равен 1.}

Чтобы функция изменяла значения переменных:{
//Можно установить у функции указатели и передать туда саму память: swap(&b, &g);
void swap(int * b, int *g) {
	*g = 10;
	*b = 20;
}

void swap(int & b, int &g) {
	g = 40;
	b = 30;
}

int main()
{
	int b = 0;
	int g = 0;
	swap(&b, &g);
	cout << b << " " << g << "\n";
	swap(b, g);
	cout << b <<" "<< g<< "\n";
	return 0;
}	
}

}

Осторожно с макросами, по возможности не использовать:{
#define max(x,y) x>y? x:y 
//Он просто подставит это в код, не заботясь о синтаксисе и типах, приоритете:
a=b+max(c,d) // (b+c) >d ? c:d	
}

Осторожно с использована неинициализированная локальная переменная{#include <iostream>
void vasay() {
	int g = 999;
}
int petay() {
	int c;
	return c;
}

int main()
{
	int a = 3;
	vasay();
	a=petay();
	std::cout<<a<<"\n";
	return 0;
}
//Этот код спокойно компилируется, без ошибок, тк Undefined Поведение (UB).
//Тут особенность стека, после окончания функции, место освобождается. И на место этих локальных
//переменных записываются другие. А значение не очищается.
}

Осторожно с временем жизни локальных переменных в функциях{
int * foo(){
	int f=10;
	return &f;
}//f-локальная переменная, и после окончания функции, она удаляется, но её адрес вернется.
//хотя переменной не существует.
int & bar(){
	int b=20;
	return b;
}
//локальная переменная уничтожится после выхода из функции, и неизвестно, что будет.



	
}

Структуры{
//При объявлении структуры нужно ставить ";" в конце. При создании функции нет
//Под структурами подразумевают группу переменных, объединенных общим именем
struct имя{
тип1 поле1;
тип2 поле2;
//тип_поля2 имя_поля2: размер2; //Минимальный размер поля структуры – один бит//для экономии системных ресурсов
...
типN полеN;
}переменная1,переменнаяН;//переменные необязательны. Так можно объявить их.
структура.поле. //обращение к полю структуры.
указатель->поле //Обращение из указателя в поле. //при попытке обращения через точку, будет ощибка, тк указатель указывает на адрес. А у адреса нет поля.
Linear *p=&a; //P указатель на структуру А. И для обращения к её полям использует ->
cout<<p->second.x<<endl; //поле second уже не указатель.
/*или надо написать: */cout<<(*p).name<<endl; //Так тоже можно из указателя обратиться к полю структуры, на который он указывает.

Конструкторы{
Конструктор-метод инициализации структуры.
Конструктор-функция с именем совпадающем с именем структуры. Функция не должна возвращать ничего. Даже void.
Пример конструктора{

#include <iostream>
using namespace std; 
struct Point// {
	Point()// {
		x=222;
		y=333;
	// }
	Point(int x)// {
		this->x=444;
		y=555;
	// }
	Point(int q, int w)// {
		x=888;
		y=999;
	// }
	int x;
	int y;
// };
int main()// {
	Point p1;
	cout<<p1.x<<" "<<p1.y<<endl;	//222 333
	Point p2={2};
	cout<<p2.x<<" "<<p2.y<<endl;	//444 555
	Point p3={3,6};
	cout<<p3.x<<" "<<p3.y<<endl;	//888 999
	return 0;	
// }
В консоль выведет:
222 333
444 555
888 999
В зависимости от параметров, срабатывает конструктор с таким кол-вом параметров.
}//Конец области "Пример конструктора".
	
Если у структуры нет конструкторов, то компилятор сделает конструктор без параметров (конструктор по умолчанию). Если есть какой-то конструктор, и нужен конструктор по умолчанию-то ручками делаем его{
struct Point {
    Point(int x):x(x){}
    int x;
};
Point w1(5);//ОК
Point w2;//error: no matching function for call to ‘Point::Point()’
}//Конец области "делаем ручками конструктор по умолчанию"

Список инициализации{
Список инициализации позволяет проинициализировать поля до входа в конструктор.
struct Point// {
	Point():x(0),y(0)
	{}
	Point(int x,int y): x(x), y(y)
	{}
	int x;
	int y;
// };
Инициализация полей в списке инициализации происходит в порядке объявления ПОЛЕЙ.
Желательно в списке инициализации указывать поля в том порядке, в каком они объявлены, или может получится хрень, которую потом хрен отладишь{
struct Point// {
    Point(): y(5),x(y){}
    int x;
    int y;
// };
int main()// {
    Point w;
    cout<<w.y<<endl; //5
    cout<<w.x<<endl; //32767
    return 0;	
// }	
}//Конец области "хрень, которую потом хрен отладишь"
}//Конец области "Список инициализации"

Значения по умолчанию{
Функции могут иметь значения параметров по умолчанию.
Значения параметров по умолчанию нужно указывать в объявлении функции.
struct Point// {
	Point(int x=5,int y=0):x(x),y(y){}
	int x;
	int y;
// };
Point p1;
cout<<p1.x<<" "<<p1.y<<endl;//5 0
Point p2(2);
cout<<p2.x<<" "<<p2.y<<endl;//2 0
Point p3(3,4);
cout<<p3.x<<" "<<p3.y<<endl;//3 4
}//Конец области "Значения по умолчанию"

Конструкторы от одного параметра и неявное преобразование{
Конструкторы от одного параметра и принимающие только один параметр в целом равны ((int x) и (int x=0,int y=0))
Забавная ошибка:
struct Point // {
    Point(int i1){x=i1;}
    int x;
// };
Point w=5;
cout<<w.x<<endl;//5
w=999;
cout<<w.x<<endl;//999
------------------------
struct Point// {
    Point():x(0),y(0){}
    Point(int x):y(x){}
    int x;
    int y;
// };
Point p1;
cout<<p1.x<<" "<<p1.y<<endl; //0 0
Point p2=5;//неявное преобразование в Point p2(5)
cout<<p2.x<<" "<<p2.y<<endl; //4196816 5

Для конструкторов от одного параметров есть ключевое слово explicit
Ключевое слово explicit запрещает автоматическое создание конвертирующего конструктора
Для запрета неявного пользовательского преобразования используется ключевое слово explicit
explicit как модификатор конструкторов с одним параметром, чтобы такие конструкторы не функционировали как конструкторы неявного преобразования
struct Point// {
    Point():x(0),y(0){}
    explicit Point(int x):y(x){}
    int x;
    int y;
// };
 Point p1;
    cout<<p1.x<<" "<<p1.y<<endl;//0 0
    Point p2=5;// error: conversion from ‘int’ to non-scalar type ‘Point’ requested Point p2=5;
    cout<<p2.x<<" "<<p2.y<<endl;
С этим словом при попытке написать =n или ={n} будет ошибка выскакивать.
Большой пример{
	struct A
// {
    A(int) { }      // converting constructor
    A(int, int) { } // converting constructor (C++11)
    operator bool() const { return true; }
// };
 
struct B
// {
    explicit B(int) { }
    explicit B(int, int) { }
    explicit operator bool() const { return true; }
// };
 
int main()
// {
    A a1 = 1;      // OK: copy-initialization selects A::A(int)
    A a2(2);       // OK: direct-initialization selects A::A(int)
    A a3 {4, 5};   // OK: direct-list-initialization selects A::A(int, int)
    A a4 = {4, 5}; // OK: copy-list-initialization selects A::A(int, int)
    A a5 = (A)1;   // OK: explicit cast performs static_cast
    if (a1) ;      // OK: A::operator bool()
    bool na1 = a1; // OK: copy-initialization selects A::operator bool()
    bool na2 = static_cast<bool>(a1); // OK: static_cast performs direct-initialization
 
//  B b1 = 1;      // error: copy-initialization does not consider B::B(int)
    B b2(2);       // OK: direct-initialization selects B::B(int)
    B b3 {4, 5};   // OK: direct-list-initialization selects B::B(int, int)
//  B b4 = {4, 5}; // error: copy-list-initialization does not consider B::B(int,int)
    B b5 = (B)1;   // OK: explicit cast performs static_cast
    if (b2) ;      // OK: B::operator bool()
//  bool nb1 = b2; // error: copy-initialization does not consider B::operator bool()
    bool nb2 = static_cast<bool>(b2); // OK: static_cast performs direct-initialization
// }
}

}//Конец области "Конструкторы от одного параметра и неявное преобразование"

}//Конец области "Конструкторы и деструкторы"

Деструктор{
Деструктор - это метод, который вызывается при удалении структуры, генерируется компилятором.
Деструктор начинается с тильды ~ и имяСтруктуры.
Деструктор только один и не имеет параметров.
struct IntArray// {
	explicit IntArray(size_t size)
		:size(size)
		,data(new int[size])
	{}
	~IntArray()// {
		delete [] data;
	// }
	size_t size;
	int *data;
// };

Явный вызов деструктора:
struct Point// {
    ~Point()// {cout<<"This is dest"<<x<<endl;}
    int x;
    int y;
// };
int main()
// {
    Point *p=new Point;
    p->x=1;
    p->~Point();
    Point w;
    w.x=2;
    w.~Point();
    cout<<"func main run"<<endl;
    return 0;
// }
 Вывод:
 This is dest1
This is dest2
func main run
This is dest2
//Не совсем пойму, почему деструктор локальной переменной срабатывает 2 раза.
}//Конец области "Деструктор"
//Структуры - это способ синтаксически и физически сгруппировать логически связанные данные.
Метод - функция внутри структуры. У метода есть прямой доступ к полям структуры{
	
#include <iostream>
using namespace std; 
struct Point// {
    int x;
    int sum()// {
        int y=x+x; //прямой доступ к полю Х
        x=999;
        return y;
    // };
// };

int main()// {
Point w;
w.x=5;
cout<<w.sum()<<endl;	//10
cout<<w.x<<endl;		//999
return 0;
// }	
	
}//Конец области "Метод- функция внутри структуры. У метода есть прямой доступ к полям структуры"

Метод - обычная функция с неявным аргументом this:{

#include <iostream>
using namespace std; 
struct Point// {
    int x;
    int y;
    int sum()// {
        int y=x+x;
        x=999;
        return y;
    // };
    void swap(int x,int y)// { //такое же имя как и поля, без this обращение к локальному полю.
        this->x=x;
        this->y=y;
    // }
// };

int main()// {
Point w;
w.x=5;
w.y=888;
cout<<w.sum()<<endl;	//10
cout<<w.x<<endl;		//999
cout<<w.y<<endl;		//888
w.swap(22,11);
cout<<w.x<<endl;		//22
cout<<w.y<<endl;		//11
return 0;
// }	
Так как аргументы функции имеют такие же имена, как и поля, нужно использовать this или будет обращение к локальной переменной (аргументу функции).	
}//Конец области "Метод - обычная функция с неявным аргументом this"

Конструктор копирования и оператор присваивания{
Конструктор копирования, это конструктор, который принимает КОНСТАНТНУЮ ССЫЛКА на свой же класс.
Конструктор присваивания это ссылочный метод на оператор = принимающий КОНСТАНТНУЮ ССЫЛКУ на свой же класс. Должен вернуть указатель на this.
Желательно проверить if( this != & q ) вдруг ничего не надо придумывать, а просто вернуть *this.
struct Vasa // {
	Vasa & operator =(Vasa const & q)// {
		this->x=q.x*44;
		return *this;
	// }
	Vasa(Vasa const & q)//  { //конструктор копирования
		this->x = q.x * 11;
	// }
	Vasa(int x):x(x){  };
	int x;
// };
int main()
// {
	Vasa q(4);
	cout << q.x << endl;//4
	Vasa w = q;
	cout << w.x << endl;//44
	w = q;
	cout << w.x << endl;//176
    return 0;
// }
	
Чтобы запретить присваивание и копирование, можно объявить их как private и не определять. Если кто-то попробуем скопировать их, то произойдет ошибка компиляции, а если метод самого класса попробует скопировать, то получится ошибка линковки, т.к они объявлены, но не определены.
}//Конец области "Конструктор копирования"

Объявление и определение метода{//ВозвращаемыйТип ИмяСтруктуры::ИмяМетода()
#include <iostream>
using namespace std; 
struct Point// {
    int x;
    int y;
    char swap(int x,int y);//Просто объявление.
//  };

int main()// {
Point w={11,22};
cout<<w.swap(55,11)<<endl;
cout<<w.x<<endl;
return 0;
// }
//RETURNTYPE classname :: FunctionName
char Point::swap(int x,int y)// { 
    this->x=x+y;
	return 'w';
// }
На выходе получаем::
w
66	
}//Конец области "Объявление и определение метода"

Абстракция и инкапсуляция{
Абстракция-независимость от представления данных.
Инкапсуляция-возможность объединить вместе данные и методы работы с этими данными.
Пример одномерного массива, который ведет себя как двумерный{
struct IntArray2D// {
	int &get(size_t i,size_t j)// {
		return data[i*b+j];
	// }
	size_t a;
	size_t b;
	int * data;
// };
int main()// {
IntArray2D m={4,2};
m.data=new int[m.a*m.b];
for (size_t i=0;i!=m.a;i++)
	for(size_t j=0;j!=m.b;j++)
			m.get(i,j)=i+j;
    
for (int i=0;i!=m.a*m.b;i++)
    cout<<m.data[i]<<endl;
return 0;
// }
//Тут эта структура инкапсулирует в себе данные о двумерном массиве.
//Хранится одномерный массив, но при помощи метода абстрагируемся.
}//Конец области "Пример одномерного массива, который ведет себя как двумерный"

}//Конец области "Абстракция и инкапсуляция"

Структура и компилятор{
Определение структуры не генерирует никакого кода.
Структуры существуют только на момент компиляции.
Структура определяет, то как данные адресуются в памяти, как они располагаются.
Но после компиляции никакой информации о структурах в коде нет.
Вся работа происходит на уровне копирования одного массива байт на место другого.

}//Конец области "Структура и компилятор"

Осторожно!!Данные в структуре идут друг за другом {
//При ошибке с указателем, можно изменить совсем другой элемент класса.

#include <iostream>
using namespace std; 
struct Point // {
    int x;
    int y;
// };
int main() // {
Point v;
v.x=9;
v.y=11;
cout<<v.x<<" "<<&v.x<<endl; 	//9 0x7ffdb76766a0
cout<<v.y<<" "<<&v.y<<endl;		//11 0x7ffdb76766a4
int *p=&v.x;
cout<<p<<endl;					//0x7ffdb76766a0
cout<<(p+1)<<"::get Y"<<endl;	//0x7ffdb76766a4::get Y
*(p+1)=999;
cout<<v.y<<" ::this is y"<<endl;//999 ::this is y
return 0;
// }
//Если это не динамическая память, то при ошибке в размере массива может быть забавная ошибка:
#include <iostream>
using namespace std; 
struct Point// {
    int x[3];
    int y;
// };
int main()// {
Point v;
v.y=777;
for(int i=0;i<4;i++)// {
    v.x[i]=i*11;
// };
cout<<v.y<<endl; //33 //хотя надеялись на 777;
return 0;
// }

Забавно, когда класс в классе, где еще несколько классов:
Промахиваясь в одном классе, попадаешь в другой класс.
[ point first | point second ]
[   x	| y   |  x   |   y   ]
#include <iostream>
using namespace std; 
struct Point// {
    int x[3];
    int y;
// };
struct Linear// {
    Point first;
    Point second;
// };
int main()// {
Linear a;
for (int i=0;i<3;++i)// {
    a.second.x[i]=i*11+11;
// };
cout<<*a.second.x<<endl;	//11
a.first.x[4]=999;
cout<<*a.second.x<<endl;	//999
return 0;
// }

}//Конец области "Осторожно!!Данные в структуре идут друг за другом"

Структуры при определнии переменной можно проинициализировать{
Point p1={1,2};
Point p2={66,99};
Segment s={p1,p2};

struct IntArray2D// {
	size_t a;
	size_t b;
	int ** data;
// }
IntArray2D={n,m,create_array2d(n,m)};
}//Конец области "Структуры при определнии переменной можно проинициализировать"

}//Конец области "Структуры"

Классы и Объектно-ориентированное программирование{
//По умолчанию члены класса считаются закрытыми. ( private: ) Это единственная разница между классом и структурой.

Теория{
Объектно-ориентированное программирование - концепция программирования, основанная на понятиях объектов и классов.
Основные понятия:
	инкапсуляция - механизм позволяющий ограничить доступ одних компонентов программы к другим. Конструкция, позволяющая связать данные с методами, предназначенными для обработки этих данных.
	наследование-возможность создавать производные классы на основе базовых.
	полиморфизм	-возможность работы с подклассом через ссылку на базовый класс, т.е в терминах базового класса.
	абстракция- сокрытие реализации класса, при помощи ограничителей доступа, чтобы вызывающий код не знал о реализации и работал только в терминах интерфейса.
Полиморфизм-возможность единообразно обрабатывать разные типы данных. Есть такие его механизмы, как:
	1-Перегрузка функций: выбор функции происходит в момент компиляции на освове типов аргументов функциии, статический полиморфизм.
	2-Виртуальные методы: выбор метода происходит в момент выполнения на основе типа объекта, у которого вызывается виртуальный метод, динамический полиморфизм.
КЛАСС-описание некоторой структуры программы,
обладающей набором внутренних переменных ( СВОЙСТВ )
и функций, имеющих доступ к свойствам ( МЕТОДОВ ).
Инкапсуляция - процесс объединения переменных и методов, в результате которого и получается класс.
Объект-это экземпляр класса (для получения доступа к свойствам и методам класса).
Объявление класса начинается с ключевого слова class.
Синтаксис:
class имя_класса// {
закрытые поля и методы класса
public: //private
открытые поля и методы класса
// } список_объектов;
	
К закрытым членам класса можно обращаться только внутри класса,
в то время как открытые члены доступны и за его пределами.
	
//Описание метода класса: //Метод отдельно от класса.
тип_результата имя_класса::имя_метода(список_аргументов){ код_метода }
//в классе для этого надо только прототип определить и все:
//Прототип определяемого метода:
тип_результата имя_метода(список_аргументов);
	
Публичный интерфейс-набор методов доступных внешнему пользователю класса.
Это позволяет поддерживать инвариант класса, т.е сохранять данные объекта в согласованном состоянии.
Закрытие полей класса позволяет абстрагироваться от способа хранения данных объекта.

Класс-структура с методами, конструктором и деструктором.
Объект-экземпляр (значение) класса.

Агрегирование -включение объекта одного класса в качестве поля в другой.

Основополагающая идея ооп-объединение данных и действий, производимых над этими данными в единое целое, которое называется объектом.
Если необходимо считать данные-вызывается соответствующий метод. Прямой доступ  к данным невозможен. Данные сокрыты от внешнего воздействия, что защишает их от случайного изменений-данные и методы инкапсулированы. Если необходимо изменить данные- нужно обратиться к методу объекта. Никакие другие функции не могут изменять данные класса.
Полиморфизм-использование операций и функций различным образом в зависимости от того, с какими типами величин они работают.
Пример {//отделы компании.
объект, что-то вроде отдела компании -бухгалтерия, продажи, кадры. У каждого подразделения свои данные, с которыми оно работает - бухгалтерия это з\п, отдел кадров- информация о сотрудниках, отдел продаж- сведенья, касающиеся торговли. Сотрудники производят операции только с теми данными, которые относятся к данному отделу. Если у менеджера по продажам возникнет необходимость узнать суммарных оклад сотрудников за июль, то ему не нужно будет идти в бухгалтерию и рыться в архиве, ему достаточно послать запрос компетентрому лицу, которое найдет нужную информаци, обработает и вышлет ответ на запрос. } //Конец области пример.

}//Конец области "Теория"

Для создания объекта в динамической памяти используется оператор new. Он отвечает за вызов конструктора.{
struct Point// {
    explicit Point(int x=0,int y=0)
        :x(x)
        ,y(y)
        {};
    int x;
    int y;
// };
//Выделение памяти и создание объекта.
Point *p=new Point(5,9);
cout<<p->x<<" "<<p->y<<endl; //5 9
При delete сначало вызывается деструктор, а потом освобождается память.
delete p;//вызов деструктора и освобождение памяти.
//вылеоение памяти и создание 10 объектов.
//вызывается конструктор по умолчанию.
IntArray *pa = new IntArray[10];
delete [] pa;//вызов деструктора и освобождение памяти.
}//Конец области "объект и динамической памяти и delete && new"

Если все у класса закрыто, а править его надо:{
//https://cppforeach.wordpress.com/2008/05/19/around_access_modifiers/
struct Cls // {
Cls(char c, double d, int i);
private:
	char c;
	double d;
	int i;
 // };
 //Создаем класс такой же структуры:
class hack_some // {
public:
  char c;
  double d;
  int i;
// };
char &get_c(Cls &cls) // {
    return reinterpret_cast<hack_some*>(&cls)->c;//правим поле "с".
// }
}//Конец области "Если все у класса закрыто, а править его надо:"

const методы Константный указатель на структуры и констрантные структуры{
методы класса могут быть констрантными. Такие методы не могут менять поля объекта.
Методы, которые не изменяют поля объекта.
struct vasa// {
    void v() const// { //этот метод не может менять поля класса.
		cout<<"v"<<endl; 
		x=888; //вообще не скомпилируется error: assignment of member ‘vasa::x’ in read-only object
		// }
    int  q() const{ cout<<"q"<<endl; }
    int  r()      { cout<<"r"<<endl; }
    int x;
// };
vasa w;
    vasa const *p=&w;
    p->q(); //работает. Выведет "q" в консоль.
	p->r(); //error: passing ‘const vasa’ as ‘this’ argument of ‘int vasa::r()’ discards qualifiers [-fpermissive]
	p->x=999;	//error: assignment of member ‘vasa::x’ in read-only object
	
Константный указатель на класс применять только констрантные методы.
Константный указатель не может менять поля объекта.
Внутри констрантного метода нельзя вызвать обычный метод. Констрантный указатель не дает через констнатный метод неявно изменять переменные.

У констратного метода const является частью сигнатуры метода-часть имени метода.
При определении в заголовочном файле, надо тоже писать конст.
Так можно определить два метода-констратный метод и обычный с одинаковым именем.{
struct vasa// {
    void v() const{ cout<<"const"<<endl;}
    int  v()      { cout<<"No const,NO"<<endl; }
    int x;
// };	
vasa w;
vasa const * v=&w;
v->v();//const
w.v();//No const,NO
У констратного вызовется констратный метод. У изменяемого обычный.
}

}//Конец области "Константный указатель на структуры и констрантные структуры"

Аккуратно с синтаксической и логической константностью{
Вроде и констратный метод, который поле изменить не может.
Но указатель содержит адрес-указатель не меняется, а значение указателя меняется.
Синтаксически все верно, а логически не совсем может быть.
struct vasa// {
   void get(int g) const// {
       cout<<"this is const"<<endl;
       *x=g;
   // } 
   int *x;
// };

    int qwe=999;
    vasa w;
    w.x=&qwe;
    cout<<*w.x<<endl;
    vasa const *p=&w;
    p->get(333);
     cout<<*w.x<<endl;
	
}//Конец области "Аккуратно с синтаксической и логической константностью"

Компилятор генерирует четыре метода:
	1-Конструктор по умолчанию,
	2-Конструктор копирования,
	3-оператор присваивания,
	4-деструктор.
Если нужно переопределить деструктор, оператор присваивания или конструктор копирования, то значит в объекте есть сложные данные и надо будет и остальные переопределить.

Наследование{
struct Derived : <modifier> Base { };
где <modifier> — это одно из ключевых слов public, protected или private.
struct A{};
struct B1 : public A {};
struct B2 : private A{};//все что пришло из А можно менять только B2 и наследники B2 не могут использовать методы A. Внешний код и наследники не имеют к полям унаследованным от А доступ.
struct B3 : protected A{}; //Наследники могут использовать поля и методы А, а внешний код нет.
Если модификатор не указан явно, используется по умолчанию:
	структуры - public
	класс - private
У класса наследника есть те же методы и поля родительского класса.
Наследование — это определение производного класса, который может обращаться ко всем элементам и методам базового класса за исключением тех, которые находятся в поле private;

Внутри класса наследника хранится экземпляр родительского класса.
	x		 x y
   vasa		Petay //В начале класса наследника хранятся поля класса родителя.
struct Vasa // {
	Vasa() :x(4) {}
	int x;
// };
struct Petay :Vasa // { //Petay наследуется от Vasa
	int y;
// };
int main() // {
	Vasa w;
	cout << w.x << endl;//4
	Petay q;
	cout << q.x << endl;//4
	q.y = 9;
	cout << q.y << endl;//9
	cout <<"На одну левее Х: "<< *((&(q.y)) - 1) << endl; //Если от памяти ячейки Y обратится на одну левее, там находится ячейка Х
    return 0;
// }

	
}//Конец области "Наследование"

Конструктор, деструктор производного класса{
При создании объекта произвольного класса сначала вызывается конструктор родительского класса.
Те поля, которые добавлены в классе наследник, инициализируются внутри конструктора класса наследника, те поля, которые унаследованы от родителя, инициализируются внутри конструктора родительского класса.

class Base_Men // { //Это класс и надо явно указывать public иначе даже конструктор не создадим
public:
	Base_Men(): base(123456) { cout << "alive Base_Men" << endl; }
	~Base_Men() { cout<<"base men dest"<<endl; }
	int base;
// };
struct Vasa:Base_Men // {
	Vasa(int x, int y) :x(x), y(y)// { //По хорошему, надо тут вызвать конструктор Base_Men в явном виде, но с этим и компилятор справится, ничего сложного нет. 
	cout << "alive Vasa" << endl; // }
	~Vasa() { cout << "Vasa dest" << endl; }
	int x;
	int y;
// };
struct Petay :Vasa // {
	Petay(int x, int y, int z) :z(z), Vasa(x, y) { cout << "alive Petay" << endl; };
	~Petay() { cout << "Petay dest" << endl; }
	int z;
//  };
int main()// {
	Petay q(111,333,888);
	cout << "base:" << q.base << endl;
	cout << "x:"<<q.x << endl;
	cout << "y:"<<q.y << endl;
	cout << "z:" <<q.z << endl;
    return 0;
// }// в итоге получаем:
alive Base_Men
alive Vasa
alive Petay
base:123456
x:111
y:333
z:888
Petay dest
Vasa dest
base men dest        
//Такие сообщения появились-в порядке убывания вызывается деструктор
При удалении производного класса, сначало вызывается деструктор производного класса, а потом родительского.
А при создании сначало конструктор родительского класса, а потом его наследника.
В «С++» конструкторы при наследовании вызываются последовательно от самого раннего предка до самого позднего потомка, а деструкторы наоборот — от самого позднего потомка до самого раннего предка.
}//Конец области "Конструктор, деструктор производного класса"

Привидение-из производного получем ссылку||указатель на базовый класс{
struct Men // {
	Men(string q1, int q2) :name(q1), age(q2) {}
	Men(Men const & q) // {
		cout << "coping" << endl;
	// }
	Men & operator =(Men const & q)// {
		cout << "operator =" << endl;
		this->age = q.age * 44;
		this->name = "Petay";
		return *this;
	// }
	string name;
	int age;
// };
struct Student :Men// {
	Student(string q, int x, string y) :Men(q,x), institute(y){};
	string institute;
// };
int main() // {
	Student vasa("Vasa", 18, "Harvard University");
	cout << "name:" << vasa.name << " institute:" << vasa.institute << endl;
	Men &p = vasa;
	cout <<"p "<< p.name << " " << p.age << endl;
	Men *p1 = &vasa;
	cout <<"p1 "<< p1->name << " " << p1->age << endl;

	Men LittleVasa = vasa;//Тут работает конструктор копирования
	Men VeryLittleVasa(vasa); //Тут работает конструктор копирования
	Men ForVasa("vasa",22);
	ForVasa = vasa; //Тут работает оператор присваивая определенный в Men
	cout << "ForVasa " << ForVasa.name << " " << ForVasa.age << endl;
	return 0;
// }
name:Vasa institute:Harvard University
p Vasa 18
p1 Vasa 18
coping
coping
operator =
ForVasa Petay 792   
Объекты наследники могут присваиваться объектам родительского класса.
Копируются только поля класса родителя.
В обратную сторону это не работает. Можно только из наследника получить родительский класс. Из родительского класса наследника не получить.
	
}//Конец области "Привидение-из производного получем ссылку||указатель на базовый класс"

Перегрузка{
Перегрузка- возможность определить несколько функций с одним именем, но различными параметрами.	При вызове такой функции по имени компилятор будет выбирать наиболее подходящую основываясь на типе и количестве аргументов.
В языке Си перегрузки нет.
double square (double d){return d*d}
int square (int i ){return i*i}

int a=	 square (4);	//square(int)      4 это число.
double b=square (3.14);	//square(double)   3.14 это доубле
double c=square (5);	//square(int)      5 это число инт потом переделается в доубле при инициализации переменной.
int d=   square (b);	//square(double)   b это доубле, потом возвращаемое доубле округлится в инт при инициализации переменной. 
float e= square (2.71f);//square(double)  //2.71f это флоат, а для него доубле ближе
Играет роль только то, какой аргумент получает функция.
Тип возвращаемого значения не учитывается. Это к функции вообще никакого отношения не имеет- будет при инициализации переменной переделывается инд в доубле и наоборот.


struct Men // {
	void write(string q) { cout << q << endl; }
	void write(char q) { cout << "CHAR"<<endl; }
// };
struct Student :Men// {
	void write(int x) { cout << "work int x" << endl; }
	using Men::write;  //без этого компилятор не будет учитывать базовые методы с таким именем.
	int y;
// };
int main() // {
	Student vasa;
	vasa.write("qwe");
	vasa.write('q');
	return 0;
// }

Когда мы определяем в производном классе методы с таким же именем, как и в базовом то эти методы перекрываю базовые-переопределяют их, а using Base::func показывает, что это не переопределение функции, а перегрузка и мы хотим использовать функции из базового класса.

Аккуратно с правилами перегрузки. Если нет точного совпадея, он попробуетн найти функцию, которая СТРОГО ЛУЧШЕ остальных. Если есть две, одинаково подходящие, то он крякнется, тк не сможет определить самую лучшую.

Перегрузка выполняется на этапе компиляции.
}//Конец области "Перегрузка"

Переопределение{//overriding
struct Men // {
	string Hello() { return "MyNameBaseMen"; };
// };
struct Student :Men// {
	void Hello() // { 
		string str = "my method+" + Men::Hello(); //обращение к методу базового класса.
		cout << str << endl;
	// };
// };
int main() // {
	Student vasa;
	vasa.Hello();
	Men *p = &vasa;
	cout << p->Hello() << endl;
	return 0;
// }
Выведет в консоль:
my method+MyNameBaseMen 
MyNameBaseMen
Так можно переопределить метод, из производного класса можно обратится к методу базового класса
}//Конец области "Переопределение"

Виртуальные методы{
Если объявить виртуальный метод, то метод вызванный будет зависит не от типа указателя, а от значения класса, на который он указывает.
Виртуальный метод (виртуальная функция) — в объектно-ориентированном программировании метод (функция) класса, который может быть переопределён в классах-наследниках так, что конкретная реализация метода для вызова будет определяться во время исполнения. Таким образом, программисту необязательно знать точный тип объекта для работы с ним через виртуальные методы: достаточно лишь знать, что объект принадлежит классу или наследнику класса, в котором метод объявлен. 
Виртуальные методы — один из важнейших приёмов реализации полиморфизма. Они позволяют создавать общий код, который может работать как с объектами базового класса, так и с объектами любого его класса-наследника. При этом базовый класс определяет способ работы с объектами и любые его наследники могут предоставлять конкретную реализацию этого способа.
Базовый класс может и не предоставлять реализации виртуального метода, а только декларировать его существование. Такие методы без реализации называются «чистыми виртуальными» (перевод англ.  pure virtual) или абстрактными. Класс, содержащий хотя бы один такой метод, тоже будет абстрактным. Объект такого класса создать нельзя (в некоторых языках допускается, но вызов абстрактного метода приведёт к ошибке). Наследники абстрактного класса должны предоставить реализацию для всех его абстрактных методов, иначе они, в свою очередь, будут абстрактными классами. Абстрактный класс, который содержит только абстрактные методы, называется интерфейсом.
struct Men // {
	virtual void Hellow() { cout << "Base struct" << endl; }
// };
struct OldMen : Men // {
	void Hellow() { cout << "OldMen"; Men::Hellow(); }
// };
struct WoMen :Men // {
	void Hellow() { cout << "WOOOOmen" << endl; }
// };
int main()
// {
	OldMen old;
	Men * boy = &old;
	Men * girl = new WoMen;
	old.Hellow();	//OldMenBase struct     
	boy->Hellow();	//OldMenBase struct   
	girl->Hellow();//WOOOOmen  
    return 0;
// }
girl это указатель на Men, но так как метод virtual, то вызывается метод того, на что он указывает.
Если не указывать virtual (' void Hellow() { cout << "Base struct" << endl; } ') тогда:
OldMenBase struct
Base struct //и boy использует базовый метод
Base struct //и girl использует базовый метод 

Если не указывать virtual, то конкретный адрес метода который будет вызван через указатель на базовый класс будет подставлен на этапе компиляции.
Если указать virtual, то адрес конкретного метода который будет вызван будет зависить от того, какое значение сейчас хранится в указателе, и значит этот адрес будет выбираться на этапе выполнения программы.

False Невиртуальные методы не могут вызывать виртуальные методы.{
virtual void v() { cout << "wer" << endl;  }
void w() { cout << "hhhh" << endl;v(); }
}
False Обращение к объекту по ссылке не позволяет вызывать виртуальные методы.
True Виртуальные методы могут вызывать невиртуальные методы.{
virtual void v() { cout << "wer" << endl; this->w(); }
void w() { cout << "hhhh" << endl; }
}
True Все виртуальные методы базового класса являются виртуальными и для производных классов. {
BaseClass->Vasa->Petay->ola и ola можно приравнять к базовому классу и вызывать виртуальный метод.
struct Men // {
	virtual void v(){ cout << "wer" << endl;  }
// };
struct OldMen : Men // {

// };
struct q :OldMen // {
	void v() { cout << "q class" << endl; }
// };
int main()
// {
	Men *p=new q;
	p->v();  //"q class"
    return 0;
// }
}
True Виртуальные методы могут быть константными.{
virtual void v() const{ cout << "wer" << endl;  }
}
False Для того, чтобы вызвать виртуальный метод, объект должен быть создан через new.{
Men p1;
p1.v();
virtual void v() const{ cout << "wer" << endl;  }
}
False Виртуальный метод можно вызвать только через указатель на объект.{
Men p1;
p1.v();
virtual void v()const { cout << "wer" << endl; }
}
}//Конец области "Виртуальные методы"

Чистые виртуальные (абстрактные) методы и абстрактный класс{ //см виртуальные методы.
Абстрактный класс в C++ - это класс, в котором объявлена хотя бы одна чисто виртуальная функция.
Абстрактный класс в объектно-ориентированном программировании — базовый класс, который не предполагает создания экземпляров. 
Абстрактный класс предназначен для написание набросок приложения. То есть разработчик пишет программу, или некоторый функционал и если разработчик опытный, он для начала будет писать проектировку работы программы, а именно проектировку методов, который будет наследовать будущий класс. Абстрактный класс не несет в себе никакую функциональность, это только наброски
	
struct Men // {
	virtual void Bay() = 0;
// };
struct OldMen : Men // {
	void Bay() { cout << "oldBay" << endl; }; //Если не переопределить все абстрактные методы, класс объявят абстрактным и его нельзя будет создать.
// };
struct WoMen :Men // {
	void Bay() { cout << "womenBay" << endl; }//Если не переопределить все абстрактные методы, класс объявят абстрактным и его нельзя будет создать.
// };
int main()
// {
	OldMen old;
	Men * boy = &old;
	Men * girl = new WoMen;
	old.Bay();	//oldBay
	boy->Bay();	//oldBay
	girl->Bay();//womenBay
    return 0;
// }
Допустим перебирается массив, в котором женщины и мужчины вместе. У каждого элемента нужно вызвать функцию. Нельзя использовать указатель на женщину или мужчину, т.к. в указатель мужчина нельзя переместить адрес женщины и наоборот. Зато можно адреса их запихивать в указатель на базовый класс и вызывать метод.
}//Конец области "Чистые виртуальные (абстрактные) методы и абстрактный класс"

Виртуальный деструктор{
Если есть хоть одна virtual функция, то нужно делать virtual деструктор.
Если класс наследник сложный, располагается в динамической памяти, то при работе с ним как с указателем на базовый класс при удалении сработает деструктор базового класса и удалит все поля базового класса. Про то что у наследника есть свои поля, он может и не знать. Потенциальная утечка памяти. А если объявить деструктор virtual, то сработает деструктор класса наследника и потом как и должно по убыванию сработают деструкторы базовых классов.
struct Men // {
	int x;
	~Men() // {
		cout << "BaseDest" << endl;
	// }
// };
struct OldMen : Men // {
	OldMen(int y): y(y){}
	int y;
	~OldMen() // {
		cout << "OldDest" << endl;
	// }
// };
int main()
// {
	Men *p = new OldMen(123987);
	p->x = 4;
	cout << p->x << endl;
	cout << *(&(p->x)+1) << endl;
	delete p;
    return 0;
// }
В консоль выведет:
4
123987
BaseDest    
Таким образом конструктор OldMen не вызывается.
В динамической памяти осталась переменная OldMen.y т.к базовый класс вообще не знает или может не знать, какие есть поля есть у наследников и удаляет только свои поля. 
А если объявить базовый деструктор virtual (' virtual ~Men() { ') тогда в консоль выведет:
4
123987
OldDest
BaseDest 
Тут срабатывает деструктор класса наследникаи потом уже базовый, полностью все удаляя.
}//Конец области "Виртуальный деструктор"

Таблица виртуальных методов{
Динамический полиморфизм реализуется при помощи таблицы виртуальных методов. (Виртуальные методы: выбор метода происходит в момент выполнения на основе типа объекта, у которого вызывается виртуальный метод). 
Таблица заводится для каждого полиморфного класса.
В C++ все функции по умолчанию имеют раннее связывание, то есть компилятор и компоновщик решают, какая именно функция должна быть вызвана, до запуска программы. Виртуальные функции имеют позднее связывание, то есть при вызове функции нужное тело выбирается на этапе выполнения программы.

Встретив ключевое слово virtual, компилятор помечает, что для этого метода должно использоваться позднее связывание: для начала он создает для класса таблицу виртуальных функций, а в класс добавляет новый скрытый для программиста член — указатель на эту таблицу. (На самом деле, насколько я знаю, стандарт языка не предписывает, как именно должен быть реализован механизм виртуальных функций, но реализация на основе виртуальной таблицы стала стандартом де факт

для каждого класса у нас будет создана таблица виртуальных функций. Каждой виртуальной функции базового класса присваивается подряд идущий индекс (в порядке объявления функций), по которому в последствие и будет определяться адрес тела функции в таблице VTABLE. При наследовании базового класса, производный класс «получает» и таблицу адресов виртуальных функций базового класса. Если какой-либо виртуальный метод в производном классе переопределяется, то в таблице виртуальных функций этого класса адрес тела соответствующего метода просто будет заменен на новый. При добавлении в производный класс новых виртуальных методов VTABLE производного класса расширяется, а таблица базового класса естественно остается такой же, как и была. Поэтому через указатель на базовый класс нельзя виртуально вызвать методы производного класса, которых не было в базовом — ведь базовый класс о них ничего «не знает» 

Вызов виртуального метода-это вызов метода по адресу из таблицы.
p->read(); //p->vprt[1]();
}//Конец области "Таблица виртуальных методов"

Переопределение private virtual методов{
Если есть функция, которая вызывает виртуальный приватный метод, то можно переопределить этот метод и изменится реализация функции:

struct A // {
	void getA()// {
	cout << "getA" << endl;
	setA();
	// }
private:
	void setA() { cout << "set A" << endl; };
// };
struct B: A // {
private:
void setA() { cout << "structB run:: ";}
// };
int main()
// {
	B w;
	w.getA();
    return 0;
// }
Выведет в консоль:
getA
set A 
А если сделать setA virtual`ьным ('virtual void setA() { cout << "set A" << endl; }'):
getA
structB run::
Так можно изменить метод setA не изменяя и не переопределяя его. Это будет шаблоном метода.
Шаблонный метод (Template method) — паттерн поведения классов, шаблон проектирования, определяющий основу алгоритма и позволяющий наследникам переопределять некоторые шаги алгоритма, не изменяя его структуру в целом.
}//Конец области "Переопределение private virtual методов"
	
Реализация чистого виртуального метода (абстрактного метода){
Для чистого виртуального метода можно определить реализацию, однако адрес этой реализации не попадет в таблицу виртуальных методов. В соответствующей ячейке будет записан адрес обработчика ошибки, что мы вызвали чистый виртуальный метод.
Метод в базовом классе чистый виртуальный-абстрактный, заставляет в производном классе переопределить этот метод, однако за счет того, что есть реализация этого метода базового класса, мы можем вызвать в реализованном методе производного класса, считая что это реализация метода по умолчания. Для этого вызываем его, как будто он не виртуальный- указываем полное имя метода (имя класса и имя метода). Когда мы вызываем метод через полное имя (имя класса и имя метода) этот вызов происходит не виртуально.
struct A // {
	virtual void getA() = 0;
// };
void A::getA() { cout << "This is virtual getA()=0;" << endl; }
struct B: A // {
	void getA() { cout << "structBrun" << endl; A::getA(); }
// };
int main()
// {
	B w;
	w.getA();
    return 0;
// }
Выведет:
structBrun
This is virtual getA()=0;
Метод базового класса надо будет определять отдельно (указывая A::getA()) за пределами класса. В классе рядом реализовать его нельзя- будет ошибка компиляции.
это нужно, когда мы хотим заставить наследников определять этот метод самостоятельно, но при этом если уж совсем не хочется, то есть стандартная реализация.
}//Конец области "Реализация чистого виртуального метода (абстрактного метода)"

Интерфейс{
Интерфейс - это абстрактный класс, у которого отсутствуют поля, а все методы являются чистыми виртуальными (абстрактными), в С++ это не касается деструктора, он может быть виртуальным, но у него должна быть реализация т.к у производного класса в конце вызывается деструктор базового класса, и если у него нет реализации- будет ошибка компиляции.
Отличие от базового класса в том, что интерфейс только задает методы, которые должны быть у производных классов.
}//Конец области "Интерфейст"

Множественное наследование{
В С++ разрешено множественное наследование:
struct Person {};
struct Student : Person {};
struct Worker : Person {};
struct WorkingStudent : Student, Worker{};
В итоге WorkingStudent унаследует два Person, т.к и Student и Worker оба наследуются от Person. По идее будет черт знает какая хрень с дублирующимися полями и в какой-то момент комплятор не сможет определить какую функцию мы вызываем и крякнется. Лучше наследоваться от одного класса и добавлять интерфейсы.

У класса будут могут быть функции, которые есть в обоих классах. Их надо переопределить, или вызвать явно.
struct alive// {
	int id;
// };
struct Men:alive// {
    void name(){cout<<"Men"<<endl;}  
// };
struct Women:alive// {
    void name(){cout<<"Women"<<endl;}  
// };
struct Person:Men,Women{};
int main()//  {
     Person vasa;
     vasa.Women::name(); //нужно или явно вызывать функции, или переопределить.
	 vasa.Men::name();	//Просто vasa.name(); выдаст ошибку: // request for member ‘name’ is ambiguous
   return 0;
 // }
 Если не переопределить поле int id; у Person, не скомпилируется. Или у Men && Women делать виртуальное наследование об alive
 А если переопределить:
 struct Person:Men,Women// {
	 int id;
    void name(){return Women::name();} 
// };
И можно вызывать явно: vasa.name();

Так как объект в памяти размещается, как объекты в памяти базовых классов и собственные поля, то Person будет в памяти выглядеь:
[alive][Men][alive][Women][Person]
Даже с переопределенным int id у Person остаются int id от Men и int id от Women:{
Person vasa;
vasa.name();
vasa.id=876;
Men *m=&vasa;
Women *w=&vasa;
cout<<&m->id<<endl;//0x7ffca7ca8b60
cout<<&vasa.Men::id<<endl;//0x7ffca7ca8b60  //они равны.
cout<<&w->id<<endl;//0x7ffca7ca8b64
cout<<&vasa.id<<endl;//0x7ffca7ca8b68
Судя по тому, что адреса отличаются только последними цифрами, 0,4,8, то каждое поле занимает 4 бита и идут последовательно{
cout<<w->id<<endl;	//32764
*((&m->id)+1)=111;	
cout<<w->id<<endl;	//111
*((&m->id)+2)=222;	
cout<<vasa.id<<endl;//222
}//Конец области "Последовательно ли идут"

}//Конец области "int id от Men и int id от Women"

Конструкторы будут идти, начиная с левой ветки, с самого левого.
	A[1]				A[4] C[5]				
	|					  |  |
	B[2]	C[3]	       D[6]
	|______  |  __________|
		   | | |
			E[7]
Тут и класс А входит два раза и класс С. Притом к С, конструктор которого вызовется третьим нельзя обратиться-его функции определены у С, конструктор которого вызовется пятым и который наследуется в D.
}//Конец области "Множественное наследование"

Перегрузка операторов{
Мы сами определяем типы, которые принимает оператор (класс и класс (2 аргумента)) или (класс и число(2аргумента)) или (просто класс (1 аргумент)(-класс или +класс)). Возвращаемое значение мы сами выбираем.
У классов можно перегружать операторы. Почти все кроме трех.
Можно настроить вывод класса, как в python:
struct vasa// {
	int x;
	// };
ostream & operator<<(ostream &x,vasa const &y)// {
    x<<y.x<<" in:"<<&y<<endl;
    return x;
// }
int main()// {
    vasa w;
    w.x=9;
    cout<<w;
    return 0;// }
В консоль выведет: "9 in:0x7ffec0ac3030"
Если переопределять операторы приведения к типу, то они не возвращают значения, надо писать приблизительно так: "operator bool(){ return true} " это выглядит:
struct vasa// {
    int x;
    operator bool()// {
        return (x>5)? true: false;
    // }
    operator int()// {
        return x;
    // }
// };

vasa w;
w.x=9;
cout<<bool(w)<<endl; //1
cout<<(bool)w<<endl; //1
w.x=1;
cout<<(bool)w<<endl; //0
cout<<w.x-7<<endl;	//-6
cout<<w.x+10<<endl; //11
	
Так например можно прибавить к классу число:

struct vasa{ int x; };

vasa operator*(vasa const &q,int p)// { //необходимо именно два аргумента-сам класс и число.
    vasa r;
    r.x=1230987;
    return r;
// }

int main()// {
    vasa q;
    q.x=4;
    cout<<q.x<<endl;	//4
    q=q*999;
    cout<<q.x<<endl;	//1230987
    return 0;
// }
В перегрузке важна последовательность, если оператор: vasa operator*(vasa const &q,int p), то он должен вернуть класс vasa и при умножении первый аргумент будет vasa, а второй int. Если в данном случае число попытатся умножить на класс, то будет ошибка.
По сути мы просто перезагружаем операторы (*+-=) и они ведь вообще никакого отношения к классу не играют, главное чтобы в операторе был класс можно написатьч то-то вроде:
void operator+(vasa &q,int p)// {
    q.x=4567;
// }
vasa q;
q.x=4;
cout<<q.x<<endl; //4
q+7;
cout<<q.x<<endl; //4567
И тогда оператор сложения класса и числа не будет ничего возвращать-просто сразу изменит класс. Перегрузить операторы можно только, если в нем участвует класс:
int operator-(int x, int y){ return x*2;} //выдаст ошибку:error: ‘int operator-(int, int)’ must have an argument of class or enumerated type
Только операторы, в которых участвует класс мы можем перезагружать.
struct Person // {
	Person(): x(123) {};
	int x;
	Person operator = (Person v) // {  //В каждом метода есть неявный аргумент this. По этому можно просто написать один аргумент, т.к один уже и так есть.
		this->x = 876;
		return *this;
	// }
// };
int main()
// {
	Person q;
	Person w;
	cout << "w:" << w.x << "|q:" << q.x << endl;		//w:123|q:123
	w = q;
	cout << "After: w:" << w.x << "|q:" << q.x << endl;	//After: w:876|q:123     
    return 0;
// }
Так же можно написать operator- который не вычитает, а просто меняет значения класса местами, тогда понадобится тольк один аргумент:
struct vasa{int x;};
vasa operator-(vasa x)// {
    x.x=-x.x;
    return x;
// }
int main()// {
    vasa w;
    w.x=9;
    cout<<w.x<<endl; //9
    w.x=-w.x;
    cout<<w.x<<endl; //-9
    return 0;// }
Есть момент с тем, где определять оператор  внутри или снаружи. Они возможно они могут по разному действовать на основании того, что внутренний идет как метод, для этого объект должен существовать- у него уже должен быть вызван конструктор. А можно пытаться инициализировать объект черт знает как, одновременно прибавляя к нему другой. Тогда приведение типов может не сработать. ( vasa q;vasa w="name"+q;)
}//Конец области "Перегрузка операторов"

Виртуальное наследование{
Если база виртуальная, то она может находиться где угодно. Обычно компиляторы распологают её в конце. Если класс А наследуется от Б, то в памяти сначало А, а потом идут поля Б. Но при виртуальном наследовании, идут сначало поля Б, а потом поля А. Или поля А вообще могут находиться в другом месте.
При приведении указателя к подклассу, компилятор через служебный метод-через указатель на таблицу виртуальных методов, или запись на ней, переходит на поле:
t->id преобразуется во что-то вроде: t->__getUnitPtr__()->id;
И если так часто обращаться, будет понижена производительность за счет доп обращений. 
Конструктор базового класса надо явно указать. Виртуальный базовый класс является предком, но нужно его явно вызвать.
Во множественном наследовании надо черт знает сколько конструкторов вызывать. Для каждого виртуального базового класса вызывать явно.
Если класс наследует два класса, у которых общий предок, то можно сделать виртуальное наследование.
struct alive{
	int id;
};
struct Men:virtual alive{
    void name(){cout<<"Men"<<endl;}  
};
struct Women:virtual alive{
    void name(){cout<<"Women"<<endl;}  
};
struct Person:Men,Women{
    void name(){return Women::name();} 
};
int main()
 {
     Person vasa;
     vasa.name();
     vasa.id=876;
     Men *m=&vasa;
     Women *w=&vasa;

    cout<<&w->id<<endl;	//0x7fffbc8d10f0
    cout<<&m->id<<endl;	//0x7fffbc8d10f0
    cout<<&vasa.id<<endl;//0x7fffbc8d10f0
   return 0;
 }
 У Person только один id. База virtual склеилась, и осталось только одна.
}//Конец области "Виртуальное наследование"

}// Конец области "Классы и Объектно-ориентированное программирование"

Шаблоны{
Шаблоны бывают двух типов:
• Шаблоны функции (Function Templates)
• Шаблоны класса (Class Templates)

Простейшую функцию-шаблон в общем виде можно записать так:
template <class Type> заголовок
// {
тело функции
// }
У шаблонных функций нет параметров по умолчанию.
У шаблонного класса есть параметр по умолчанию, можно задать каждому шаблоному-параметру свой параметр по умолчания:
template <typename  T1=int,
		  typename  T2=char *>
struct Vasa// {
    T1 x1;
    T2 x2;
// };
Vasa <>q;
q.x1=3456;
q.x2="Hellow";
cout<<q.x1<<" "<<q.x2<<endl; //3456 Hellow
Vasa <char>w;
w.x1='r';
w.x2="Hellow";
cout<<w.x1<<" "<<w.x2<<endl;//r Hellow
Можно не всегда указывать тип шаблонной функции, компилятор может сам определить её по аргументам, если они одинаковые и подходят:
template <typename T> T f(T x){return x+x;}
cout<<f(9)<<endl;
cout<<f((string)"qwe")<<endl;

Шаблоны методов:
Не могут быть шаблонными:
	конструктор копирования,
	конструктор присваивания,
	конструктор по умолчанию,
	деструктор.
	Виртуальный метод.
В теории говорили, что нельзя, но в vs получилось:{
#include "stdafx.h"
#include <iostream>
using namespace std;

struct vasa // {
	template <typename T>
	vasa(T x):x(x),y(200) {}
	int x;
	int y;
// };
int main()
// {
	vasa q('5');
	cout << q.x << endl; //55 выдаст. 
	cout << q.y << endl;
    return 0;
// }
}


Для шаблонной функции есть перегрузка, и её можно перегрузить, а одной вызвав другую. Чтобы какая-то функция имела меньше шаблонных параметров, можно перезагрузить её.Шаблоны функций также можно перегружать другими шаблонами функций, изменив количество передаваемых параметров в функцию. Еще одной особенностью перегрузки является то, что шаблонные функции могут быть перегружены обычными не шаблонными функциями. То есть указывается то же самое имя функции, с теми же параметрами, но для определенного типа данных, и все будет корректно работать.
Пример:
	template <typename  T>
	T get(T q)// {
		return q*2;
	// }
Пример шаблона:
template <template-parameters> function-declaration 
template <class SomeType> SomeType sum (SomeType a, SomeType b) {return a+b; }
Использование:
name <template-arguments> (function-arguments)
x = sum<int>(10,20);
Можно передать несколько параметров:
template <class T1, class T2, class T3> и это будет работать так:
template <class T1, class T2, class T3>
struct Vasa// {
    T1 x1;
    T2 x2;
    T3 x3;
// };
Vasa <int,char*,char>q;
    q.x1=3456;
    q.x2="Hellow";
    q.x3='h';
    cout<<q.x1<<" "<<q.x2<<" "<<q.x3<<endl; //3456 Hellow h

Опасный момент в шаблонах связанный с очередностью выбора шаблона в зависимости от положения его в коде.{
template<typename T> void foo(T){cout<<"1"<<endl;} // 1
template<> void foo(int*){cout<<"2"<<endl;}   // 2
template<typename T> void foo(T*){cout<<"3"<<endl;} // 3


int main()// {
    int i;
	foo(&i);
    return 0;
// }
Тут сработает третья функция.
Если удалить первую и третью-будет ошибка. Вторая функция сама по себе не работает.
}//Конец области "Опасный момент в шаблонах связанный с очередностью выбора шаблона в зависимости от положения его в коде."
В общем есть 
1. Обычные функции;
2. базовые шаблоны. Это функции вида template<typename T> void bar(T);
3. Специализации шаблонов функций.

Специализация шаблонов функций, идет ПОД шаблонной функции.
Сначала выбирается лучший кандидат среди обычных функций и базовых шаблонов, причем предпочтение отдается обычным функциям.
Если же более подходящим является базовый шаблон, то проверяется а нет ли у него еще более подходящих специализаций и, если есть, выбирается одна из них.
Специализация, это шаблон типо:
template<> void foo(int*){cout<<"2"<<endl;}  //В нем пустой <>.
Для того чтобы специализация шаблонной функции считалась таковой, базовый шаблон должен быть объявлен в коде перед этой специализацией.

В шаблон можно передавать не только тип, но и:
Параметрами шаблонов могут быть:
	1-целочисленные значения,{
template <typename T,int X>
void  q(T x1)// {
	cout<<X<<endl;
// }
int main()// {
    q<int,5>(5);//выведет: 5	
// }
	}//Конец примера "Целочисленные значения".
	2-указатели или ссылки на значения с внешней линковкой
	3-шаблоны.
Все параметры должны быть определены на этапе компиляции -все типы обрабатываются на этапе компиляции. В скомпилированном коде нет никаких типов. Значения должны быть известны на этапе компиляции. Параметры шаблона не могут быть прочитаны из файла или получены со стандартного ввода, сгенерированы...

Компиляция шаблонов{
Шаблон независимо компилируется для каждого значения шаблонных параметров.
Компиляция (инстанциирование) шаблона происходит в точке первого использования - точке инстанциирования шаблона.
Компиляшия шаблонов класса-ленивая, компилируются только те методы, которые используются.
В точке инстанциирования шаблон должен быть полностью определен.
Шаблоны следует определять в заголовочных файлах. //в точке инстанциирования он должен быть полностью определен. Так большие шаблонные классы разделяют на два заголовочных файла: объявление (array.hpp) и определение (array_impl.hpp).
Все шаблонные функции (свободные функции и методы) являются inline
В разных единицах трансляции инстанциирование происходит независимо.
}//Конец области "Компиляция шаблонов"

Частичная специализация и шаблонные параметры по умолчанию есть только у шаблонов классов.
Вывод шаблонных параметров есть только у шаблонов функций (компилятор сам определяет параметр шаблона по аргументам функции).
Предпочтительно использовать перегрузку шаблонных функций вместо их полной специализации.
Полная специализация функций -не является шаблоном, это обычные функции.
Возможно виртуальные методы, конструктор по умолчанию, конструктор копирования и присваивания с деструктором не могут быть шаблонными.
Можно удобно использовать typedef для длинных шаблонных имён.
}//Конец области "Шаблоны".

Объединения union{//Вообще-то в C++17 он не нужен в повседневном коде. //Устарело, наследие С и 90-х.
//Тип union часто использовали в мультимедийных библиотеках. В них разыгрывается вторая фишка union: идентификаторы полей анонимного union попадают во внешнюю область видимости.
//Под объединениями понимают область памяти, в которой одновременно может хранится несколько различных переменных.
union имя_объединения{
тип_переменной1 имя_переменной1;
тип_переменной2 имя_переменной2;
...
тип_переменнойN имя_переменнойN;
} список экземпляров;
//Странная штука, похоже //технология объединений union берет свои истоки в 90-х. Слабенькие по нашим временам ЭВМ//Каждый байт памяти был на вес золота, приходилось экономить на всём. 
//Объединение – это такой формат данных, который подобен структуре. Оно (объединение) способно хранить в пределах одной зарезервированной области памяти различные типы данных. Но в каждый определенный момент времени в объединении хранится только один из этих типов данных и возможно использовать лишь значение этого элемента (компонента). 
для записи обеих переменных используется общая область памяти. Обычно объем памяти для хранения данных объединения выбирается исходя из размера самой большой (по типу) переменной.
Ситуация следующая: при обращении к переменной n или m, являющихся членами объединения, просматривается одна и та же область памяти.
union g{
    char name;
    int age;
};
g v;
v.age=113;
cout<<v.age<<endl; 	//113
cout<<v.name<<endl;	//q
v.name='q';
cout<<v.age<<endl;	//113
cout<<v.name<<endl;	//q
    
v.age=35;
cout<<v.age<<endl;	//35
cout<<v.name<<endl;	//#
}

Перечисления enum{
//Под перечислением подразумевают набор именованных целочисленных констант, которые используются для определения возможных значений переменной типа перечисления.
enum — это сгруппированный набор целочисленных констант.
enum тип_перечисления {константа1, константа2,...,
константаN} список переменных типа перечисления;
Внутри перечисления числа, перечисление это набор именованных целочисленных констант:
//default:  0    1     2     3    4   5
enum color{red,green,yellow,vasa,cat,dog};
color v=red;
cout<<v<<endl;//0
v=vasa;
cout<<v<<endl;//3
cout<<cat<<endl;//4
cout<<dog<<endl;//5
//Можно установить значение по умолчанию: //следующее значение на единицу будет больше предыдущего.
enum color{red,green,yellow,vasa,cat=100,dog};//тогда cat=100,а dog уже 101
enum { BoardWidth = 10, BoardHeight = 22 };

}

Подробнее об указателях{
//Под указателем подразумевают переменную, значением которой является адрес памяти.
	int * a = 0;  //нулевой указатель ни на что не указывает. cout << a, то получим 00000000.
	if (a == 0)//Нужно проверять, не равен ли указатель нулю. *a в данном случае вырубит программу.
	if(a) //bool(*a) будет равно нулю. Любой не нулевой указатель это true
	//Взятие значения у нулевого указателя вырубает программу-ошибка. Нужно всегда проверять на равенство нулю.
	& перед переменной-это получение адреса. Указатель может указывать только на адрес.
	& выдает адрес и на него может ссылаться указатель. int b=5; &b выведет адрес, где находится эта переменная
	ptrMe=&me; //связывание. "&" получает адрес переменной в памяти.
	//указатель указывает на ячейку памяти. Если просто вывести его, то получим ячейку:
	int *a; a=&b; cout<<a //008f8e0 например получим. А если:
	cout << *a, то получим значение, которое там находится.
	int **g; это указатель на указалатель. Это значит, что это указатель, который указывает на другой указатель.
	//другим указателем может быть тоже указатель на другой указатель.
	**g выдаст значение переменной, на которую ссылается указатель, на который ссылается указатель g{
	int b = 5;
	int * g = &b;
	int **f = &g;

	cout << f << endl;  //0000006BD07EFCD8 указатель f ссылается на ячейку памяти. А это память другого указателя (int **f = &g;  g)
	cout << &g << endl;	//0000006BD07EFCD8 память, где храниться g
	cout << &b << endl;	//0000006BD07EFCB4 память, где хранитьяс b
	cout << *f << endl; //0000006BD07EFCB4 значение ячейки, на которую указывает. А указывает он на указателя-а в указателе храниться ссылка на ячейку b
	cout << **f << endl;//5

	}	
	*b=5; Теперь в этой ячейке хранится значение пять. Меняет значение той учейки памяти, на которую указывает.
	Тройной, четверной и так далее указатель:{
	//Сколько звездочек, столько и надо написать, чтобы получить значение:
	int b =5;
	int * g = &b;
	int **f = &g;
	int *** jj = &f;
	int **** four = &jj;

	cout << * g << endl; 		//5  все это выдаст значение указателя
	cout << ** f << endl;		//5
	cout << *** jj << endl;		//5
	cout << **** four << endl;	//5
	
	cout <<"*** four:: " << *** four << endl; //*** four:: 0000003A1B8FFA84
	cout << "&b:: " << &b << endl; //&b:: 0000003A1B8FFA84
	cout << "** four:: " << ** four << endl;//** four:: 0000003A1B8FFAA8
	cout << "&g:: " << &g << endl;//&g:: 0000003A1B8FFAA8
	cout << "* four:: " << * four << endl;//* four:: 0000003A1B8FFAC8
	cout << "&f:: " << &f << endl;//&f:: 0000003A1B8FFAC8
	cout << "four:: " << four << endl;//four:: 0000003A1B8FFAE8
	cout << "&jj:: " << &jj << endl;//&jj:: 0000003A1B8FFAE8
	Из четверного указателя, можно получить значение любого указателя, на который он указывает.
	four указывает на jj который указывает на f который указывает на g который указывает на переменную b, таким образом:
	four  --> &jj  --> &f    --> &g     --> &b аналогично:
    &four --> four --> *four --> **four --> ***four
	}

	Указатель на функцию{//можно создавать такие функции: void myfunc(double x,double (*f)(double))//Первый аргумент имеет тип double, а второй аргумент является указателем на функцию.
//функции (без круглых скобок и аргументов) является указателем на функцию.
Сначала указывается тип результата, который возвращается соответствующей функцией,
затем заключенные в круглые скобки оператор * и имя указателя, а после
этих круглых скобок еще одни круглые скобки с перечислением типов аргументов функции:
int vasa(int g=6){ return g*11;}
int (*p)(int);  p=vasa;
cout<<p(4)<<endl; //44
}
	специальный указатель: void* -может удержать любой тип объекта:
		В него можно запихнуть любой адрес, но тип объекта по этому адресу неизвестен.
		Адрес выведет, а значение нет. Получение значения из него геморно и вручную{
			#include <iostream>
			#include <string>
			using namespace std; 
			int main()// {
			int a=5;
			string w="vasa";
			void * p;
			p=&a;
			cout<<p<<" "<<&a<<endl;		//0x7ffc59d2bffc 0x7ffc59d2bffc
			cout<<*((int*)p)<<endl;		//5
			p=&w;
			cout<<p<<" "<<&w<<endl;		//0x7ffc59d2c000 0x7ffc59d2c000
			cout<<*(string *)p<<endl;	//vasa
			return 0;
			// }	
		Если написать cout<<*p<<endl; то будет выскачена ошибка:
		error: ‘void*’ is not a pointer-to-object type
		С указателем void* допустимо немного действий: его можно сравнить с другим указателем, можно передать его функции или возвратить из нее либо присвоить другому указателю типа void*. Его нельзя использовать для работы с объектом, адрес которого он содержит, поскольку неизвестен тип объекта, неизвестны и операции, которые можно с ним выполнять.
		Как правило, указатель void* используют для работы с памятью как с областью памяти, а не для доступа к объекту, хранящемуся в этой области.
		
		
		
		}//Конец области void*
	
	const int *p=&w; //указатель на константу.
	int *const p=&w;//константный указатель
	const int *const p=&w; //константный указатель на константу
	
	Не объявлять ни одного const и позволить изменять и сам указатель и данные на которые он указывает
		uint64_t *bob;
	Объявить неизменяемыми только данные, но позволить изменять указатель	
		uint64_t const *bob;//Это распространенный шаблон для перебора последовательностей данных: переходить к следующему элементу, увеличивая указатель, но не позволяя указателю изменять данные.
	Объявить неизменяемым только указатель, но позволить изменять данные	
		uint64_t *const bob;
	константный указатель и указатель на константу{
		указатели указывают на адрес. Их значение адрес. Этот адрес у констратного нельзя изменить. А значение как угодно.
		#include <iostream>
		using namespace std; 
		int main()// {
		int w=5;
		int *const p=&w;
		cout<<*p<<endl;//5
		w++;
		cout<<*p<<endl;//6
		*p=7;
		cout<<*p<<" "<<w<<endl;//7 7 
		int g=999;
		p=&g;//ошибка: error: assignment of read-only variable ‘p’
		return 0;
		// }	
		
		
	}//Конец области константных указателей и указателей на константу.
	
	Можно изменить констрантный указатель, явным приведением:
	const char days[5]={'q','w','e','r','\0'};
	char * w = (char *) &days [1];
	cout<<days<<endl;	//qwer
	*w='9';
	cout<<days<<endl;	//q9er
	*((char *) &days [0])='5';
	cout<<days<<endl;	//59er
} //Конец области указателей.

умные указатели{
В std есть несколько умных указателей:
unique_ptr:
	умный указатель с уникальным владением.
	Нельзя копировать, можно перемещать (алгоритмы std сортировки не будут работать, так как там копирование)
	Не подходит для разделяемых объектов.
shared_ptr:
	умный указатель с подстетом ссылок.
	Универсальный указатель.
weak_ptr:
	умный указатель для создания слабых ссылок.
	работает вместе с shared_ptr.
}//Конец области "умные указатели"

Ссылка (Обертка над указателями) реализует идею синонима{
//Ссылка инициализируется только один раз.
//Ссылка всегда должна быть определена. int &b; вернет ошибку.
Указатели можно переназначать, а ссылки нет:{
	int g = 9;
	int b = 9;
	int *p;
	p = &g;
	p = &b;
	*p += 4;
	cout << "g:" << g << "\n";	//g:9
	cout << "b:" << b << "\n";	//b:13
	cout << "p:" << p << "\n";	//p:0000005F5DBDFC94
	cout << "&b:" <<&b << "\n";	//&b:0000005F5DBDFC94
	Указатели можно переназначать. А ссылку нет:
	int g = 3;
	int b = 9;
	int &p = g;
	p = b; //Ссылка это синим-все равно что g=b;  Её не переназначить.
	cout << "g:" << g << "\n"; //g:9
	cout << "b:" << b << "\n"; //b:9
}
int g = 9;
int &b = g;
b += 5; //И тут g становиться равным 14.
У ссылки нет нулевого значения//- int &p = 0; вернет ошибку.
Пример:{
void swap(int & a){
	a = 5;
}
int main()
{
	int a = 9;
	swap(a);
	cout << a << endl;	//выведет пять
	return 0;
}
}
Лучше не пытаться получить адрес ссылок //(int &p = g; cout << &p << endl;), в стандарте этого нет, и компилятор на свое усмотрение работает-например он при компиляции может заменить все ссылки этой переменной.
Тут вместо адреса ссылок, будет браться адрес переменной, на которую ссылается ссылка//: int * pl=&p -pl cсылается на переменную g;
Нет ссылок на ссылку.// int &p = g; int && h=p; будет ошибка. && это ссылка на rvalue
Нельзя создать массив ссылок.// int &h[2] = {}; вернет ошибку
Для ссылок нет арифметики.

Ссылка на константу ограничивает только то, что при помощи этой ссылки можно делать. Привязка ссылки к константному объекту ничего не говорит о том, является ли сам основной объект константой. Поскольку основной объект может оказаться неконстантным{
	#include <iostream>
using namespace std; 
int main()// {
int w=5;
const int &q=w;
cout<<q<<endl;//5
w++;
cout<<q<<endl;//6
return 0;
// }
Но если написать:
q++;
Получим ошибку: error: increment of read-only reference ‘q’
}//Конец области ссылка на константу


}//Конец области ссылка

Массивы и массивы с указателями, многомерные массивы{//массивы чисел и массивы строк, имеют разное поведение. См заметки->Странные и неожиданное поведение кода>Чтение файла.
	//имя массива (без индексов) является указателем на первый элемент массива. //Например, если массив создается командой int n[10], то имя массива n является указателем (адресом) на первый элемент массива n[0].
	//Динамический массив от статического отличается в первую очередь тем, что на момент компиляции размер динамического массива не известен, в отличие от массивов статических, для которых размер должен быть известен уже при компиляции.
	Обращение по индексу:m[i] //Это как *(m+i);
	Забавно, можно 2[m], получим элемент с индексом 2.
Массив-набор однотипных элементов, расположенных в памяти друг за другом, доступ к которым осуществляется по индексу.
//Размер массива должен быть известен на момент компиляции(такие массивы называются статическими). int b[n]={} писать нельзя. Или создавать динамический или явно n заменять на число (Error:variable-sized object ‘b’ may not be initialized)
int m[10]={1,2,3,4,5};//массив 1,2,3,4,5,0,0,0,0,0
Если просто создать массив: int m[10];, то он будет заполнен черт знает чем.
Надо создавать массив или явно (int m[10] = { 11,22,33,44,55 };)
или int m[10] = {}; тогда он будет заполнен нулями.
Те значения, которые явно не указаны, заполняются нулями.
for (int i=0;i<10;++i)
	cout<<m[i]<<"\n";
В качестве массива передается указатель на нулевой элемент. Просто так с работать с массивом как с массивом нельзя
По этому, без разницы, когда объявляешь функцию, является параметр функции указателем или массивом, все равно
передавая в функцию массив, передается указатель на нулевой элемент:
int max_element(int *m,int SIZE_MASSIV){
//и приходится передавать размер массива в функцию, чтобы можно было перебирать массив
int max_el=*m;
for (int i=1;i<	SIZE_MASSIV ; ++i)
	if (m[i]>max_el)
		max_el=m[i];
return max_el;
//Или можно передать за последний элемент массивка, тот который идет за последний,
//Чтобы алгоритм сработал, если массив пустой дадут.
}
Указатели позволяют передвигаться по массиву.
int m[10] = { 11,22,33,44,55 };
cout << m << "\n"; //Выведет адрес нулевого элемента (в данном случае он был 00000074456FF9A8)
cout << *m << "\n";//Выведет значение нулевого элемента (в данном случае это 11)
int *p=&m[0] //Адрес начала массива
int *p = m; //Автоматически преобразовывается в указатель на нулевой элемент: int *p=&m[0]
int *q=&m[9] //Адрес последнего элемента массива.
p+k//сдвиг на k ячеек типа int вправо //cout << *(p+2) << "\n"; выведет 33.
p-k//сдвиг на k ячеек типа int влево  //cout << *(p+2) << "\n"; тут мы уезжаем за границы массива, и получаем черти что.
q-p//количество ячеек между указателями (получим девять)//Предполагается что q больше p иначе будет со знаком минуса как ниже
p-q//А тут уже получим минус девять
p[k] //Эквивалентно *(p+k)//cout << p[1] << "\n"; получим 22. а  p[0] это 11 будет


Многомерные массивы: 
На стеке двумерный массив идет как одномерный:
Если объявлено int x[5][7], то x — это не массив длины 5 неких указателей, указывающих куда-то далеко. Нет, x теперь — это единый монолитный блок размером 5 x 7, размещённый на стеке. sizeof (x) равен 5 * 7 * sizeof (int). Элементы располагаются в памяти так: x[0][0], x[0][1], x[0][2], x[0][3], x[0][4], x[0][5], x[0][6], x[1][0] и так далее. 
Можно проверить адреса:{
char x[3][2];
cout<<(void *)&x[0][1]<<endl;	//0x7ffddb9623c1
cout<<(void *)&x[0][2]<<endl;	//0x7ffddb9623c2
cout<<(void *)&x[0][3]<<endl;	//0x7ffddb9623c3
cout<<(void *)&x[0][4]<<endl;	//0x7ffddb9623c4
cout<<(void *)&x[0][5]<<endl;	//0x7ffddb9623c5
cout<<(void *)&x[0][6]<<endl;	//0x7ffddb9623c6
     
cout<<"x[1][]"<<endl;			//x[1][]
cout<<(void *)&x[1][0]<<endl;	//0x7ffddb9623c2
cout<<(void *)&x[1][1]<<endl;	//0x7ffddb9623c3
cout<<(void *)&x[1][2]<<endl;	//0x7ffddb9623c4
cout<<"x[2][]"<<endl; 			//x[2][]
cout<<(void *)&x[2][0]<<endl;	//0x7ffddb9623c4
cout<<(void *)&x[2][1]<<endl;	//0x7ffddb9623c5
cout<<(void *)&x[2][2]<<endl;	//0x7ffddb9623c6
}//Конец области "Проверка адресов"

//При инициализации массивов, если явно указан их размер, недостающие элементы заполняются нулями.
//название двумерного массива с одним лишь первым индексом это указатель на первый элемент соответствующей строки массива.
//(m[1]+2) ссылка на третий элемент второй строки m[1] это ссылка на первый элемент второй строки и к нему прибавляем два.
int m2d[2][3]={{1,2,3}, {4,5,6}}; //элементы располагаются в памяти "по строчкам".//создается без звездочки/Этот массив автоматически создается в стеке
размерность может быть любой, но редко используются >4. int m4d[2][3][4][5]={};

Двумерные массивы:
m-указатель на двумерных массив типа int.
Значит m[i][j] имеет тип int (точнее int &).
m[i][j] <--> *(m[i] +j), т.е тип m[i] - int *.
аналогично: m[i] <--> *(m+i), т.е тип m- int **.
значение m[i]-адрес строки с номером i.
значение m- адрес массива с указателями на строки.
Пример создания массива 5х4 динамического.
int ** m=new * int[5]//строка из пяти элементов, в каждом из которых будет ссылка на строку.
for (size_t i=0;i!=5;i++){
	m[i]=new int[4]; //строка из четырех элементов.
}
При таком создании, массив не обязательно должен быть однородным (new int[4];), в каждой строке может находиться любое кол-во переменных, например в первой строке один элемент, во второй четыре, в третьей три.
Пример функции создания двумерного массива размера a * b{
int ** create_array2d(size_t a, size_t b){//при создании массива оператор new вызывается (a+1) раз.
	int ** m = new int * [a];
	for (size_t i = 0; i != a; ++i)
		m[i] = new int[b];
	return m;
}//Cильно фрагментируем память.
Пример эффективного создания массива 5 * 4{
int ** m = new int * [5];
m[0] = new int[5 * 4];
for (size_t i=1; i!=5;++i)
	m[i]=m[i - 1] +4;
}
Приведенным выше примером, создася 2 массива, в одном 5 строк, и он ссылается на другой массив.
}

Пример функции освобождения массива{
void free_array2d(int ** m, size_t a){
	for (size_t i=0; i!=a; ++i){
		delete []m[i];
	}
	delete []m;
}
void free_array2d(int ** m,size_t a){ //Эффективное удаление эффективного массива
	delete [] m[0];
	delete [] m;
}
}

Эффективное выделение двумерного массива размера a * b {
int ** create_array2d(size_t a,size_t b){
	int ** m = new int *[a];
	m[0]=new int [a * b];
	for (size_t i=1;i!=a;++i)
		m[i] = m[i-1]+b;
	return m;
}
}

Массив как и вектор -контейнер безымянных объектов одинакового типа, к которым обращаются по позиции
В отличие от вектора, массивы имеют фиксированный размер. Добавлять элементы к массиву нельзя. За счет постоянного размера лучшая производительность.

Символьный массив можно иницировать строковым литералом, но инициализовать string не получилось.
char w[4]="wer";
}

Динамическая память{
Стек программы ограничен.
double m[100000000]={};//80мб //не умещается в стек. При запуске программа падает. Перестает отвечать.
В С++ выделением и освобождением памяти управляется вручную.
Выделение памяти в стиле С{
	Стандартная библиотека cstdlib дает 4 функции для управление памяти:
void * malloc (size_t size); //выделяет область памяти размера больше или равного size. Данные не инициализируются. //кусочек округлится вверх. В самом начале храняться служебные данные. А в он вернет указатель на чуть правее. По этому функция free не требует размер. А только указатель.
void   free	  (void *prt); //Освобождает область памяти, ранее выделенную одной из функций (malloc/calloc/realloc). prt указатель, который пришел из этих функций.
void * calloc (size_t nmemb, size_t size); //выделяет массив из nmemb (кол-во элементов) размера size. Данные инициализируются нулем.
void * realloc(void * ptr,size_t size); //изменяет размер области памяти по указателю ptr на size(если возможно, просто продляет её на том же месте).

}
Примеры выделения памяти в стиле С{
	int * m = (int *)malloc(1000 *sizeof(int));// создание массива из 1000 int //кол-во элементов на размер самого элемента
	m=(int *)realloc(m,2000*sizeof(int));//изменение размера массива до 2000 (массив и новый размер передаем). //попробует расширить область, если не получиться, создаст новую область и первую тысячу элементов скопирует туда, а ту область, которую раньше массив занимал, освободит.
	free(m);//освобождение массива.
	m=(int *)calloc(3000,sizeof(int));//создание массива нулей
	free(m);//очищаем массив, и показываем, что больше не будем использовать, придавая переменной значение ноль. Хороший тон.
	m=0;
	
	
	
	
}

Выделение памяти в стиле С++{
Есть 2 набора операторов:
	new и delete -для одиночных значений.
	new [] и delete []-для массивов.
	Версия delete должна соответствовать версии оператора new.

//выделение памяти под один int со значением пять.
int * m = new int(5);
delete m; //освобождение памяти.

//создание массива значений типа int
int * m = new int[1000];
delete [] m;//освобождение памяти.
}

Типичные проблемы при работе с памятью{
Проблема производительности: создание переменной на стеке намного "дешевле" выделения для неё динамической памяти.
Проблема фрагментации: выделение большого количества небольших сегментов способствует фрагментации памяти.	
Утечки памяти:{
	//создание массива 1000 int
	int * m=new int [1000];
	//создание массива из 2000 int, а те 1000 не были очищены и пропали вникуда-память под них занята, а ссылки на нее больше нет.
	m=new int [2000];//учетка памяти из 1000 int
	// не был вызван delete []m, учетка памяти.
}
}
Неправильное освобождение памяти:{
	int * m1 = new int [1000];
	delete m1;//должно быть delete [] m1 //произвольное поведение, никто не знает что будет.
	
	int * p = new int (0);
	free(p); //совмещение С++ и С функций. //неопределенное поведение, в стандарте не описано данное поведение
	
	int * q1 = (int*)malloc(sizeof(int));
	free(q1);
	free(q1);//двойное удаление. //будет ошибка. Просто приложение прекращает работу ничего не говоря.
	
	int * q2 = (int *)malloc(sizeof(int));
	free(q2);
	q2=0;//обнуляем указатель
	free(q2);//правильно работает для q2=0; //все правильно сработает.
	
}
}

Строки{
to_string()	//часто нужна

c_str() //возвращает указатель на начало символьного массива с нулевым символом в конце. Тип указателя const char * не позволяет изменять содержимое массива.

const char *, строковый массив и char *{
//     char w[]="qwer";
//     cout<<w<<endl;
//     w[1]='7';
//     char * q=w;//указатель char равен именно w. w-указатель на нулевой элемент массива.
//     q[1]='z';

Этот код работает, можно обращаться по индексу для чтения w[1], но изменять нельзя. Выдает ошибку.
    char *w="qwer";
    cout<<w<<endl;
	
}//Конец области "const char *, строковый массив и char *"

Работа со строками в стиле С{//кропотливая работа с ручным выделением памяти. Опасно.
Библиотека cstring функции для работы со строками (char *)
char s1[100]="Hello";
cout<<strlen(s1) //5 ищет в строке \0, тут опасно: char s1[100] = "Hello\0vasa"; выведет пять, а последние 4 буквы пропустит.
char s2[]=" , world!";
cout<<strcat(s1,s2);//должны сложить строки, но vs2015 ругает на небезопасность. Не проверял. Предполагается, что в первом элементе достаточно места для хранения второй строки.
char s3[6]={72,101,108,108,111}//задается кодами соответствующих букв. Нужно смотреть на таблицу символов.
strcmp(s1,s3)//Начиная с первых символов функция strcmp сравнивает поочередно каждую пару символов, и продолжается это до тех пор, пока не будут найдены различные символы или не будет достигнут конец строки.//Нулевое значение говорит о том, что обе строки равны.Значение больше нуля указывает на то, что строка string1 больше строки string2, значение меньше нуля свидетельствует об обратном.
}
Работа со строками в стиле С++{//размер массивов автоматически меняется на уровне библиотеки.
Библиотека string -обёртка над строками, которая упрощает операции.
#include <string>//namespace std;
string s1="Hello";
s1.size();//5
string s2=" vasa";
cout<<s1+s2//сложение строк.
cout<<(s1 == s2)//равенство строк.
}

Строка(string)-это последовательность символов переменной длины.
//http://www.cplusplus.com/reference/string/string/
//http://ru.cppreference.com/w/cpp/string/basic_string
Наиболее распостраненные способы инициализации строк{
	
	string s1;			//инициализация по умолчанию; s1 - пустая строка.
	string s2=s1;		//s2-копия s1 //string s2(s1); //тоже самое
	string s3="hiya";	//s3-копия строкового литерала// string s3("value") //нулевой символ не включен.
	string s4(10,'c');	//s4- сссссссссс
	
}//Конец области "Наиболее распостраненные способы инициализации строк"

String operations:
	c_str//Get C string equivalent (public member function )
	data//	Get string data (public member function )
	get_allocator//	Get allocator (public member function )
	copy//	Copy sequence of characters from string (public member function )
	find//	Find content in string (public member function )
	rfind//	Find last occurrence of content in string (public member function )
	find_first_of//	Find character in string (public member function )
	find_last_of//	Find character in string from the end (public member function )
	find_first_not_of//	Find absence of character in string (public member function )
	find_last_not_of//Find non-matching character in string from the end (public member function )
	substr//	Generate substring (public member function )
	compare//	Compare strings (public member function )

Modifiers:
	operator+=//Append to string (public member function )
	append//	Append to string (public member function )
	push_back//	Append character to string (public member function )
	assign//	Assign content to string (public member function )
	insert//	Insert into string (public member function )
	erase//	Erase characters from string (public member function )
	replace//	Replace portion of string (public member function )
	swap//	Swap string values (public member function )
	pop_back//	Delete last character (public member function )

Capacity:
	size//	Return length of string (public member function )
	length// Return length of string (public member function )
	max_size//	Return maximum size of string (public member function )
	resize//	Resize string (public member function )
	capacity//	Return size of allocated storage (public member function )
	reserve//	Request a change in capacity (public member function )
	clear//Clear string (public member function )
	empty//	Test if string is empty (public member function )
	shrink_to_fit //Shrink to fit (public member function )
	
Element access:
	char& at (size_t pos); {//Return value-The character at the specified position in the string.
		pos - Value with the position of a character within the string. Note: The first character in a string is denoted by a value of 0 (not 1). If it is not the position of a character, an out_of_range exception is thrown.
		Example:
			string w="qwert9";	
			char q=w.at(3);	//r
			w.at(1)//w
}//Конец области "at"
	operator[] (size_t pos);//Get character of string (public member function )
	char& back();	//Access last character (public member function )
	char& front();	//Access first character (public member function )
	
Iterators:	
	begin //Return iterator to beginning (public member function )
	end	//Return iterator to end (public member function )
	rbegin //Return reverse iterator to reverse beginning (public member function )
	rend	//Return reverse iterator to reverse end (public member function )
	cbegin  //Return const_iterator to beginning (public member function )
	cend //Return const_iterator to end (public member function )
	crbegin //Return const_reverse_iterator to reverse beginning (public member function )
	crend //Return const_reverse_iterator to reverse end (public member function )

Строки можно складывать с char и char *{
char w='r';
string q="Vasa";
char *r="tyu";
string t=w+q+r;
cout<<t<<endl;	//	rVasatyu
}//Конец области сложение с char и char *

Набор функций для классификации и преобразования отдельных символов (char){
isalnum		Check if character is alphanumeric (function )
isalpha		Check if character is alphabetic (function )
isblank 	Check if character is blank (function )
iscntrl		Check if character is a control character (function )
isdigit		Check if character is decimal digit (function )
isgraph		Check if character has graphical representation (function )
islower		Check if character is lowercase letter (function )
isprint		Check if character is printable (function )
ispunct		Check if character is a punctuation character (function )
isspace		Check if character is a white-space (function )
isupper		Check if character is uppercase letter (function )
isxdigit	Check if character is hexadecimal digit (function )	

В основнмо возвращают true или false если символ подходит под условие:
char w='t';
cout<< islower(w)<<endl;	//512//возвращает любое какое-то число, если символ в нижнем регистре. /*A value different from zero (i.e., true) if indeed c is a lowercase alphabetic letter. Zero (i.e., false) otherwise.*/
cout<< islower('Y')<<endl;	// 0

}//Конец области "Набор функций для классификации и преобразования отдельных символов (char)"

Строка это последовательность символов, и как последовательность, её можно обойти в цикле: серийный оператор for (range for):
for (char i: "qwert")// {
        cout<<i<<endl;
    // } //каждый символ будет выведен с новой строки.
"qwert" это будет const char *.
А если сделать его string, то можно будет менять в цикле:
string w="qwert";
for(char &i: w)
	i='Y';
cout<< w <<endl;//	YYYYY

}//Конец области "Строки"

Вектор (vector){//последовательность значений одного типа.
#include <vector>
using std::vector;
Немного eng теории{//http://www.cplusplus.com/reference/vector/vector/
Vectors are sequence containers representing arrays that can change in size.

Just like arrays, vectors use contiguous storage locations for their elements, which means that their elements can also be accessed using offsets on regular pointers to its elements, and just as efficiently as in arrays. But unlike arrays, their size can change dynamically, with their storage being handled automatically by the container.

Internally, vectors use a dynamically allocated array to store their elements. This array may need to be reallocated in order to grow in size when new elements are inserted, which implies allocating a new array and moving all elements to it. This is a relatively expensive task in terms of processing time, and thus, vectors do not reallocate each time an element is added to the container.

Instead, vector containers may allocate some extra storage to accommodate for possible growth, and thus the container may have an actual capacity greater than the storage strictly needed to contain its elements (i.e., its size). Libraries can implement different strategies for growth to balance between memory usage and reallocations, but in any case, reallocations should only happen at logarithmically growing intervals of size so that the insertion of individual elements at the end of the vector can be provided with amortized constant time complexity (see push_back).

Therefore, compared to arrays, vectors consume more memory in exchange for the ability to manage storage and grow dynamically in an efficient way.

Compared to the other dynamic sequence containers (deques, lists and forward_lists), vectors are very efficient accessing its elements (just like arrays) and relatively efficient adding or removing elements from its end. For operations that involve inserting or removing elements at positions other than the end, they perform worse than the others, and have less consistent iterators and references than lists and forward_lists.

}//Конец области "end теория"
Немного не совсем понятной теории{
Стандарт требует, чтобы реализация шаблона vector обеспечивала эффективное добавление элементов во время выполнения. Поскольку рост вектора эффективен, определение вектора сразу необходимого размера зачастую является ненужным и может даже привести к потере производительности. Исключением является случай, когда все элементы нуждаются в одинаковом значении. При разных значениях элементов обычно эффективней определить пустой вектор и добавлять элементы во время выполнения, по мере того, как значения становятся известны.	
	
Начало с пустого вектора и добавление элементов во время выполнения кардинально отличается от использования встроенных массивов в языке С и других языках. В частности, если вы знакомы с языком С или Java, то, вероятно, полагаете, что лучше определить вектор в его ожидаемом размере, но фактически имеет место обратное.
}//Конец области "немного не совсем понятной теории"
vector это коллекция объектов одинакового типа, каждому из которых присвоен целочисленный индекс, представляющий доступ к этому объекту. -это контейнер ( container), поскольку он "содержит" другие объекты.
Тип vecrot - это шаблон класса ( class template). Это как инструкция для компилятора по созданию классов или функций.

При создании экземпляра шаблона класса следует указать дополнительную информацию, характер которой зависит от шаблона (в угловых скобках после имени шаблона).
vector<int> ivec;//ivec содержит объекты типа int
vector<Sales_item> Salec_vec;	//содержит объекты класса Sales_item
vector<vector<string>> file;	//вектор, содержит другие векторы

Способы инициализации векторов{
vector <T> v1				//Вектор, содержащий объекты типа Т. Стандартный конструктор м1 пуст.
vector <T> v2(v1)			//Вектор v2- копия всех элементов вектора v1
vector <T> v2=v1			//Эквивалент v2(v1) - v2 копия элементов вектора v1
vector <T> v3(n,val)		//Вектор v3 содержит n элементов со значением val
vector <T> v4(n)			//Вектор v4 содержит n экземпляров объекта типа Т инициализированного значениями по умолчанию
vector <T> v5{a,b,c...}		//Вектор v5 содержит столько элементов, сколько предоставлено инициализаторов; элементы инициализируются соответствующими инициализаторами.
vectot <T> v5={a,b,c...}	//Эквивалент v5{a,b,c...}

vector <int>w(4);	//четыре элемента проинициализированы нулем.
vector <int>q{4};	//один элемент проинициализированный числом 4.
vector <int>w(4,99);//четыре элемента проинициализированны числом 99
vector <int>q{4,99};//два элемента, нулевой 4, первый 99.
Фигурная скобка-попытка списочной инициализации.
}//Конец области "Способы инициализации векторов"

Modifiers:
	assign			Assign vector content (public member function )
	push_back		Add element at the end (public member function )
	pop_back		Delete last element (public member function )
	insert			Insert elements (public member function )
	erase			Erase elements (public member function )
	swap			Swap content (public member function )
	clear			Clear content (public member function )
	emplace			Construct and insert element (public member function )
	emplace_back	Construct and insert element at the end (public member function )


Iterators:
	begin	Return iterator to beginning (public member function )
	end		Return iterator to end (public member function )
	rbegin	Return reverse iterator to reverse beginning (public member function )
	rend	Return reverse iterator to reverse end (public member function )
	cbegin	Return const_iterator to beginning (public member function )
	cend	Return const_iterator to end (public member function )
	crbegin	Return const_reverse_iterator to reverse beginning (public member function )
	crend	Return const_reverse_iterator to reverse end (public member function )
	
Capacity:
	size			Return size (public member function )
	max_size		Return maximum size (public member function )
	resize			Change size (public member function )
	capacity		Return size of allocated storage capacity (public member function )
	empty			Test whether vector is empty (public member function )
	reserve			Request a change in capacity (public member function )
	shrink_to_fit	Shrink to fit (public member function )	
	
Element access:
	operator[]	Access element (public member function )
	at			Access element (public member function )
	front		Access first element (public member function )
	back		Access last element (public member function )
	data		Access data (public member function )

Оператор индексирования не добавляет новый элемент. Он лишь выбирает существующий элемент. Он не может добавить новый элемент.

Красивый оборот с вектором{
набор оценок в диапазоне от 0 до 100. Для учета создаем вектор.
0-9			40-49	80-89
10-19		50-59	90-99
20-29		60-69	100
30-39		70-79
vector <int> scores(11,0);
int grade;
while (cin>>grade)// {
	if (grade>100){break;}
	if (grade<=100)
		++scores[grade/10]; //красивый ход. Приращение счетчика и одновременно получение нужного индекса
// };
for (int i:scores)
    cout<<i;
cout<<endl;

}//Конец области "Красивый оборот с вектором"

}//Конец области "Вектор (vector)"

статический массив array{
# include <array>
template < class T, size_t N > class array;
шаблон array -класс обертка над статическим массивом:
operator[], at,
back/*Access last element*/,front() /*Access first element*/,
fill/*Fill array with value*/
data/*Returns a pointer to the first element*/
Работаем с массивом, как с контейнером. Не позволяет изменять свой размер динамически.
Размер должен быть известен в момент компиляции.
std::array<std::string,3>a={"One","Two","Three"};
}//Конец области "статический массив array"

Словарь{
#include <map>
Контейнер  map  сам выполняет сортировку по алфавиту.

}//Конец области "Словарь"

Ввод-вывод{

Ввод-вывод в стиле С{//сложен и небезопасен (типы аргументов не проверяются).
#include <cstdio>
printf("Time: %s and %.2d \n",vasa,qwe);
scanf("%d %d",&a,&b);//считает ввод и запишет в переменные.
}

char str[100]; cin>>str; //оператор ввода >> считывает информацию, пока не встретит символ перехода на новую строку, символ табуляции или пробел.
endl — специальное значение, называемое манипулятором (manipulator).//При его записи в поток вывода происходит переход на новую строку и сброс буфера (buffer), связанного с данным устройством. Сброс буфера гарантирует, что весь вывод, который программа сформировала на данный момент, будет немедленно записан в поток вывода, а не будет ожидать записи, находясь в памяти.
Во время отладки программисты зачастую добавляют операторы вывода промежуточных значений. Для таких операторов всегда следует применять сброс потока. Если этого не сделать, оставшиеся в буфере вывода данные в случае сбоя программы могут ввести в заблуждение разработчика, неправильно засвидетельствовав место возникновения проблемы.

Реализуйте функцию getline, которая считывает поток ввода посимвольно, пока не достигнет конца потока или не встретит символ переноса строки ('\n'), и возвращает C-style строку с прочитанными символами.
внимание на "symbol != std::cin.eof()"
#include <iostream>
char *getline()
// {
    char symbol='\0';
    char * w=new char [1000000000];
    int i=0;
    while(std::cin.get(symbol) && symbol != '\n' && symbol != std::cin.eof())// {
        w[i]=symbol;
        i++;
    // };
    w[i]='\0';
    return w;
// }
}

Работа с файлами{
//Механизм ввода-вывода, разработанный для обычного языка С, не соответствует общепринятому сегодня стилю объектно-ориентированного программирования, кроме того, он активно использует операции с указателями, считающиеся потенциально небезопасными в современных защищённых средах выполнения кода. Альтернативой при разработке прикладных приложений является механизм стандартных классов ввода-вывода, предоставляемый стандартом языка C++.
Файлы открываются в момент определения переменных, а закрываются, когда переменные перестают существовать-при выходе из соответствующей функции или области видимости.
#include <fstream>//Библиотека fstream //Все поточные классы ввода-вывода являются косвенными производными от общего предка ios, полностью наследуя его функциональность.

Возможные значения флагов открытия файла и их назначение{//Так, режим открытия файлов задает член данных перечисляемого типа open_mode, который определяется следующим образом: enum open_mode { app, binary, in, out, trunc, ate };
	ios_base::in		Открыть для ввода (выбирается по умолчанию для ifstream)  //читаем
	ios_base::out		Открыть для вывода (выбирается по умолчанию для ofstream) //записываем
	ios_base::binary	Открыть файл в бинарном виде
	ios_base::aрр		Присоединять данные; запись в конец файла
	ios_base::ate		Установить файловый указатель на конец файла//чтобы записывать в конец файла.
	//Не проврял::флаги ate и app по описанию очень похожи, они оба перемещают указатель в конец файла, но флаг app позволяет производить запись, только в конец файла, а флаг ate просто переставляет флаг в конец файла и не ограничивает места записи.
	ios_base::trunc		Уничтожить содержимое, если файл существует (выбирается по умолчанию, если флаг out указан, а флаги ate и арр — нет)
}

Режимы открытия файлов можно устанавливать непосредственно при создании объекта или при вызове функции open(){
ofstream fout("cppstudio.txt", ios_base::app); // открываем файл для добавления информации к концу файла
fout.open("cppstudio.txt", ios_base::app); // открываем файл для добавления информации к концу файла
}

//Например, чтобы открыть файл с именем test.txt для чтения данных в бинарном виде, следует написать
ifstream file; 
file.open ("test.txt", ios::in | ios::binary);
file.is_open() //функция — , которая возвращает целые значения: 1 — если файл был успешно открыт, 0 — если файл открыт не был.
cout<<fin<<endl; //Работает похоже. Она мне вернула 0x7fff8830e8c0, а если я пытался открыть несуществующий, то 0 возвращает.

Пример чтение текстового файла{
ifstream NewFile;
NewFile.open("./first/file.txt"); //текстовый файл, в который я записал: "some text"
char x[6]={};
char b='\0';
NewFile.read((char*)&x, sizeof(x));
cout<<   x <<endl; //some t
NewFile.read((char*)&b, sizeof(b));
cout<<   b <<endl; //e
}

Пример как узнать размер файла С++{
#include <iostream>
#include <fstream>
using namespace std;
int main(){
ifstream NewFile;
NewFile.open("./first/image.png");
long nFileLen = 0;
if (NewFile)
{
   NewFile.seekg(0, std::ios_base::end);
   nFileLen = NewFile.tellg();
   NewFile.close();
   cout<<nFileLen<<endl;//3428
}
    return 0;
}
}

ifstream классы для чтения{
Методы:
	open	Открывает файл для чтения
	get		Читает один или более символов из файла
	getline	Читает символьную строку из текстового файла или данные из бинарного файла до определенного ограничителя
	read	Считывает заданное число байт из файла в память
	eof		Возвращает ненулевое значение (true), когда указатель потока достигает конца файла
	peek	Выдает очередной символ потока, но не выбирает его
	seekg	Перемещает указатель позиционирования файла в заданное положение{
	std::istream::seekg
		(1)	istream& seekg (streampos pos);
		(2)	istream& seekg (streamoff off, ios_base::seekdir way);
	Параметры:
		pos		New absolute position within the stream (relative to the beginning). streampos is an fpos type (it can be converted to/from integral types).
		off		Offset value, relative to the way parameter. streamoff is an offset type (generally, a signed integral type).
		way		Object of type ios_base::seekdir. It may take any of the following constant values:
			value:	offset is relative to..:
			ios_base::beg	beginning of the stream
			ios_base::cur	current position in the stream
			ios_base::end	end of the stream
	Пример:
		ErrorFile.seekg(0, std::ios_base::beg);//перемещение к началу файла
		cout<<ErrorFile.tellg()<<endl;		//текущая позиция 0
   
		ErrorFile.seekg(0, std::ios_base::end);//перемещение к концу файла
		cout<<ErrorFile.tellg()<<endl;			//3428
	}
	tellg	Возвращает текущее значение указателя позиционирования файла
	close	Закрывает файл
	
}

ofstream для записи{
Методы:
	open	Открывает файл для записи
	put		Записывает одиночный символ в файл
	write	Записывает заданное число байт из памяти в файл
	seekp	Перемещает указатель позиционирования в указанное положение
	tellp	Возвращает текущее значение указателя позиционирования файла
	close	Закрывает файл
}

fstream для модификации файлов {//класс fstream произведен от istream и ostream (родителей ifstream и ofstream соответственно)
// Открыть файл на чтение/запись одновременно
 fstream file("Notebook.txt", ios::binary | ios::in | ios::out);
}

//Осторожно с записью char b[]="some",сюда в конец добавляется '\0', и он же записывается в файл.
//При чтении всего (WriteFile.read((char*)b,106);) он считывается, и при выводе к консоль просто обрежет текст, дойдя до '\0'

Бинарные файлы{
Бинарные данные обслуживаются наподобие текстовых.
Отличие состоит в том, что если бинарные данные записываются в определенной логической структуре, то они должны считываться из файла в переменную того же структурного типа.
Первый параметр методов write и read (адрес блока записи/чтения) должен иметь тип символьного указателя char *, 
поэтому необходимо произвести явное преобразование типа адреса структуры void *.
Второй параметр указывает, что бинарные блоки файла имеют постоянный размер байтов независимо от фактической длины записи. 
file.write((char*)&x, sizeof(x)); 
}
}

Remark{

Ручное побайтовое перемещение по структуре с помощью указателя{
char — это всегда ровно один байт и во всех стандартах C и C++:
sizeof (char) == 1 (но при этом стандарты не гарантируют, что в байте содержится именно 8 бит :)).
Далее, если прибавить к указателю на какой-нибудь тип T число, то реальное численное значение этого указателя увеличится на это число, умноженное на sizeof (T):
Т. е. если p имеет тип T *TYPE, то p + 3 эквивалентно (T *)((char *)p + 3 * sizeof (T)). Аналогичные соображения относятся и к вычитанию.
Оператор char * перегружен. Вывести адрес указателя на char или сам char нельзя.
cout<<std::setw (10)<<"start: "	<<&q<<endl;							//адрес первого байта структуры
cout<<std::setw (10)<<"+1: "	<<&q+1<<endl;						//а тут уже +20 байт от первого байта структуры
cout<<std::setw (10)<<"char"	<<(void*)(((char*)(&q))+1)<<endl;	//второй байт структуры.
Нужно привести указатель к char * и можно побайтово лазить по структуре. Но вывести его нельзя-он перегружен. Приходиться к типу void * приводить.
}//Конец области "Ручное побайтовое перемещение по структуре с помощью указателя"

Число в строку и последнее значение{
int i=12345;
string s =to_string(i); 
cout<<s[s.length()-1]<<endl;	//5	
}//Конец области "Число в строку и последнее значение"

Префиксная и постфиксная форме инкремента и декремента{
Оператор инкремента ++
Оператор декремента --
префиксная версия позволяет избежать ненужной работы. Она увеличивает значение и возвращает результат. Постфиксный оператор должен хранить исходное значение, чтобы возвратить неувеличенное значение как результат. Но если в исходном значении нет никакой потребности, то нет необходимости и в дополнительных действиях, осуществляемых постфиксным оператором.
}//Конец области "Префиксная и постфиксная форме инкремента и декремента"

Парадигма{
С,Pascal,Fortran и другие сходные с ними языки программирования относятся к категории процедурных языков. Каждый оператор такого языка является указанием компьютеру совершить некоторое действие, например принять данные от пользователя, произвести с ними определенные действия и вывести результат этих действий на экран. Программы, написанные на процедурных языках представляют собой последовательность инструкций.
Парадигма- дополнительная внутренняя организация программы.
Паради́гма программи́рования — это совокупность идей и понятий, определяющих стиль написания компьютерных программ (подход к программированию). Это способ концептуализации, определяющий организацию вычислений и структурирование работы, выполняемой компьютером.
}//Конец области "Парадигма"
	
В любой непонятной ситуации, можно запихнуть блок кода- ограничение видимости{
int main()// {
    int x=732;
    {}; //просто запихиваем блок кода, со своей видимостью и радуемся.
    cout<<x<<endl;//732
Блок кода может изменять внешние переменные, можно создавать внутренние с таким-же именем и они удаляться в конце.
int x=732;
int i=6;
/* { */int i=123456789;  //это локальная переменная, с таким же именем, удалится в конце.
x=i;// };				//изменяем настоющий Х.
cout<<x<<endl;//123456789
cout<<i<<endl;//6
}//Конец области "Непонятная ситуация".	
		
Отрицательная сторона глобальной переменной{
Масштабируемость-если библиотека использует глобальные переменные и реализует базу данных, то при добавлении второй базы данных, они обе будут обращаться к одной и той же глобальной переменной. Коллизия будет. Или при многопоточности, оба потока в одну перенную будут пытаться что-то записать, их нужно будет синхронизировать. Программу тяжело будет увеличить, добавив новые функции или свойства.

Побочные эффекты. Функция в теории должна всегда возвращать одно и тоже значение, при одном и том же аргументе- если функции квадратного корня дать аргументом число два, то она всегда должна возвращать четыре, а при использовании глобальных переменных, никто не скажет, что она вернет. Тяжело отдалить такую функцию-нужно слезить за тем, кто и когда изменяет глобальную переменную.

Порядок инициализации -Если глобальная переменная есть в другом файле, и одна глобальная переменная зависит от другой, (w=q+5;q=10) не факт, что они в нужном порядке определятся (w может быть не равно 15). Будет непредсказуемое поведение программы. Сильно зависит от того, как компилятор расположил глобальные переменные в секции инициализации.

	
}//Конец области "Отрицательная сторона глобальной переменной"

Время жизни переменной:
#include <iostream>
#include <string>
using namespace std; 
struct Point // {
    Point(int x=0):x(x){
        cout<<"Create"<<x<<endl;
    // }
    int x;
    ~Point()// {
        cout<<"Delete "<<x<<endl;
    // }
};
void create()// {
    Point x2=2;
    Point x3=3;
    Point x4=4;
// }
int main()// {
    Point x1=1;
    create();
    Point x5=5;
    return 0;
// } 
В консоль выведут:
Create1
Create2
Create3
Create4
Delete 4
Delete 3
Delete 2
Create5
Delete 5
Delete 1
Структуры удаляются в обратной порядке.
Дейструкторы переменных на стеке вызываются в обратном порядке (по отношению к порядку вызова конструкторов)

Кракозябры в консоли{
Пишем файл в utf-8.
Потом в нотепаде выбираем: Преобразовать в ANSI
И компилируем.
Потом исходник обратно преобразовываем в utf-8	
	
}//Конец области "Кракозябры в консоли"

Если что-то похоже на объявлении функции, то это и есть объявлении функции{
Point p1;	//определение переменной
Point p2();	//объявление функции

double k=5.1;
Point p3(int(k));	//Объявление функции
Point p4((int)k);	//объявление переменной
}//Конец области "Специфичный синтаксис"
cin-принимает ввод пользователя.
printf()-в библиотеке <iostream>
int %d
char %c
string %s чтобы вывести строку: string.c_str() //string vasa="bi";printf("My name:%s\n",vasa.c_str()); 

cout<<setlocale(LC_ALL, "")<<endl; //выведет всю локаль по умолчанию. У меня это было: en_US.UTF-8 //Если не отображается кириллица в консоли, попробовать: setlocale(LC_ALL, "Russian");
boolalpha- потоковый манипулятор //cout << "Is x equal to y?" << boolalpha << (me.position.x == 10) << (me.position.x == 0)<<endl; //в консоль будет написано false or true
sizeof-указание размера типа.//кол-во байт, которое занимает конкретное значение.
cout << typeid(w).name() << endl; //вывод в консоль тип w
http://www.cplusplus.com/reference/istream/istream/seekg/ //Описание функций. Удобное и подробное.


Команды компилятору (www.sourcelair.com/workspace/C){//онлайн IDE. Доволно удобная с консолью и файловой системой.
	g++ -std=c++11 f.cpp //команда компилятора. Сделает a.out (это исполняемый файл).
}

Надо уточнить{//Не совсем понятно. Надо уточнить.
В docs.microsoft.com/ru-ru/cpp/standard-library/input-output-alternatives в Альтернативные варианты ввода и вывода написано:
Visual C++ предоставляет несколько альтернатив для программирования ввода-вывода:
	1-Прямой ввод-вывод без буферизации на основе библиотеки времени выполнения С.
	2-Потоковый ввод-вывод на основе библиотеки времени выполнения ANSI C.
	3-Прямой ввод-вывод на консоль и в порт.
	4-Библиотека MFC.
	5-Стандартная библиотека Microsoft C++.
	
Классы iostream полезны для ввода-вывода форматированного текста с буферизацией. 
Они также могут использоваться для ввода-вывода без буферизации или двоичного ввода-вывода, если требуется интерфейс программирования C++ и принято решение отказаться от использования библиотеки Microsoft Foundation Class (MFC).
}

Странные и неожиданное поведение кода {//Потом разобраться, почему так произошло.

Чтение файла{//Нашел закономерность, но очень слабо понял.
//Пример 1:
NewFile.open("./first/file.txt"); //в файле some text qwertyuiopasdfghjklzxcvbnm
char b[9]={};
NewFile.read((char*)&b, 900);
cout<<sizeof(b)<<endl;//9
cout<<b<<endl;//some text qwertyuiopasdfghjklzxcvbnm //тут выводиться весь текст, до 900 символов, указанный во втором атрибуте read.
cout<<   *b <<endl;//s
cout<<   *(b+1) <<endl;//o //Это же понятно и логично. Но почему B выводит не адрес, а все?
//Но размер b то не 900.
//Пример 2, тут уже поведение отличается.
ifstream fin("/mnt/project/first/image.png",ios::in | ios::binary);
ofstream newim("./first/NewImg.png",ios::out |ios::binary);//Пустая картинка, создаст её
char x[9]={};
fin.read((char*)&x, 900);
newim.write((char*)&x, 900);
//При запуске получаем Segmentation fault      (core dumped) 
//Но если char x[9]={}; заменить на char x[900]={}; все сработывает идеально. И картинка копируется полностью.
//Почему он выводит все за пределами Х, но при записи ругается, что я обращаюсь за пределы программы.
//Да и х же по идее указатель на первый элемент массива. А он выводит не адрес элемента, а все что в массиве.
//О вот еще один пример:
char g[]="This is string";
cout<<g<<endl;//This is string
//Или
char *b="This is string";//Выведет предупреждение, что устарело: //warning: deprecated conversion from string constant to ‘char*’ [-Wwrite-strings]
cout<<b<<endl;//This is string
cout<<*b<<endl;//T
cout<<*(b+1)<<endl;//h
cout<<b[2]<<endl;//i

//Почему? Они оба массивы, и оба ведут себя по разному.

int m[20]={1,2,3,4,5,6};
cout<<m<<endl;//0x7ffccfcd2a00
cout<<*m<<endl;//1

char wtf[20]={'w','h','a','t','y','o','u','i','s'};
cout<<wtf<<endl;//whatyouis
cout<<*wtf<<endl;//w
}




}

Загрузка файлов с помощью Curl{
	curl -0 https://domain.ru/file.zip //сохранение файл с тем же именем, что и на сервере
	curl -o archive.zip https://domain.ru/file.zip    //сохранение файла с новым именем	
}

Забавная статья об изучении С++ начиная с С{
	
Б большинстве книг язык C++ представлен в порядке его развития. Сначала они знакомят с частью С в языке C++, а в конце книги представляются более абстрактные средства C++ как дополнительные возможности. У этого подхода
есть две проблемы: читатели могут увязнуть в подробностях, унаследованных от низкоуровневого программирования, и сдаться. Те же, кто будет упорствовать в изучении, наживут плохие привычки, от которых впоследствии придется избавляться.
Мы придерживаемся противоположного подхода: с самого начала используем средства, которые позволяют программистам игнорировать детали, унаследованные от низкоуровневого программирования. Например, мы вводим и используем библиотечные типы string и vector наряду со встроенными цифровыми типами и массивами. Программы, которые используют эти библиотечные типы, проще писать, проще понимать, и ошибок в них много меньше.
Слишком часто библиотеки преподносят как "дополнительную" тему. Вместо того чтобы использовать библиотеки, во многих книгах используют низкоуровневые способы программирования с использованием указателей на символьные массивы и динамического управления памятью. Заставить правильно работать программы, которые используют эти низкоуровневые подходы, куда труднее, чем написать соответствующий код C++, используя библиотеку.
}

Теория о функции main {
Определение функции содержит четыре элемента: тип возвращаемого значения (return type), имя функции (function паше), список параметров (parameter list), который может быть пустым, и тело функции (function body).
В большинстве операционных систем возвращаемое функцией main () значение используется как индикатор состояния. Возвращение значения 0 свидетельствует об успехе. Любое другое значение, как правило, означает отказ, а само значение указывает на его причину.
}

Тип определяет и содержимое элемента данных, и операции, которые возможны с ним.

На операционной системе UNIX исполняемые файлы не имеют расширения, а в операционной системе Windows они имеют расширение . ехе.

Посмотреть руководство по компилятору: компиляторы способны предупреждать о проблемных конструкциях. Не проверял: Поэтому с компилятором GNU желательно использовать параметр -Wall, а с компиляторами Microsoft — параметр /W4.

Все имена, определенные в стандартной библиотеке, находятся в пространстве имен std.

Цикл while продолжается, поочередно проверяя условие и выполняя оператор, пока условие не станет ложно.

Для ввода символа конца файла в операционной системе Windows достаточно нажать комбинацию клавиш <Ctrl+z> (удерживая нажатой клавишу <Ctri>, нажать клавишу <z>), а затем клавишу <Enter> или <Return>. На машине с операционной системой UNIX, включая Mac OS-X, как правило, используется комбинация клавиш <Ctrl+d>.

Класс определяет тип данных и набор операций, связанных с этим типом.

Определение связывает имя с реализацией, что может быть либо кодом либо данными:
	Определение переменной побуждает компилятор зарезервировать некоторую область памяти, возможно задав ей некоторое определённое значение. 
	Определение функции заставляет компилятор сгенерировать код для этой функции 
Объявление говорит компилятору, что определение функции или переменной (с определённым именем) существует в другом месте программы, вероятно в другом C файле. (Заметьте, что определение также является объявлением — фактически это объявление, в котором «другое место» программы совпадает с текущим).

Для переменных существует определения двух видов:
	1-глобальные переменные, которые существуют на протяжении всего жизненного цикла программы («статическое размещение») и которые доступны в различных функциях;
	2-локальные переменные, которые существуют только в пределах некоторой исполняемой функции («локальное размещение») и которые доступны только внутри этой самой функции.
При этом под термином «доступны» следует понимать «можно обратиться по имени, ассоциированным с переменной в момент определения».
Существует пара частных случаев, которые с первого раза не кажутся очевидными:
	статичные (static) локальные переменные на самом деле являются глобальными, потому что существуют на протяжении всей жизни программы, даже если они видимы только в пределах одной функции. 
	статичные глобальные переменные также являются глобальными с той лишь разницей, что они доступны только в пределах одного файла, где они определены.
Стоит отметить, что, определяя функцию статичной, просто сокращается количество мест, из которых можно обратиться к данной функции по имени. 

И наконец, мы можем сохранять информацию в памяти, которая динамически выделена посредством malloc или new. В данном случае нет возможности обратиться к выделенной памяти по имени, поэтому необходимо использовать указатели — именованные переменные, содержащие адрес неименованной области памяти. Эта область памяти может быть также освобождена с помощью free или delete. В этом случае мы имеем дело с «динамическим размещением».
	
	/* Определение неинициализированной глобальной переменной */
int x_global_uninit;
 
/* Определение инициализированной глобальной переменной */
int x_global_init = 1;  
 
/* Определение неинициализированной глобальной переменной, к которой можно обратиться по имени только в пределах этого C файла */
static int y_global_uninit; 
 
/* Определение инициализированной глобальной переменной, к которой  можно обратиться по имени только в пределах этого C файла */ 
static int y_global_init = 2; 
 
/* Объявление глобальной переменной, которая определена где-нибудь в другом месте программы */
extern int z_global;
 
/* Объявлени функции, которая определена где-нибудь другом месте программы (Вы можете добавить впереди "extern", однако это необязательно) */
int fn_a(int x, int y);
 
/* Определение функции. Однако будучи помеченной как static, её можно вызвать по имени только в пределах этого C  файла. */ 
static int fn_b(int x) { return x+1; }
 
/* Определение функции. Параметр функции считается локальной переменной. */
int fn_c(int x_local) // {
  /* Определение неинициализированной локальной переменной */
  int y_local_uninit;
  /* Определение инициализированной локальной переменной */
  int y_local_init = 3;
 
  /* Код, который обращается к локальным и глобальным переменным, а также функциям по имени */ 
  x_global_uninit = fn_a(x_local, x_global_init);
  y_local_uninit = fn_a(x_local, y_local_init);
  y_local_uninit += fn_b(z_global);
  return (x_global_uninit + y_local_uninit);
// }
	
Если написать нечто, выглядящее как отрицательный десятичный литерал, например -42, то знак минус это не часть литерала. Знак "минус" это оператор, который инвертирует знак своего операнда (литерала).

Можно отображать символ (\n и прочие управляющие последовательности) по его числовому значению:
\12 это новая строка \40 это пробел.{
cout<<"qwe\40rty\12tyui\12ty"<<endl; //выведет:
Compiling first/f.cpp...
Running first/f.cpp...
qwe rty
tyui
ty
//Вот так.	
std::cout << "Hi \x4dO\115!"; //Выведет:
Compiling first/f.cpp...
Running first/f.cpp...
Hi MOM!
//Вот так
}
Если за символом \ будет больше трех восьмиричных цифр, то к нему будут относится только первые три.
Например, литерал "\1234" представляет два символа: символ, представленный восьмеричным значением 123, и символ 4.

В самом общем определении объект — это область памяти, способная содержать данные и обладающая типом.
Одни программисты используют термин объект лишь для переменных и экземпляров классов. Другие используют его, чтобы различать именованные и неименованные объекты, причем для именованны объектов используют термин переменная (variable ). Третьи различают объекты и значения,
используя термин объект для тех данных, которые могут программой, и термин значение (value) — для тех данных, которые предназначены только для чтения.

Может путать знак = при инициализации переменной.
Инициализация и присвоение это разные операции.

Обсуждение gamedev{
	
Ключевая задача: Создать документ, способный в полной мере отразить и передать без дополнительных комментариев суть идеи.
Иными словами, любой, кто прочтёт итоговое описание, должен однозначно понять, о чём идёт речь, и при будущем диалоге с носителем идеи владеть полными объёмом знаний.
Здесь следует сделать замечание, что мы ограничиваемся бизнес-логикой верхнего уровня, не погружаясь в инструментарий и тонкости реализации — это следующий этап.

0.1. Структура документа

Далее по тексту мы пройдём основные составляющие формального описания идеи. В каждом блоке я буду приводить короткую его характеристику, ссылки на дополнительные материалы и пример, основанный на моём личном проекте. Общая структура будет выглядеть следующим образом:
Содержание
Концепция
Название
Жанр
Ключевое отличие
Платформа(-мы)
Целевая аудитория

Форма
Картинка (Сеттинг)
Геймплей
Звук

Аналоги
Источники идей
Конкуренты

Деньги
Способы монетизации
Примеры реализации

Состояние пректа
Текущее состояние
Общий план реализации
Ближайшие действия
Необходимые ресурсы

1.2 Жанр
Самая распространённая проблема здесь — попытки смешивать жанры и продвигать это, как ключевое отличие. Несколько раз я слышал «Сейчас замутим смесь StarCraft, MineCraft, ещё какой-нибудь *Craft и захватим мир!» Не издевайтесь над игроком, заставляя его тратить силы на попытку понять, что же это перед ним такое. Как бы там ни было, жанр игры должен быть ОДИН. Безусловно, можно замешивать элементы геймплея из соседних жанров, но ключевой мотив должен быть однообразным. Если вернуться к идее презентации, то на этом слайде должно быть одно слово (RTS, RPG, FPS и т.д.) и одно предложение, которое может пояснять или уточнять это слово.

1.3. Ключевое отличие
Как правило, на этом пункте многие сдаются. Внятно проговорить, чем твоя идея лучше, чем все остальные — это испытание не из простых. Более того, даже если на данный момент тебе удалось сформировать что-то внятное, то впереди ещё ждёт блок «Аналоги», который подвергнет очередной волне критики твою идею.
В принципе, здесь всё просто: «Чем твоя игра будет выделяться от всех остальных в жанре?» В маркетинге это называется «Позиционирование — простое, ясное, однозначное, выгодное отличие от конкурентов». Матчасть по вопросу можно посмотреть здесь или в книгах Дж. Траута. Приведу несколько примеров:
MineCraft — большой открытый полностью изменяемый мир;
StarCraft — классическая RTS с идеальным балансом;
Догонялки — простой подвижный геймплей, не требующий дополнительного оборудования.

1.5. Целевая аудитория

Ещё один раздел, который ставит в ступор подавляющее большинство будущих игроделов. А вопрос здесь очень простой: «Для кого твоя игра? Кто будет ядром сообщества?» Самый распространённый ответ — «для всех!», и он же — самый неправильный. Маркетологи знают, что реклама, направленная на всех, не попадает ни по кому, та же история и с продуктами. Безусловно, есть «товары народного потребления», но их список очень мал и в общем количестве незначительный. Всё остальное, что не попадает в этот список, создано для какой-то конкретной группы. Мерседесы — для успешных, Роллекс — для понтовых, StarCraft — для продвинутых, Весёлая ферма — для домохозяек, MineCraft — для школьников.


2.2. Геймплей

Термин «Геймплей» весьма неоднозначен, есть множество авторитетных людей, изучающих игры и игровой дизайн, которые вообще считают, что он лишён смысла (можно почитать даже на Википедии. Здесь мы будем рассматривать геймплей в разрезе игровой механики, т.е. взаимодействие человека с игровым миром:
Место появления персонажа/ей в игровом мире в начале игры. Может ли игрок выбрать, где появиться или игра сама выбирает точку? Место появления всегда одно и то же или постоянно меняется? Тут всё просто: Terraria — случайная точка в игровом мире, Diablo — всегда одинаковая точка в игровом мире, Battlefield — сами выбираем, где появиться.
Управление персонажем/ами. Безусловно, этот пункт во многом определяется платформой. С одной стороны, чаще всего здесь пишут стандартные способы управления (клавиатура, мышь, тач-скрин, участок тач-скрина и т.д.), а с другой могут появиться и весьма экзотические способы. Например, управление голосом: The Howler. В любом случае, необходимо описать процесс управления игрой и персонажем/ами, ведь это те действия, которые игрок будет совершать бОльшую часть времени.
Развитие и изменения персонажа/ей. Существуют ли какие-то характеристики персонажа/ей? Предусмотрена ли система усовершенствования характеристик? Существуют ли понятия «опыт», есть ли игровые предметы, которые влияют на характеристики?
Враги и «зоны-смерти». Существуют ли в игре у персонажа/ей противники? Что является условием смерти? Как персонаж/и взаимодействует/ют с врагами?
Многопользовательская игра. Есть ли в игре многопользовательский режим? Если да, то как игроки взаимодействуют друг с другом?
Игровые уровни/локации. Есть ли разделение на уровни? Чем они отличаются друг от друга? Что необходимо, чтобы перейти с уровня на уровень?
Условия победы/поражения. Какие у игрока есть цели? Что является условием победы или поражения?
Продолжительность игры. Сохранения. На сколько игрового времени рассчитана игра? Может ли игрок остановить игру и продолжить позже с этого же места?

Геймплей Mini DayZ{
Игрок каждый раз появляется на берегу в случайной точке игровой карты. Управление осуществляется при помощи клавиатуры и мыши. Все кнопки мыши продублированы клавишами на клавиатуре. Характеристики персонажа зависят от снаряжения, местоположения и погоды\времени суток. Базовые характеристики: здоровье, жажда, голод, температура. Враги в игре — зомби двух типов, а также боты-выжившие. Враги атакуют игрока в соответствии с их снаряжением, как только он попадает в зону их видимости, боты-выжившие сами путешествуют по карте, сражаясь друг с другом и зомби. Многопользовательская игра не предусмотрена (есть вероятность появления со временем). Игровая карта выбирается в начале каждой игровой сессии и может быть изменена только после гибели игрока. Карта не делится на уровни и полностью открыта для исследования игроком. Победа в игре невозможна, ключевая цель — как можно дольше пробыть в игровом мире. Игрок проигрывает, когда уровень здоровья персонажа становится равен нулю. Сохранения отсутствуют, после каждой смерти игрок начинает сначала. Полное исследование игровой карты занимает не менее 20 часов.}


Детальность. В концепции должны быть ответы на все вопросы. После прочтения концепции должно сформироваться полное представление о проекте. Специалисты первым делом смотрят на концепцию, если концепция окажется для них не полной и непонятной, то они не будут с Вами работать.
). Если Вы будете работать в команде или использовать помощь других людей (инвесторы, художники и прочие), то Вам просто необходима развёрнутая концепция и ТЗ для каждого человека. Критерий один – понятность. Нужно чтобы любой человек, ознакомившись с концепцией и ТЗ, представил конечный результат, так же как и Вы.


}//Конец области Обсуждение gamedev

Вложенные области видимости{ //Оператор области видимости
#include <iostream>
using namespace std; 
int w=5; //глобальная область видимости переменной
int main()// {
cout<<w<<endl; //5 глобальная переменная.
int w=9; //локальная переменная вытесняет область видимости
cout<<w<<endl; //9 локальная переменная.
cout<<::w<<endl;//5 тут явно обращаемся к глобальной переменной.
return 0;
// }	

Оператор области видимости "::" переопределяет правила областей видимости.
У глобальной области видимости нет имени.
Следовательно, когда у оператора пусто слева, это обращение к указанному справа имени в области глобальной видимости.
Если такой переменной в глобальной области нет, будет ошибка:
#include <iostream>
using namespace std; 
int main() // {
int t=4;
cout<<::t<<endl; //error: ‘::t’ has not been declared
return 0;
// }
}//Конец области Вложенные области видимости

Копирование или передача указателя(функции){
	Есть небольшой момент связанный с производиельностью:
		Если не передать указатель в функцию, то переменная скопируется.
			Создастся новая переменная, в которой будут новые адреса, и воссоздадутся
			новые адреса её полей.
		Передать в функцию указатель и съэкономить на памяти.
	Пример:
#include <iostream>
using namespace std; 
struct Point// {
    int x;
// };
void getAdd(Point i)// {
    cout<<i.x<<" "<<&i.x<<endl;
// }
int main()// {
Point w;
cout<<w.x<<" "<<&w.x<<endl;
getAdd(w);
return 0;
// }
//На экран будет выведено:
2136896640 0x7ffc7f5e7390
2136896640 0x7ffc7f5e7370 //тут уже другой адрес. А значение скопировалось.
По идее если передать указатель, то ничего заново создаваться не будет,
экономия памяти.
}//Конец области: Копирование или передача указателя(функции)

Ключевые слова языка С++{//выше есть еще одни ключевые слова. А это список.
alignas
alignof
asm
auto
bool
break
case
catch
char
char16_t
char32_t
class
const
constexpr
const_cast
continue
decltype
default
delete
do
double
dynamic_cast
else
enum
explicit
export
extern
false
float
for
friend
goto
if
inline
int
long
mutable
namespace
new
noexcept
nullptr
operator
private
protected
public
register
reinterpret_cast
return
short
signed
sizeof
static
static_assert
static_cast
struct
switch
template
this
thread_local
throw
true
try
typedef
typeid
typename
union
unsigned
using
virtual
void
volatile
wchar_t
while
Альтернативные имена операторов языка С++
and
and_eq
bitand
bitor
compl
not
not_eq
or
or_eq
xor
xor_eq
}//Конец области Ключевые слова.

}//Конец области Remark

Ключевые слова{
	
friend{
friend функция, метод или класс имеют полный доступ, включая private в другом классе. Такие функции могут изменять приватные поля класса.
Так например левая функция, которую в классе объявили дружественной, может изменять поля объекта, однако тут чертовски важную роль со стороны компилятора играет то, в каком месте она располагается. Функция использует в аргументе ссылку на структуру. Значит над функцией должно быть объявление струкруты. Но если функция лезет в поле структуры, а вверху только объявление без ничего, то будет ошибка-компилятор в объявлении не видит, какие там поля.
Функция friend — это функция, которая не является членом класса, но имеет доступ к закрытым и защищенным членам класса. Дружественные функции не считаются членами класса; это обычные внешние функции с особыми правами доступа. Дружественные функции не входят в область видимости класса и не вызываются с помощью операторов выбора члена (. и –>), если они не являются членами другого класса. Функция friend объявляется с помощью класса, который предоставляет доступ. Объявление friend можно поместить в любом месте объявления класса. На него не влияют ключевые слова управления доступом.
Функции-члены класса могут быть объявлены в других классах как дружественные (class B {  friend int A::Func1( B& );};
Класс friend — это класс, все функций-члены которого являются дружественными функциями класса, то есть функции-члены которого имеют доступ к закрытым и защищенным членам другого класса.
Дружественные функции можно определять прямо внутри описания класса- они становяться inline.
struct First; //пример объявления. Если прямо под ним разместить функцию, то будет ошибка.
struct First// {
    First():x(765){}
    void xprint(){cout<<x<<endl;}
    friend void SetX(First &w,int x); //Это объявление функции.
private:
    int x;
// };
void SetX(First &w,int x)// { //запихнул её в самый низ, чтобы все поля уже были объявлены.
    w.x=x;
// }
int main()// {
    First w;
    w.xprint();//765
    SetX(w,555);
    w.xprint();//555 //поле изменилось из-за ссылки. Иначе можно только читать поля копии и менять поля копии.
    return 0;
// }

Пример, как friend класс может изменять приватные поля другого:
struct First// {
    First():x(765){}
    void xprint(){cout<<x<<endl;}
friend struct Second;
private:
    int x;
// };
struct Second// {
    void Secondprint(First &i)// { //передаем ссылку, и эта структура может изменять приватные поля другой структуры.
        cout<<i.x<<endl;
        i.x=123456;
    // }
    void NotChangeValue(First i)// {//тут копируется. По этому изменения не сохраняются.
        cout<<i.x<<endl;
        i.x=9999;
    // }
// };
int main()// {
    First w;
    w.xprint();//765
    Second q;
    q.Secondprint(w);//765
    w.xprint();//123456
    q.NotChangeValue(w);//123456
    w.xprint();//123456
    return 0;
// }
}//Конец области "friend"

extern{
Использование extern позволяет объявить переменную, не определяя ее, он сообщает, что переменная находится где-то в другом месте. 
Пример{
#include <iostream>
using namespace std; 
extern int w;
int main()// {
cout<<w;
return 0;
// }
int w=123;
----Тут уже нет программы---
//В консоли:
Compiling first/f.cpp...
Running first/f.cpp...
123
}	

 В примере выше объявление х находится в верхней части программы, а определение внизу. Но, как правило, extern используется, чтобы получить доступ к глобальной переменной, объявленной в другом исходном файле, а затем связать два получившихся объектных файла вместе после компиляции. Использование extern для объявления глобальной переменной в значительной степени то же самое, что и, используя объявление функции, объявить функцию в заголовке файла. (На самом деле, вы ставите extern в заголовке файла, а не в исходном файле.)

В самом деле, если вы поставите переменную в заголовке файла и не будете использовать extern, вы столкнетесь с обратной задачей неопределенного символа, у вас будет символ с несколькими определениями, с ошибкой типа:
redefinition of ‘foo  //Это произойдет, когда компоновщик будет связывать объектные файлы. 

Общие случаи
	Если вы хотите использовать функцию в нескольких исходных файлах, вы должны объявить функцию в одном заголовочном файле (.h), а затем определить функцию в одном исходном файле (.c или .cpp). Весь код, который использует функцию должен включать в себя только .h файл, и вам надо связать полученные объектные файлы с объектным файлом от компиляции исходного файла.

	Если вы хотите использовать класс в нескольких файлах, вы должны поместить определение класса в заголовочный файл и определить методы класса в соответствующем исходном файле. (Вы также можете использовать встроенные функции для методов).

	Если вы хотите использовать переменную в нескольких файлах, вы должны объявить переменную с помощью ключевого слова extern в одном заголовочном файле, а затем включить этот заголовочный файл во все исходные файлы, которым нужна эта переменная. Затем вы должны определить эту переменную в одном исходном файле, который связан со всеми объектными файлами, которые используют эту переменную.

}//Конец области extern

typedef{
механизм определения новых имен для уже существующих типов реализуется с помощью ключевого слова typedef:
typedef тип новое_имя_типа;//Так создадим новый тип на основе существующего. Типо синоним типа.
Пример:
typedef int* IntPointer;
int n=100;
IntPointer p;
p=&n;
(*p)++;
cout<<"n = "<<n<<endl;

Превдонимы типа позволяют упростить сложные определения типов, облегчая их использования. Имена некоторых типов может быть трудно написать по памяти. Чтобы не было ошибок. Формат записи сложного типа способен скрыть его цель или значение.
}

static {	
Имеет пять различных применений:
	1- при определении глобальной переменной: тогда глобальная переменная будет доступна только в пределах модуля. А другом файле можно объявить глобальную статическую переменную с таким же именем.
	2- статическая локальная переменная -это глобальная переменная, доступная только в пределах этой функции. Ведет себя как глобальная переменная внутри этой функции. Живет от вызова этой функции до конца программы. Храниться не на стеке, как обычная локальная переменная, а в той же области, где храняться другие глобальные переменные. По хорошему, это глобальная переменная, которая доступна только внутри функции.
	3-статическая функция- функция доступная только в пределах модуля. Подстановка адресов будет происходить локально внутри одного модуля и внутри другого модуля. Статические глобальные переменные и статические функции проходят внутреннюю линковку.
	4-статические поля класса- это глобальная переменная, определенная внутри класса. На нее распостраняются модификаторы доступа, это единственное, что отличаюет статическое поле класса, от глобальной переменной. Храняться там же, где и глобальная переменная. Статические поля класса создаются при запуске программы и удаляются при выходе из программы. Можно объявить в классе, и определить где-нибудь еще: (struct User{private: static size_t instances_;}; size_t User::instances_=0;) главное определить её как глобальну. переменную-вне функции. В классе определять нельзя, и в функции тоже. Компилятор выдаст ошибку. Обычные поля класса-это поля объекта, храняться в объекте, а статическое поле храниться в области глобальных переменных. Так как статическое поле храниться не в объекте, то для доступа к нему не нужен объект. 
	5-статические методы- это функции определенные внутри класса, которые имеют доступ к закрытым методам и полям. Для их вызова не нужен объект. Можно сказать, что функция, которая имеет доступ к закрытым полям и методам. По нему например можно получать значение статического поля. ИмяКласса::ИмяФункции();. Отличие статического метода от обычной внешней функции-на него действуют модификаторы доступа и он имеет доступ к закрытым полям класса, и к статическим и к нестатическим, как статический метод, он своего this не имеет, но если в него передать какой-то объект, то у этого объекта можно обращаться к закрытым полям метода, но нужно помнить, что своего объекта нет и просто так обратиться к нестатическому полю мы не можем.

	
Веселье начинается, когда static функция определена в заголовочном файле .hpp, который подключается тремя файлами .cpp. И в заголовочной функции есть static переменная. static из заголовочного файла вставиться в код каждого файла- в каждом из трех файлов будет своя функция static. И у каждой функции static каждого файла будет свой static переменная.

Ключевое слово static может быть использовано в трех основных контекстах:
	1-внутри функции;{
	Использование static внутри функции является самым простым. Это просто означает, что после того, как переменная была инициализирована, она остается в памяти до конца программы. Вы можете думать об этом, как о переменной, которая хранит свое значение до полного завершения программы. Например, вы можете использовать статическую переменную для записи количества раз, когда функция была вызвана, просто добавив строки  static int count = 0; и count++; в функцию. Так как count является статической переменной, строка static int count = 0; будет выполняться только один раз. Всякий раз, когда функция вызывается, count будет иметь последнее значение, данное ему.
	Пример:
	for(int ix=0; ix < 10; ix++)
	{
	for(int iy = 0; iy < 10; iy++)
	{
		static int number_of_times = 0;
		number_of_times++;
	}
	}
	Вы также можете использовать static таким образом, чтобы предотвратить переинициализацию переменной внутри цикла. 
	Например, в следующем коде переменная number_of_times будет равна 100, 
	несмотря на то что строка static int number_of_times = 0; находится внутри цикла, где она, по-видимому, должна исполнятся каждый раз, когда программа доходит до цикла. 
	Хитрость заключается в том, что ключевое слово static препятствует повторной инициализации переменной
	
	}
	
	2-внутри определения класса{
		Хотя большинство переменных, объявленных внутри класса могут иметь разное значение в каждом экземпляре класса, 
		статические поля класса будут иметь то же значение для всех экземпляров данного класса и даже не 
		обязательно создавать экземпляр этого класса. 
		Полезно представить себе, что статические переменные класса содержат информацию, необходимую для создания новых объектов (например в фабрике классов). 
		Например, если вы хотите пронумеровать экземпляры класса, можно использовать статическую переменную для отслеживания последнего используемого номера. 
		Важно отметить, что хорошим тоном при использовании статических переменных класса является использование class_name::х;, а не instance_of_class.x;. 
		Это помогает напомнить программисту, что статические переменные не принадлежат к одному экземпляру класса, 
		и что вам не обязательно создавать экземпляр этого класса. 
		Как вы уже, наверное, заметили, для доступа к static можно использовать оператор области видимости, ::, когда вы обращаетесь к нему через имя класса.		
		
		class user
		{
		private:
		int id;
		static int next_id;
 
		public:
		static int next_user_id()
		{
		next_id++;
		return next_id;
		}
		// остальные методы для класса user
		user() // конструктор класса
		{
		id = user::next_id++; // или вызов метода, id = user.next_user_id();
		}
		};
		int user::next_id = 0;
		}
	
	3-перед глобальной переменной внутри файла, составляющего многофайловую программу{
	Последнее использование static — глобальная переменная в файле кода. В этом случае использование static указывает, что исходный код в других файлах, которые являются частью проекта, не может получить доступ к переменной.
	Только код внутри того же файла может увидеть переменную (её область видимости ограничена файлом). 
	Эта техника может быть использована для моделирования объектно-ориентированного кода, потому что она 
	ограничивает видимость переменных и таким образом помогает избежать конфликта имен. 
	Этот способ использования static является пережитком Cи.	
		
	}
	
Статические константные переменные можно внутри какой-нибудь структуры хранить:
template <typename T, typename V>
struct SameType// { 
    static const int value =567;
// };

int main()// {
    std::cout << SameType<int,int>::value << std::endl; //567
    return 0;
// }
}//Конец области "static"

Инструкция безусловного перехода goto {
mylabel: // Используется метка
goto mylabel; // Команда с инструкцией безусловного перехода
Пример программы с goto{
#include <iostream>
using namespace std;
int main(){
int n,i=1,s=0;
cout<<"Enter number n=";
cin>>n;
// Используется метка
mylabel:
s+=i;
i++;
// Команда с инструкцией безусловного перехода
if(i<=n) goto mylabel;
cout<<"Sum of natural numbers is: "<<s<<"\n";
return 0;
}
}//Конец Области Пример программы с goto
}//Конец Области Инструкция безусловного перехода goto

auto {
Иногда не знаем тип выражение, но надо сохранить переменную.
Компилятор сам разберется, что это за тип. Для этого использует спецификатор типа auto
auto x=val1+val2;
Спецификатор auto приказывает компирятору вывести тип из инициализатора.
auto w=5; //cout<<w<<endl; выведет пять так компилировал g++ f.cpp  -std=c++11//без него ошибку выдавал.
	
int foo();
int& foo1();
const int foo2();
const int& foo3();

auto ri = foo(); // int
auto ri1 = foo1(); // int
auto ri2 = foo2(); // int
auto ri3 = foo3(); // int
}//Конец области auto

decltype{
	1. decltype(var), когда var — это объявленная переменная (например в функции или как член класса). В этом случае decltype(var) будет иметь в точности тот тип, с которым объявлена переменная.
	2. decltype(expr), expr — выражение. В этом случае типом decltype(expr) будет тип, которое могло бы вернуть это выражение, с той оговоркой, что decltype(expr) будет иметь тип T& (const T&), если expr возвращает lvalue, T, если expr возвращает rvalue типа Т (const T) и T&& (const T&&), если expr возвращает xvalue (rvalue reference).

Что значит “могло бы вернуть”? Это значит то, что decltype не вычисляет переданное ему в качестве аргумента выражение.
int i;
decltype(i); // int
decltype(i + 1); // int
decltype((i)); // int&
decltype(i = 4); //int&
const int foo();
decltype(foo()) ;// int
int&& foo1();
decltype(foo1()) ;// int&


int i = 3;
decltype(i) ri14; // int
decltype((i)) ri15; // int&
}//Конец области decltype

using {
объявление using (using declaration)-позволяет использовать имена из другого пространства имен без указания префикса "ИмяПространстваИмен::".
using ПространствоИмен::имя;
using std::cin;//можно использовать cin, а cout без std выдаст ошибку: error: ‘cout’ was not declared in this scope
Объявление применяется только к одному элеенту пространства имен.
Код в заголовках копируется в текст программы, в которую он включен. Если в коде есть using, он скопируется. В результате может получится конфликт имен.
}//Конец области "using"

mutable{
mutable означает, что спецификатор const, примененный к классу, следует игнорировать. 
По стандарту только данные класса могут быть mutable.
Признак правильного использования mutable: если при доступе к данным через интерфейс класса все выглядит так, будто в классе ничего не менялось, то можно использовать mutable.

Если const struct создана, то можно менять в любой момент переменные, которые mutable
}//Конец области "mutable"

protected{
Класс наследник не имеет доступа к private полям и методам родительского класса.
Для определения закрытых членом класса доступных наследникам используется protected.
Внешний код не сможет изменить поле, а наследники могут.
struct Men // {
protected:
	int age;
// };
struct Student :Men// {
	void get() { this->age = 5;}
	int y;
// };
int main() // {
	Men x;
	//x.age = 5;
	Student vasa;
	vasa.get();
	return 0;
// }
Сам код не может менять vasa.age - выскочит ошибка, а методы vasa могут менять поле.
}//Конец области "protected"

operator , (оператор запятая){
Оператор запятая гарантирует, что сначало первый оператор выполнится, а потом второй. Так можно писать забавные штуки с переменными и присваиванием:
int f()// {
    cout<<"func"<<endl;
    return 1234;
// }
int www()// {
    cout<<"work www"<<endl;
    return 9876;
// }
int main()// {
    int a=0;
    a=(f(),www());
    cout<<a<<endl;//а будет равно выражению, которое вернет www(), первое значение просто игнорируется.
    int b=(9,88);
    cout<<b<<endl; //88
    return 0;
// }
выведет:
func
work www
9876
88
Оператор «запятая» используется для связки нескольких выражений. Левая сторона оператора «запятая» всегда вычисляется как void (то есть не выдающее значения). Это означает, что значение выражения, находящегося с правой стороны, станет значением разделенного запятыми выражения.
Оператор запятая используется чтобы последовательно что-то сделать- последовательно вызвать несколько функций:
void f(){
    static int x=0;
    cout<<"func:"<<x<<endl;
    x+=1;
}
void www(){
    cout<<"work www"<<endl;
}
int main()// {
    f(),f(),www(),f(),f();
    return 0;
// }
Выведет в консоль:
func:0
func:1
work www
func:2
func:3
То есть сначало две функции f() вызовутся, а потом www() и еще две f().
}//Конец области "operator , (оператор запятая)"

inline{
inline double square(int x){return x*x}
Использовав inline мы подсказываем компилятору, что функцию, неплохо было бы, встроить- замена формального вызова функции на тело этой функции. Если функция простая, то быстрее её вставить на этапе компиляции, чем вызывать её, сохранять её адрес, перемещаться по нему, копировать значение, возвращаться.
Такую функцию нельзя разделить на объявление и определение. Лучше в одном месте, в заголовочном файле сразу её объявить и определить.
Все методы, определенные внутри класса, по умолчанию являются inline.
При линковке из всех скомпилированных копий будет выбрана одна. Выберется одна любая.
Часто inline используют, чтобы описать функцию в заголовомном файле, так можно сделать библиотеку-один файл, в котором все функции будут inline. Заголовочный файл будет большим, и его долго компилировать.
}//Конец области "inline"

}//Конец Области ключевые слова.

Итераторы{
У всех библиотечных контейнеров есть итераторы.
Функция-член begin() возвращает итератор, который обозначает символ на первый элемент.
auto b=v.begin(), e=v.end();
Итератор, возвращенный функцией end(), указывает на следующую позицию за концом контейнера(или строки). Этот итератор обозначает несуществующий элемент за концом контейнера. Как индификатор, обозначающий, что обработаны все элементы- итератор после конца.
Если контейнер пуск, begin() возвращает тот же инератор, что и end().
Если контейнер пуст, возвращаемые функциями begin() и end() итератору совпадают и оба являются итератором после конца.
Итератор использует оператор инкремента (оператор ++) для перемещения с одного элемента на следующий.
Большинство итераторов не имеет оператора <. При использовании != можно не заботиться о точном типе обрабатываемого контейнера.

Тип, возвращаемый функциями begin () и end (), зависит от константности объекта, для которого они были вызваны. Если объект является константой, то функции begin () и end() возвращают итератор типа const iterator; если объект не константа, они возвращают итератор типа iterator.
Чтобы позволить специально задать тип const iterator, новый стандарт вводит две новые функции, cbegin () и cend():
auto it3 = v.cbegin(); // it3 имеет тип vector<int>::cons t_iterator
Константный итератор позволяет читать, но не дает менять.
}//Конец области "Итераторы"

Исключения, обработка ошибок{
Фундаментальная идея обработки исключительных ситуаций состоит в том, что функция, обнаружившая проблему, но не знающая как её решить, генерирует исключение в надежде, что вызвавшая её (непосредственно или косвенно) функция сможет решить возникшую проблему.
try// {
	throw 999;
// }
catch(int i)// {	//ловит ошибку, где аргумент число.
	cout<<i<<endl;
// }
catch(...)// {      //все остальное ловит.
	cout<<"Error"<<endl;
// }
Если throw выкинет число, его поймает catch ловящий int или catch(...) который все ловит.
В С++ есть исключения, которые кидает сам С++ за счет throw и есть те, которые кидает процессор.
Процессорные прерывания полностью игнорируются С++, пролетают сквозь все catch и сносят программу:std::terminate.
Есть два вида исключений:
Аппаратные (структурные, SE-Structured Exception), которые генерируются процессором. К ним относятся, например,
	деление на 0;
	выход за границы массива;
	обращение к невыделенной памяти;
	переполнение разрядной сетки.
Программные, генерируемые операционной системой и прикладными программами – возникают тогда, когда программа их явно инициирует. Тот же throw.
С++ по умолчанию не ловит аппаратные исключение, они сквозь catch пролетают. Для виндовс можно настроить vs чтобы она их ловила, да и обертка для vs какая-то на __try есть.

Прерывания — это как бы сигнал процессору, что надо прервать выполнение (их поэтому и назвали прерываниями) текущего кода и срочно сделать то, что указано в обработчике.
Еще есть прерывания, которые генерируются самим процессором при определенных обстоятельствах — исключения:
1-Деление на ноль. Генерируется при, собственно, делении на ноль.
2-Отладочное исключение. Генерироваться само не может, используется для, собственно, отладки.
3-Немаскируемое прерывание. Генерируется при ошибках ОЗУ и невосстановимых ошибках «железа». Их невозможно замаскировать с помощью PIC (Programmable Interrupt Controller — программируемый контроллер прерываний), так как оно идет сразу в процессор, минуя PIC, но можно просто отключить.
4-Точка останова. Тоже используется для отладки, потому что его опкод занимает всего 1 байт, в отличии от остальных INT N. Переназначалось DOS-отладчиками для своих целей.
5-Переполнение. Генерируется инструкцией INTO, если в (E)FLAGS включен бит переполнения.
6-Выход за пределы. Генерируется при ошибке инструкции BOUND.
7-Недопустимый опкод. Генерируется при попытке выполнения недопустимого кода операции.
8-Устройство недоступно. Сейчас не используется, генерировался при попытке использования операций с плавающей точкой на процессорах без FPU.
9-Double fault. Сложно перевести название. Ошибка невосстановима, происходит при невозможности вызвать обработчик исключения.
10-Переполнение сегмента сопроцессора. Больше не используется.
11-Недопустимый TSS. Сегмент состояния задачи задан неправильно.
12-Сегмент отсутствует. Возникает при попытке загрузки сегмента с битом Present == 0.
13-Ошибка сегмента стека. Возникает при попытке загрузки сегмента с битом Present == 0 или переполнении стека.
14-Общая ошибка защиты. Генерируется в очень большом числе случаев, среди них есть ошибка сегмента, попытка выполнения инструкции без необходимых прав, запись туда, куда не надо, попытка доступа к нулевому дескриптору GDT и многое другое.
15-Ошибка страницы. Происходит при чтении или записи в несуществующую страницу памяти, попытке доступа к данным без необходимых прав или другом.
16-Ошибка с плавающей точкой. Происходит при выполнении инструкции FWAIT или WAIT с битом №5 в CR0 == 0.
17-Ошибка при проверке на выравнивание. Происходит только в третьем кольце привилегий процессора, если эта ошибка, конечно, включена.
18-Ошибка при проверке машины. Генерируется процессором при обнаружении «железных» ошибок.
19-Исключение с плавающей точкой SIMD. Генерируется при ошибках с 128-битными числами с плавающей точкой.
20-Ошибка виртуализации.
21-Ошибка безопасности.
22-Тройная ошибка. По сути исключением не является, это даже не прерывание. Происходит при невозможности вызвать Double Fault. Вызывает немедленную перезагрузку компьютера.

Возможно{
Исключения С++ являются частью языка, определенного стандартом языка, и реализованы библиотекой компилятора и среды выполнения. Существуют и другие exceptions, которые обнаруживаются процессором, например, деление на ноль или разыменование указателя NULL. Оба являются примерами Undefined Behavior в стандарте языка. Это faults в терминологии процессора и на x86, например, триггер a fault handler, который затем обслуживается ОС. Затем ОС может сообщить об этой ошибке процессу, вызвавшему его, в Unix это делается с помощью signals. Если ваш процесс установил signal handler для SIGSEGV, например, он может обрабатывать ошибку, сгенерированную CPU, когда процесс разыскивает указатель NULL... этот механизм отделен от исключений С++, определенных языком.

Если в виндах прямо в ядре имеется механизм SEH, который отображается в расширениях MSVC на exceptions, и ошибка сегментации там отображается в прикладной слой в виде exception и может быть перехвачена, то в Linux'е при ошибке сегментации процессу посылается сигнал SIGSEGV, а никаких exceptions не возникает. При желании можно, конечно, написать сигнальный обработчик, и повесить его на перехват SIGSEGV, но это очень порочная практика, обычно ни к чему хорошему не приводящая...
Порочная практика, вероятно, потому, что после выхода за границы массива (например), часть данных, точки выхода из функций (если массив лежал в стеке) и т.д. можно считать неопределёнными. Что ж тут ещё делать, как не срочно завершить приложение, пока переходы в случайные места или использование случайных данных, которые программа считает не случайными, не натворили бог знает чего...
}//Конец области "Возможно"

В Виндовс есть SEH — Structured Exception Handling: Структурированная обработка исключений - механизм обработки программных и аппаратных исключений в операционной системе Microsoft Windows, позволяющий программистам контролировать обработку исключений, а также являющийся отладочным средством[1].

Механизм поддерживается Microsoft только на уровне компилятора с помощью реализации нестандартных синтаксических конструкций __try, __except и __finally.
}//Конец области "Исключения, обработка ошибок"

Преобразования типов{
В С нет конструкторов, деструкторов, есть только простые типы, указатели и структура. Там преобразователь только один, через скобочки или (int)w или в процедурном духе int(w).
	
}//Конец области "Преобразования типов".

C/C++ interface to SQLite ("sqlite3.h") {//http://sqlite.org/quickstart.html //http://sqlite.org/c3ref/funclist.html Список функций
#include "sqlite3.h"

Повторная успешная компиляция{
shell.c
sqlite3.c
sqlite3.def
sqlite3.dll
sqlite3.h
sqlite3ext.h 
Потом прописал:
gcc -shared sqlite3.c -o sqlite3.dll
и в папке sqlite3.dll вместо 1700 стал весить 832.
Создал простой файл, в нем:
#include "sqlite3.h" sqlite3 *db; sqlite3_stmt * pStmt; sqlite3_open("lingualeo.db", &db);
А скомпилировал его:
g++ f.cpp -L . -lsqlite3 
нужно указать, что библиотеку искать в этой папке или выдаст ошибку.
Скачал и распоковал в папку оба архива:
}//Конец области "Повторная успешная компиляция"

Успешная компиляция в windows{
//скачал два архива, один с dll (1700кб) и def, другой с sqlite.h и прочим:
gcc -shared sqlite3.c -o sqlite3.dll //Так я скомпилировал свой dll, который уже весит 800кб. Почти в два раза меньше.
//Про тот компилятор ругался.
g++ w.cpp -L. -lsqlite3 //Таким кодом скомпилировал потом.
//Для кросплатформенности:
g++ w.cpp -L. -lsqlite3 -static-libgcc -static-libstdc++
libgcc_s_dw2-1.dll нужно держать в папке вместе с sqlite3.dll
#include <iostream>
#include <fstream>
#include "sqlite3.h"
#pragma comment(lib, "sqlite3.dll")
using namespace std;

int main(){
sqlite3 *db;
sqlite3_stmt * pStmt;
if (sqlite3_open("./lingualeo.db", &db)){
	cout<<"Error MyERROR: \n"<< sqlite3_errmsg(db)<<endl;
	sqlite3_close(db);
    return 1;}
cout<<"open bd\n";
   
if (sqlite3_prepare(db, "SELECT * FROM 'MainTable';", -1, &pStmt, NULL)){
	cout<<"Error MyERROR: \n"<< sqlite3_errmsg(db)<<endl;
	sqlite3_finalize(pStmt);
	sqlite3_close(db);
    return 1;}
cout<<"Запрос похоже сделался\n";
    
while((sqlite3_step(pStmt)) == SQLITE_ROW){
    int coln = sqlite3_data_count(pStmt);
    for(int j=0; j<coln; j++) {
        cout<<sqlite3_column_text(pStmt, j)<<endl;
    }
    cout<<"end j."<<endl;
};
return 0;
}
	
}//Конец области Успешная компиляция в windows


Иногда чтобы компилировалось надо написать: " g++ f.cpp -lsqlite3" //без -lsqlite3 выдает странные ошибки: undefined reference to `sqlite3_open'
//Тут описание компиляции. Разобратся и опробовать.//https://www.sqlite.org//howtocompile.html#building_a_windows_dll
Пара примеров использования "sqlite3.h"{
sqlite3 *db;
char *db_name="test.sl3";
char *zErrMsg = 0;
//Создание или открытие БД 
error = sqlite3_open(db_name, &db); 
if ( error ) { 
    cout<<"Can't open database: "<<sqlite3_errmsg(db)<<endl; 
	sqlite3_close(db); 
}

//Создание таблицы 
error = sqlite3_exec(db, "CREATE TABLE table1 (id INTEGER PRIMARY KEY,field1 TEXT,field2 TEXT);", NULL, 0, &zErrMsg); 
if ( error ) { 
    cout<<"Can't create tables: "<<sqlite3_errmsg(db)<<endl; 
    sqlite3_close(db); 
}

//Ввод данных в таблицу
error = sqlite3_exec(db, "INSERT INTO table1(field1, field2) VALUES ('Super', 'SQL');", NULL, 0, &zErrMsg);
if ( error ){
    cout<<"Can't insert data to table: "<<sqlite3_errmsg(db)<<endl;
	sqlite3_close(db);
}

}
	
int sqlite3_open(
				const char *filename,   /* Database filename (UTF-8) */
				sqlite3 **ppDb          /* OUT: SQLite db handle */
				);


int sqlite3_exec(
  sqlite3*,                                  /* An open database */
  const char *sql,                           /* SQL to be evaluated */
  int (*callback)(void*,int,char**,char**),  /* Callback function */
  void *,                                    /* 1st argument to callback */
  char **errmsg                              /* Error msg written here */
);
sqlite3_exec это удобная оболочка вокруг функций sqlite3_prepare_v2() /* http://sqlite.org/c3ref/prepare.html*/,
												sqlite3_step() /* http://sqlite.org/c3ref/step.html */ ,
												and sqlite3_finalize() /*  http://sqlite.org/c3ref/finalize.html  */
sqlite3_prepare


Последовательное описание как сделать запрос{
	
Полностью рабочий код{
#include <iostream>
#include <fstream>
#include "sqlite3.h"
using namespace std;
int main(){
sqlite3 *db;
sqlite3_stmt * pStmt;
if (sqlite3_open("/mnt/project/first/Northwind.sl3", &db)){
	cout<<"Error MyERROR: \n"<< sqlite3_errmsg(db)<<endl;
	sqlite3_close(db);
    return 1;}
cout<<"open bd\n";
   
if (sqlite3_prepare(db, "SELECT * FROM 'Region';", -1, &pStmt, NULL)){
	cout<<"Error MyERROR: \n"<< sqlite3_errmsg(db)<<endl;
	sqlite3_finalize(pStmt);
	sqlite3_close(db);
    return 1;}
cout<<"Запрос похоже сделался\n";
    
while((sqlite3_step(pStmt)) == SQLITE_ROW){
    int coln = sqlite3_data_count(pStmt);
    for(int j=0; j<coln; j++) {
        cout<<sqlite3_column_text(pStmt, j)<<endl;
    }
    cout<<"end j."<<endl;
};
return 0;
}
}//Конец области "Полностью рабочий код"

sqlite3 *db;
sqlite3_stmt * pStmt;
int i, j, coln, rc;
char *sql[] = {//Массив с инструкциями. Чтобы извлекать инструкцию по sql[i]
    "INSERT INTO tbl1 VALUES(NULL, 'Ben Frees', 2478);",
    "INSERT INTO tbl1 VALUES(NULL, 'Roy Askey', 2289);",
    "INSERT INTO tbl1 VALUES(NULL, 'Lary Terner', 2021);",
    "INSERT INTO tbl1 VALUES(NULL, 'Jonny Hitlop', 1471);",
    "INSERT INTO tbl1 VALUES(NULL, 'Zoran Covoc', 1143);",
    "SELECT N AS 'NUMBER', nm AS 'NAME', score AS 'SCORE' FROM tbl1;"
    "DROP TABLE tb1;"
    "VACUUM;"
};  
 // открытие (создание) БД
if (sqlite3_open("exam3.db", &db)){
	printf("Error: %s\n", sqlite3_errmsg(db));
	sqlite3_close(db);
	system("pause");
	exit(1);
}
// шаг 1 подготовка SQL инструкции к выполнению 
//(компиляция ее в байт-код)
if (sqlite3_prepare(db, sql[i], -1, &pStmt, NULL)){
	printf("Error: %s\n", sqlite3_errmsg(db));
	sqlite3_finalize(pStmt);
	sqlite3_close(db);
	system("pause");
	exit(1);
}
// шаг 2 выполнение SQL инструкций
while((rc = sqlite3_step(pStmt)) == SQLITE_ROW){ //SQLITE_ROW это один из макросов #define
// тело цилка выполнится только для инструкции SELECT для остальных запросов функция  sqlite3_step вернет SQLITE_DONE
// получить число столбцов в текущей строке результата
int coln = sqlite3_data_count(pStmt);

// шаг 3 получение данных
for(j=0; j<coln; j++) 
// получение данных как текстовые строки вне зависимости от объявленного типа столбца
printf("%s\t",sqlite3_column_text(pStmt, j));//здесь просто переделываешь куда тебе надо выводить данные.
}




}//Конец области "Последовательное описание как сделать запрос"


}

GTK+ (  GIMP ToolKit ){
# include <gtk/gtk.h>{ //https://ru.wikipedia.org/wiki/GTK%2B#%D0%9F%D1%80%D0%B8%D0%BC%D0%B5%D1%80_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D1%8B
	https://www.gtk.org/download/ //ссылка на установщик.


#include <gtkmm.h> //https://ru.wikipedia.org/wiki/Gtkmm{
	https://wiki.gnome.org/Projects/gtkmm/MSWindows //возможно тут описана установка.
	https://wiki.gnome.org/Attic/GtkmmOnWindows#Download //Скачивание и зависимости
	gtkmm — официальный C++-интерфейс для GUI-библиотеки GTK+. Включает слоты и сигналы с проверкой типов во время компиляции (благодаря библиотеке libsigc++ (англ.)русск.), наследование виджетов с использованием стандартного способа C++ и полный набор виджетов, предоставляемых GTK+. Графический интерфейс программы может создаваться программно или с использованием Glade.	
	
	
}

C++/Tk { //#include "cpptk.h" http://cpptk.sourceforge.net/
fatal error: gtk/gtk.h: No such file or directory windows
//Подключение заголовочного файла gtk/gtk.h //https://www.linux.org.ru/forum/development/7633744



}

Qt Framework {

!!!!qt.conf!!!Пихать к каждому exe{
	
[Paths]
Prefix=.
Libraries=.
Plugins=plugins
Imports=imports
Qml2Imports=qml

Такое у файла содержание. Без него замучуюсь что-либо на другом компе запускать.
Список файлов, которые мне нужны для запуска на другом компе:
Qt5Core.dll
Qt5Gui.dll
Qt5Sql.dll
Qt5Widgets.dll
libgcc_s_dw2-1.dll
libstdc++-6.dll
libwinpthread-1.dll
lingualeo.db
plugins
qt.conf
untitled.exe     	

plugins:
	platforms:
		qwindows.dll     
	sqldrivers:      
		qsqlite.dll  

}//Конец области "!!!!qt.conf!!!Пихать к каждому exe"

game{
https://www.youtube.com/watch?v=tnPS2t5W_lY&index=6&list=PLMgDVIa0Pg8WrI9WmZR09xAbfXyfkqKWy
//чувак на eng очень хорошо описывает игру, даже без знания английского можно слушать.
https://github.com/MeLikeyCode/QtGameTutorial //этот же чувак на git
http://doc.crossplatform.ru/qt/4.5.0/qgraphicsitem.html //на русском объяснение документации.
Graphics View Framework:
QGraphicsScene - представляет поверхность для управления большим количеством 2д graphical items
QGraphicsItem | QGraphicsRectItem
QGraphicsView
У элемента собственная система координат.
}//Конец области "game"	
	
Разбираю tetrix{
enum { BoardWidth = 10, BoardHeight = 22 }; //интересное и непонятное кодосочетание. 
В игре используется три класса:
1- TetrixWindow -отображение счета, жизней и информации о следующей штуке
2- TetrixBoard - логика игры, ввод клавиатуры, отображение штук в игровой зоне.
3- TetrixPiece -содержит о каждой штуке информацию.

TetrixBoard::drawSquare  - самописная функция, которая отображает все это.


}//Конец области "tetrix"

qrand(){
qrand()%3 выводит число [0,1,2] число 3 он не выводит.
qrand()%3+1;  //выведет [1,2,3]
}//Конец области "qrand()"

Горячие клавиши{
F4	Переключает редактор между файлом реализации (.сpp) и соответствующим заголовочным файлом (.h), которые содержат объявления интерфейса и реализации класса соответственно.
F2	Выполняет переход к месту объявления переменной, функции, класса, на имени которых стоял курсор при нажатии.

Ctrl+Shift+R	Переименование переменной, метода, класса, на имени которых стоит курсор. Имя будет изменено во всех местах, где встречается его использование: не только в текущем файле, но и в других файлах проекта. При замене имени будет учитываться область видимости имени, поэтому замена произойдёт только в местах обращения к имени. Именно этим это действие отличается от обычного поиска и замены текста

Ctrl+Shift+U	Поиск всех мест обращения к переменной, методу, классу на имени которого стоит курсор.

Ctrl+K	Открывает поле быстрого поиска (Locator).

Alt+Enter	Позволяет открыть доступные дополнительные действия для переменной, метода, класса, оператора в позиции курсора. Это дополнительные действия для рефакторинга (реорганизации и улучшения существующего кода) могут содержать изменение порядка параметров, изменения в текущем фрагменте кода, добавление фрагментов кода и т.д

Ctrl+Space	Вызывает выпадающий список автозавершения кода.
}//Конец области "Горячие клавиши"

Некоторые переменные для описания настроек проекта .pro{
Переменная	Описание	Пример
CONFIG	Разнообразные настройки конфигурации проекта (например: режим отладки, вывод предупреждений, компиляция динамической библиотеки и т.п.).	
CONFIG += dll plugin \
	warn_on release
DEFINES	Макроопределения в проекте. Работает так же, как директива препроцессора #define.	
DEFINES +=
DEBUG_OUTPUT \
	CUSTOM_DEFINE
DESTDIR	Путь к папке, где будет создан исполняемый файл.	
DESTDIR = ./bin
INCLUDEPATH	Путь к папкам с заголовочными файлами	
INCLUDEPATH += ./includes \
	./my_header_files
FORMS	Файлы форм Qt Designer.	
FORMS += mainwindow.ui
HEADERS	Заголовочные файлы программы *.h.	
HEADERS += mainwindow.h
LIBS	Пути к динамическим библиотекам и статическим библиотекам, которые используются в программе.	
LIBS += -L./libs \
	-L./my_libs \
	-lmycustomlib
QT	Модули Qt, которые используются в программе.	
QT += core gui widgets \
	network sql xml
RESOURCES	Файл ресурсов.	
RESOURCES = resources.qrc
SOURCES	Исходные тексты программы *.cpp.	
SOURCES += main.cpp \
	mainwindow.cpp
TARGET	Название исполняемого файла или динамической библиотеки.	
TARGET = MyFirstProject
TEMPLATE	Тип проекта (приложение, библиотека, составленный из подпроектов ...)	
TEMPLATE = lib
}//Конец области "Некоторые переменные для описания настроек проекта .pro"

QString {
Для проверки на пустую строку используют метод isEmpty(). Его не следует путать с методом isNull(), который возвращает значение true только для ещё не инициализированной строки
QString( ).isNull ( ); // true (нулевая строка)
QString( ).isEmpty ( ); // true (нулевая строка тоже пустая)
QString( "" ).isNull ( ); // false (пустая строка не является нулевой)
QString( "" ).isEmpty ( ); // true
QString( "abc" ).isNull ( ); // false
QString( "abc" ).isEmpty ( ); // false

QString lQtstringInitial = " I am a standard STL string. ";
std::string lStdstring = lQtstringInitial.toStdString ( );
QString lQtString = QString::fromStdString ( lStdString );

int x = 16;
QString lXStr = QString::number ( x );
}//Конец области "QString"

QList — список общего назначения. {
Для добавления элементов в начало и в конец списка используют методы prepend() и append(). Также можно добавить несколько элементов за раз используя потоковые операторы.
Для доступа к элементам используют метод at(), который принимает индекс элемента в списке в качестве аргумента. Количество элементов в списке возвращают методы size() и count().
}//Конец области "QList — список общего назначения. "

Политики размера (Size Policies){
QSizePolicy::Fixed — sizeHint определяет размеры элемента. Размеры элемента фиксированы;
QSizePolicy::Minimum — sizeHint определяет минимально возможные размеры;
QSizePolicy::Maximum — sizeHint определяет максимально возможные размеры;
QSizePolicy::Preferred — sizeHint определяет рекомендованные размеры для элемента;
QSizePolicy::Expanding — так же как Preferred с тенденцией к увеличению размера;
QSizePolicy::MinimumExpanding — так же как Minimum с тенденцией к увеличению размера;
QSizePolicy::Ignored — sizeHint будет игнорирован, элемент должен занимать столько места на форме, сколько возможно.	
}//Конец области "Политики размера (Size Policies)"

Рисование элементов. Класс QPainter{
Каждый виджет занимает прямоугольную область на экране в соответствии с позицией и размерами. В пределах этой области виджет прорисовывает себя когда становится видимым или когда часть этой области была перекрыта или изменилась геометрия виджета. Для рисования визуальных элементов пользуются примитивами, такими как линии, окружности, прямоугольники, градиенты и т. п. Из примитивов складываются сложные элементы, такие как разнообразные рамки, поля, панели и т. д. Для рисования примитивов в Qt пользуются специальным классом QPainter.

QPainter обладает богатым набором методов для рисования различных геометрических примитивов, надписей и частей изображений. Для рисования он использует объекты класса QPaintDevice, реализующие область для вывода графической информации (на экран, область памяти, на принтер и т. д.). Класс QWidget как раз наследует от классов QObject и QPaintDevice, что позволяет использовать QPainter для рисования интерфейса.

Оконная система и Qt следят за изменениями размеров, позиции, видимости окон и отдельных виджетов в программе и направляют специальные события, которые сообщают каждый виджет о необходимости обновления вида. В виртуальном обработчике paintEvent() виджеты имеют возможность использовать QPainter для собственного отражения. В нашем примере мы определим обработчик события QPaintEvent.
{
#include <QWidget>
class LedIndicator : public QWidget
{
	Q_OBJECT
	Q_PROPERTY( QString TextREAD TextWRITE setText )
	Q_PROPERTY( bool turnedOn READ isTurnedOn WRITE setTurnedOn NOTIFY
		state toggled )
public :
.....
	QSizeminimumSizeHint ( ) const;
... .
protected :
	void paintEvent ( QPaintEvent *);
.....
};
void LedIndicator::paintEvent ( QPaintEvent *pEvent )
{
//Создаём объект QPainter и указываем QPaintDevice текущий виджет
QPainter lPainter ( this );
//Используем сглаживание при рисовании для лучшего вида
lPainter.setRenderHint ( QPainter::Antialiasing );
//Центр окружности индикатора QPoint — класс для описания точки
QPoint lLedCenter ( cLedRadius + 1, height ( ) / 2 );
//Фигура, которую мы будем рисовать QPainterPath — класс для описания фигуры
//состоящей из нескольких примитивов
QPainterPath lPath;
//Добавляем окружность
lPath.addEllipse ( lLedCenter, cLedRadius, cLedRadius );
lPainter.save ( ); //Сохраняем настройки после всех изменений мы восстановим их для
//рисования подписи
//Создаём радиальный (окружностями) градиент указываем центр для градиента и радиус
QRadialGradient lGradient ( lLedCenter, cLedRadius );
	if ( mIsTurnedOn ) //Устанавливаем цвет границы и градиент
	{ //для включённого и выключенного состояний
		//Задаём объект QPen — настройки рисования контуров
		//Используем константу для задания цвета контура в конструкторе QPen
		lPainter.setP en (QPen(Qt::darkGreen ) );
		//Задаём цвет в разных точках (0 — центр, 1 — край) цвет будет равномерно изменяться
		//Для задания цвета пользуемся текстовым шестнадцатеричным RGB обозначением
		//— неявное преобразование в QColor
		lGradient.setcolorA t ( 0.2, " #70FF70 " );
		lGradient.setcolorA t ( 1, " #00CC00 " );
	}
	else
	{
		//Здесь задаём чёрный цвет. Конструктор QColor, значение красной,
		//зелёной и синей (0-255) компонент цвета
		lPainter.setPen (QPen( QColor ( 0, 0, 0 ) ) );
		lGradient.setcolorAt ( 0.2, Qt::gray );
		lGradient.setcolorAt ( 1, Qt::darkGray );
	}
//Заполняем фигуру индикатора градиентом
lPainter.fillPath ( lPath, QBrush ( lGradient ) );
//Рисуем границу индикатора
lPainter.drawPath ( lPath );
//Восстанавливаем настройки перед последним сохранением
lPainter.restore ( );
//Устанавливаем шрифт для рисования текста используем QWidget::font(),
//чтобы иметь возможность стилизовать надпись
lPainter.setFont ( font ( ) );
//Квадрат, в котором будет рисоваться текст. QRect — класс для обозначения прямоуольной области
QRect lTextrect ( cLedRadius*2+ cLedSpacing, 0, width ( )- ( cLedRadius *2 +
	cLedSpacing ), height ( ) );
//Рисуем текст в заданном прямоугольнике, выравнивание по левому краю и вертикально по
	центру
lPainter.drawText ( lTextRect, Qt::AlignVCenter | Qt::Alignleft, mText );
}
//Переопределяем виртуальный метод minimumSizeHint() для передачи корректных минимальных
	размеров
QS ize LedIndicator::minimumSizeHint ( ) const
{
	return QS ize ( cLedRadius * 2 //Диаметр индикатора
	+ fontMetrics ( ).width (mText ) //Ширина текста mText
	+ cLedSpacing, //Отступ
	cLedRadius * 2 );
}

#include <QHBoxLayout>
#include <QCheckBox>
#include " LedIndicator .h "
MainWindow::MainWindow ( QWidget * parent ) : QWidget ( parent )
{
//Главное компонование
QHBoxLayout * lLayout = new QHBoxLayout;
set Layout ( lLayout );
//Создаём наш индикатор и добавляем его к компоновщику
LedIndicator * lLedIndicator = new LedIndicator;
lLedIndicator ->setText ( " LED Indicator " );
lLayout->addWidget ( lLedIndicator );
//Создаём и добавляем флажок
QCheckBox *lCheckBox = new QCheckBox ( " Led ON " );
lLayout->addWidget ( lCheckBox );
//Соединяем флажок и индикатор
connect ( lCheckBox, SIGNAL( toggled ( bool ) ),lLedIndicator, SLOT( setTurnedOn ( bool ) ), Qt::UniqueConnection );
}

}//Конец области "пример QPaintEvent"


}//Конец области "Рисование элементов. Класс QPainter"

управлять типом обрамления, типом окна (для оконной системы).{
QMainWindow — окно приложения, которое может содержать меню, панели, строку статуса;
QDialog — диалоговое окно;
QWidget — простое, обычно немодальное окно;

Окно обычно имеет обрамление и заголовок. Текст для заголовка окна устанавливают с помощью метода QWidget::setWindowTitle(). Конструктор класса QWidget принимает дополнительный параметр, для типа окна — Qt::WindowFlags. С помощью этого параметра можно управлять типом обрамления, типом окна (для оконной системы). Например, можно создать окно без обрамления (это полезно в некоторых случаях для оформления, например, для окна загрузки программы) или деактивировать кнопки для минимизации и максимизации окна.

Окно диалога — это особый вид окна, который может использоваться для различных целей, но всегда предоставляет пользователю возможность взаимодействия с программой. Диалоги, как правило, не имеют кнопок для минимизации и максимизации окна. Окна диалога также часто бывают модальными. Модальность окна определяется его поведением. Модальные окна блокируют доступ к другим окнам, пока пользователь не завершит работу с окном (не закроет его). Задать модальность окна можно с помощью метода QWidget::setWindowModality(), если передать ему логическое значение true.

QMainWindow — класс, реализующий функциональность главного окна приложения. Для этого он дополнительно имеет специальные средства работы:

Главное меню (Main menu);
Панели инструментов (Toolbars);
Панель статуса (Status bar);
Присоединяемые панели (Docks);

Присоединяемые панели QDockWidget (dock widgets), монтируются в крае окна, и могут быть перенесены и перегруппированы пользователем, или даже разделены и размещены как отдельные окна. Обычно содержат группу элементов пользовательского интерфейса, объединенных общей целью и назначением или группу инструментов для работы с текущим открытым файлом.

Панель статуса QStatusBar (Status bar) обычно используют для изображения текстовых сообщений о статусе или текущие действия программы, но она может содержать пиктограммы, а также другие виджеты (например, индикаторы прогресса, метки).

}//Конец области "управлять типом обрамления, типом окна (для оконной системы). "

Ресурсы программы{
Часто бывает необходимо добавить в программу дополнительные файлы такие как изображения и значки, используемые при оформления интерфейса, звуковые файлы для уведомлений пользователя, сценарии, выполняемые программой и т.д.

Добавляя файл как ресурс в программу, мы указываем, что хотим включить данные, содержащиеся в этом файле в исполняемый файл. Таким образом скомпилированная программа будет содержать все ресурсные файлы внутри. Средства Qt позволяют обращаться к этим данным, и считывать файлы в ресурсах так же, как и обычные файлы в файловой системе.

Для демонстрации работы с ресурсами в Qt добавим изображения для пунктов меню и кнопки на панель инструментов текстового редактора.{
	В папке проекта создадим подкаталог resources. Внутри добавим еще одну вложенную папку с названием images и добавим туда значки для меню.
	Вызовем мастер создания новых файлов и проектов. Выберем раздел Qt и создадим Qt Resource File (Файл ресурсов Qt). В следующем окне мастера, введем для файла имя в поле Name (Имя): resources.qrc. В поле Path (Путь) нажмем на кнопку и в диалоге выберем созданную папку resources. Нажмем Next (Далее) и в следующем окне Finish (Завершить).
	Выберем созданный файл ресурсов в дереве проекта (раздел Resources) и откроем его. В главном окне Qt Creator появится редактор ресурсов, который состоит из браузера ресурсов (сверху) и панели редактирования (снизу). На нижней панели выберите Add-> Add Prefix (Добавить->Добавить префикс). Сразу же в редакторе появится раздел для ресурсов и станет доступным для редактирования его название (поле Prefix). Установите название для раздела: actions.
	Выберите раздел actions в редакторе ресурсов и нажмите внизу на панели Add-> Add Files (Добавить->Добавить файлы). В диалоге выбора файлов откройте папку resources/images внутри папки с проектом, выберите все файлы в папке и нажмите Open. Пиктограммы сразу будут добавлены в раздел и показаны в редакторе.
	Для каждой из пиктограмм можно выбрать псевдоним — второе имя по которому к пиктограмме можно получить доступ. Это делают для того, чтобы при изменении файла не нужно было менять путь к изображению в коде программы. Для этого достаточно добавить другое изображение и установить такой же псевдоним как для старого, а старому изображению, в свою очередь, удалить псевдоним. Установите псевдоним для каждого из изображений согласно действию для которого они предназначены (смотрите на рис. 15.8).
	Изображение для действия можно добавить в коде программы вызвав для действия метод QAction::setIcon(). Например: ui->action_New->setIcon (QIcon(":/actions/new"));
}//Конец области "демонстрация"

для того чтобы получить доступ к ресурсам мы начинаем путь с символов :/ Далее мы указываем раздел, куда мы добавили пиктограммы — actions, и затем указываем псевдоним для самого изображения в ресурсной системе — new
ui->action_New->setIcon (QIcon(":/actions/new"));

}//Конец области "Ресурсы программы"
// https://doc.qt.io/qt-5.10/  Готовые примеры: https://doc.qt.io/qt-5.10/qtexamplesandtutorials.html 

Компиляция для windows:
Чтобы программу перенести на другой комп нужно в папку к exe скопировать папку platforms.
Я совершил наиглупейшую ошибку, скопировав папку platforms из папки Qt5.2.0\Tools\QtCreator\bin\plugins, когда надо было копировать из папки Qt5.2.0\5.2.0-rc1\mingw48_32\plugins
Итого в папке с exe будет:
Папка platforms:
	qminimal.dll  
	qminimald.dll  
	qoffscreen.dll  
	qoffscreend.dll  
	qwindows.dll  
	qwindowsd.dll

Qt5Core.dll
Qt5Gui.dll
Qt5Widgets.dll
libgcc_s_dw2-1.dll
libstdc++-6.dll
libwinpthread-1.dll

Реализовать на qt5:
	lingualeo
	snake
	pazzle
	mario
	tetrix

  
ru.wikipedia.org/wiki/Qt Тут есть список литературы:{
Макс Шлее. Qt 5.3 Профессиональное программирование на C++. — СПб.: БХВ-Петербург, 2015. — С. 928. — ISBN 978-5-9775-3346-1.
Боровский А. Qt 4.7+ Практическое программирование на C++. — СПб.: БХВ-Петербург, 2012. — С. 496. — ISBN 978-5-9775-0757-8.
Макс Шлее. Qt 4.8 Профессиональное программирование на C++. — СПб.: БХВ-Петербург, 2012. — С. 912. — ISBN 978-5-9775-0736-3.
Саммерфилд М. Qt. Профессиональное программирование. Разработка кроссплатформенных приложений на С++. — СПб.: Символ-Плюс, 2011. — С. 560. — ISBN 978-5-93286-207-0.
Макс Шлее. Qt 4.5 Профессиональное программирование на C++. — СПб.: БХВ-Петербург, 2010. — С. 896. — ISBN 978-5-9775-0398-3.
Ж. Бланшет, М. Саммерфилд. Qt 4: Программирование GUI на C++. 2-е дополненное издание. — М.: Кудиц-пресс, 2008. — С. 736. — ISBN 978-5-91136-059-7.
Земсков Ю.В. Qt 4 на примерах. — СПб.: «БХВ-Петербург», 2008. — С. 608. — ISBN 978-5-9775-0256-6.
Ж. Бланшет, М. Саммерфилд. Qt 4: Программирование GUI на C++. — М.: Кудиц-пресс, 2007. — С. 648. — ISBN 978-5-91136-038-2.
Макс Шлее. Qt 4: Профессиональное программирование на C++. — СПб.: БХВ-Петербург, 2007. — С. 880. — ISBN 978-5-9775-0010-6.
Чеботарев А. Библиотека Qt 4. Создание прикладных приложений в среде Linux. — М.: Диалектика, 2006. — С. 256. — ISBN 5-8459-0996-1.
}

Размышления о жизни и пример, который планирую дома запустить{
#include <QtWidgets> //включает в себя классы: QApplication и QLabel.
#include <QObject>


class ClassForEventClickButtom : public QObject {
Q_OBJECT
public slots:
	void slotInc();
};


void ClassForEventClickButtom::slotlnc() { qDebugf) « "I'm a slot";}



int main(int argc, char ** argv) // {
	QApplication app (argc,argv);//контроль и управление приложением.

	QPushButton firstButton ( "Первая кнопка" ) ;
	QPushButton secondButton ( "Вторая кнопка" ) ;
	QPushButton thirdButton ( "Третья кнопка" ) ;
	QPushButton fourthButton ( "Четвертая кнопка" ) ;
	
	QVBoxLayout *mainLayout = new QVBoxLayout; //дух 1С
	mainLayout->addWidget(firstButton); 
	mainLayout->addWidget(secondButton);
	mainLayout->addWidget(thirdButton);
	mainLayout->addWidget(fourthButton);
	
	QObject::connect(
					&firstButton ,
					SIGNAL (clicked () ) ,
					&classForEventClickButtom, 
					SLOT (slotInc ());
	
	
	
	return app.exec();//Это цикл, передает сообщения получаемые от системы обработчику.
	
// }



Фрагменты кода и практические заметки //http://qtdocs.narod.ru/4.1.0/doc/html/qhboxlayout.html
В Qt имеется три вида менеджеров компоновки: QHBoxLayout, QVBoxLayout и QGridLayout.
Компановка:
	QGridLayout	Размещает виджеты в сетке
	QHBoxLayout	Выстраивает виджеты в горизонтальный ряд
	QVBoxLayout	Выстраивает виджеты в линию по вертикали
Один компановщик может входить в другой.
Пример{
FindFileDialog::FindFileDialog(QWidget *parent, const char *name) 
    : QDialog(parent, name) 
// {
  ...
  QGridLayout *leftLayout = new QGridLayout; 
  leftLayout->addWidget(namedLabel, 0, 0); 
  leftLayout->addWidget(namedLineEdit, 0, 1); 
  leftLayout->addWidget(lookInLabel, 1, 0); 
  leftLayout->addWidget(lookInLineEdit, 1, 1); 
  leftLayout->addMultiCellWidget(subfoldersCheckBox, 2, 2, 0, 1); 
  leftLayout->addMultiCellWidget(listView, 3, 3, 0, 1); 
  leftLayout->addMultiCellWidget(messageLabel, 4, 4, 0, 1); 
  
  QVBoxLayout *rightLayout = new QVBoxLayout; 
  rightLayout->addWidget(findButton); 
  rightLayout->addWidget(stopButton); 
  rightLayout->addWidget(closeButton); 
  rightLayout->addStretch(1); //для создания пустой нерастяжимой ячейки.
  rightLayout->addWidget(helpButton); 
  
  QHBoxLayout *mainLayout = new QHBoxLayout(this); 
  mainLayout->setMargin(11); 
  mainLayout->setSpacing(6); 
  mainLayout->addLayout(leftLayout); 
  mainLayout->addLayout(rightLayout); // для добавления ячейки, содержащей другой QLayout в ряд и установки его фактора растяжения.
// }	
Размещением компонентов на форме управляют один QHBoxLayout, один QGridLayout и один QVBoxLayout. QGridLayout и QVBoxLayout расположены рядом друг с дружкой, внутри QHBoxLayout. Рамка вокруг формы имеет ширину 11 пикселей, промежутки между подчиненными виджетами -- 6 пикселей.
	
}

Отправка сигнала:
	QObject::connect(
		const QObject* sender, //sender — указатель на объект, отправляющий сигнал;
		const char* signal, //signal — это сигнал, с которым осуществляется соединение. Прототип (имя и аргументы) метода сигнала должен быть заключен в специальный макрос SIGNAL(method( ) );
		const QObject* receiver, //receiver — указатель на объект, который имеет слот для обработки сигнала;
		const char* slot,		//slot — слот, который вызывается при получении сигнала. Прототип слота должен быть заключен в специальный макрос SLOT(method ( ) ) ;
		Qt::ConnectionType type = Qt:Autoconnection //type — управляет режимом обработки.
);
Пример отправки сигнала:
	QPushButton cmd ( "ADD" ) ;
	cmd.show ( ) ;
	QObject: :connect (
						&cmd, //нажимающаяся кнопка cmd
						SIGNAL (clicked () ) , //по идее предопределенный сигнал нажатия кнопки.
						&counter, //кто получает
						SLOT (slotInc () ) //. При каждом нажатии накнопку вызывается метод slotInc()
						) ;
class Counter : public QObject {
				Q_OBJECT
	private:
		int m_nValue;
	public:
		Counter();
	public slots:
		void slotlnc();
	signals:
	void goodbye ( );
	void counterChanged(int);
};
void Counter::slotInc() {
    emit counterChanged(++m_nValue);
    if (m_nValue == 5) {
        emit goodbye();
    }
}





/*Теория о философии.
Любая Qt-программа должна использовать хотя бы один модуль: QtCore,QtGui, QtWidgets
класс Qwidget — это базовый класс для всех элементов управления библиотеки Qt.
В него входят:
	классы для автоматического размещения элементов: QVBoxLayout,QHBoxLayout (см. главу 6);
	классы элементов отображения: QLabel,QLCDNumber (см. главу 7);
	классы кнопок: QPushButton,QCheckBox,QRadioButton (см. главу 8);
	классы элементов установок: QSlider,QScrollBar (см. главу 9);
	классы элементов ввода: QLineEdit,QSpinBox (см. главу 10);
	классы элементов выбора: QComboBox,QTooiBox(см.главу 11);
	классы меню: QMainwindow и QMenu (см. главы 31 и 34);
	классы окон сообщений и диалоговых окон: QMessageBox,QDiaiog (см. главу 32);
	классы для рисования: QPainter,QBrush,QPen,QColor (см. главу 18);
	классы для растровых изображений: Qimage,QPixmap (см. главу 19);
	классы стилей (см. главу 26) — отдельному элементу, так и всему приложению может быть присвоен определенный стиль, изменяющий их внешний облик;
	класс приложения QApplication,который предоставляет цикл событий.


Объект класса QApplication представляет собой центральный контрольный пункт Qt-приложений, имеющих пользовательский интерфейс на базе виджетов. Этот объект используется для получения событий клавиатуры, мыши, таймера и других событий, на которые приложение должно реагировать соответствующим образом. Например, окно даже самого простого приложения может быть изменено по величине или быть перекрыто окном другого приложения, и на все подобные события необходима правильная реакция.


концепция функций обратного вызова (callback functions), лежащая в основе
X Window System, основана на использовании обычных функций, которые должны вызы¬
ваться в результате действий пользователя.

Сигналы- метод определенный в классе, только без реализации. Методы сигналов не должны возвращать каких-либо значений, и поэтому перед именем метода всегда должен стоять возвращаемый параметр void.

Сигнал не обязательно соединять со слотом. Если соединения не произошло, то он просто не будет обрабатываться.


*/
	
	
}//Конец области размыщлений о жизни.

Sql в Qt5{
в файл .pro добавляем:
	QT += sql
В .cpp добавляем:
	#include <QtSql>
соединение с базой:
	QSqlDatabase db = QSqlDatabase::addDatabase("QSQLITE");//указываем, что это база SQLite версии 3
	db.setDatabaseName("lingualeo.db");//Имя базы.
	if (!db.open(){ /*do something;*/}
выполнение запроса:
	QSqlQuery query;
	query=db.exec( QString( "SELECT name, salary FROM employee WHERE salary > 50000" ) );
	while (query.next()) // {
		QString name = query.value(0).toString();//Поля задаются индексами, начиная с нуля.
		int salary = query.value(1).toInt();
		qDebug() << name << salary;
		 // }
		 
возможное получение индекса по имени поля:
	QSqlQuery q("select * from employees");
	QSqlRecord rec = q.record();
	int nameCol = rec.indexOf("name"); // index of the field "name"
	while (q.next())
		qDebug() << q.value(nameCol).toString(); // output all names
	
возможная вставка в SQL-запрос значения переменных:
	QSqlDatabase db = QSqlDatabase::addDatabase( "QLINTER" );
	if( !db.open() ) {do something}
	
	QSqlQuery query(db); 
	query.prepare("INSERT INTO cd (year, make, model, color) " 
				   "VALUES (?, ?, ?, ?)"); 
	query.addBindValue(70); 
	query.addBindValue(QString ("FORD")); 
	query.addBindValue(QString("PANTERA")); 
	query.addBindValue(QString("BLACK")); 
	query.exec();
	
	
	QSqlQuery query;
    query.prepare("INSERT INTO person (id, forename, surname) "
                  "VALUES (:id, :forename, :surname)");
    query.bindValue(":id", 1001);
    query.bindValue(":forename", "Bart");
    query.bindValue(":surname", "Simpson");
    query.exec();
	
	
	QSqlQuery query;
    query.prepare("INSERT INTO person (id, forename, surname) "
                  "VALUES (:id, :forename, :surname)");
    query.bindValue(0, 1001);
    query.bindValue(1, "Bart");
    query.bindValue(2, "Simpson");
    query.exec();
	
В новом окне отобразить весь запрос:
	QTableView view;
	QSqlQueryModel model;
	model.setQuery("SELECT phone, email "
					"FROM addressbook "
					"WHERE name = 'Piggy';"
					) ;
	view.setModel(&model);
	view.show();
}//Конец области "Sql в Qt5"

Возможно: Добавление css файла{
	
// Файл simple.qss
QPushButton // {
	min-width: 8Opx;
// }
QPushButton // {
	border-image: url(:/style/btn.bmp) 5px;
	border-width: 5рх;
// }
QPushButton:hover // {
	border-image: url(:/style/btnhvd.bmp) 5px;
	border-width: 5px;
// }
QPushButton:pressed // {
	border-image: url(:/style/btnprs.bmp) 5px;
	border-width: 5px;
// }


#include <QtWidgets>
//int main (int arge, char** argv)
	QApplication app(argc, argv);	
	QWidget wgt;
	QPushButton* pcmdA = new QPushButton ("Buttonl");
	QVBoxLayout* pvbxLayout = new QVBoxLayout;
	pvbxLayout->addWidget(pcmdA);
	wgt.setLayout(pvbxLayout);
	QFile file(":/style/simple.qss");
	file.open(QFile::Readonly);

	QString strCSS = QLatinlString(file.readAll());
	qApp->setStyleSheet(strCSS);

	wgt.show();
	return app.exec();
}//Конец области "Добавление css файла"

Возможно: звуковые файлы в Qt5{
Простой вариант:
	Класс QSound предоставляет только примитивные возможности воспроизведения звуковых
	файлов формата WAV.
		
	QSound::play(" : /yesterday.wav" ) ;
		
	QSound sound( ":/yesterday.wav" );
	sound.setLoops (3) ; //3 раза
	sound.play();
		
	sound.stop();

QMediaPlayer ():
	QT += multimedia
	
	#include <QMediaPlayer>
	
	QMediaPlayer* pPlayer = new QMediaPlayer;
	pPlayer->setMedia(QUrl::fromLocalFile(":/yesterday.mp3"));
	pPlayer->play();


}//Конец области "звуковые файлы в Qt5"

.pro{
Возможно как-то так можно подключить библиотеку:	
	LIBS += -L../../lib/ —ITools
	INCLUDEPATH = ../../include
}


//Создаём метку, указывая родительский виджет — this, то есть экземпляр класса ParentWidget.
QLabel * lLabel=new QLabel ( this );
или:
QPushButton * lPushButton = new QPushButton;
lPushButton->setParent ( lSomeWidget );
Обратите внимание на то, как мы создавали элементы пользовательского интерфейса в динамической памяти используя оператор new. Это гарантирует, что элементы не будут удалены после завершения работы конструктора ParentWidget.

Также с помощью соединений между слотами и сигналами может происходить передача параметров. Например, визуальный элемент QCheckBox выпускает сигнал toggled() каждый раз при установке и снятии флажка. Сигнал toggled() передаёт один параметр — булевое значение: true — если флажок установлен, false — если нет. Мы сможем соединить его со слотом setChecked() кнопки, который также принимает булево значение и устанавливает кнопку в положение "включено" (true) или "выключено" (false). Заметьте: мы использовали метод setCheckable(), который устанавливает для кнопки режим переключения между двумя состояниями.

lPushButton->setCheckable ( true );
connect ( lCheckBox, SIGNAL( toggled ( bool ) ), lPushButton,SLOT( setChecked ( bool ) ) );
порядок и тип параметров должен совпадать у объекта, который передаёт сигнал, и у объекта-получателя;
сигнал или слот получателя может опускать некоторые или все остальные параметры, при этом порядок и тип параметров, которые остались у получателя, должны совпадать с первыми параметрами сигнала.
Для того, чтобы объект мог принимать участие в сигнально-слотовом взаимодействии, нужно удовлетворить несколько условий. Класс, экземпляром которого является объект, должен наследовать от класса QObject (в случае множественного наследования QObject должен быть первым в списке классов).
Также нужно добавить к описанию класса (перед описанием любых других членов класса в секции private) макрос Q_OBJECT, который будет обработан метаобъектным компилятором moc (программа, которая выполняет предварительную обработку текста программы при запуске qmake и генерирует дополнительный код для реализации возможностей, которые предоставляет Qt). Далее в описании класса можно указать собственно сигналы и слоты. Сигналы описываются в разделе signals, а слоты — в разделе slots, где перед названием раздела стоит спецификатор доступа (public, private либо protected).
}//Конец области "Qt Framework"

Windows API (Application Programming Interface)  #include <windows.h> {
chcp 65001  //Сменить кодировку в консоли.
#include <windows.h> 
#ifdef UNICODE //попробовать что-то такое # Unicode and ANSI names  CreateWindowW (Unicode) and CreateWindowA (ANSI)
#define CreateWindow  CreateWindowW
#else
#define CreateWindow  CreateWindowA
#endif

– это набор готовых классов, функций, структур и констант, при помощи которых любое приложение может взаимодействовать с операционной системой (ОС) Windows.

Windows API предназначены для процедурного программиро¬
вания, и с реализацией объектно-ориентированных проектов у них наверняка появятся
трудности. 
концепция функций обратного вызова (callback functions), лежащая в основе
X Window System, основана на использовании обычных функций, которые должны вызы¬
ваться в результате действий пользователя.


#include "MP3Player.h"//Рабочий код для vs{
	#include "MP3Player.h"

int main(int argc, TCHAR* argv[])
{
	MP3Player player;

	player.OpenFromFile(L"ex.mp3");

	player.Play();

	while (player.GetPosition() < 20) {
		printf("Test music for 20s : %f elapsed\n",player.GetPosition());
		Sleep(1000);
	}

	player.Close();

	return 0;
}

Пытаюсь разобраться{ //09.02.2018 
//Оконные приложения строятся по принципам событийно-управляемого программирования (event-driven programming) - стиля программирования, при котором поведение компонента системы определяется набором возможных внешних событий и ответных реакций компонента на них. Такими компонентами в Windows являются окна.

Главным элементом программы в среде Windows является окно.
Окно может содержать элементы управления: кнопки, списки, окна редактирования и др.
Эти элементы также являются окнами, но обладающими особым свойством: 
	события, происходящие с этими элементами (и самим окном), приводят к приходу сообщений 
	в процедуру окна.

	
//Более или менее удобно структурированный:
list Windows API Index//https://msdn.microsoft.com/en-us/library/windows/desktop/ff818516(v=vs.85).aspx
Подробнее о кнопках//https://rsdn.org/article/baseserv/api32.xml
Че я паникую? Есть же книги. Ищем книги: Технология программирования на С++. Win32 API-приложения ...
//И так начнем:
Жизнеоборот windows приложения:
	1. Определить класс окна.
	2. Зарегистрировать окно.
	3. Создать окно данного класса.
	4. Отобразить окно.
	5. Запустить цикл обработки сообщений.
//Термин интерфейс здесь следует понимать как способ взаимодействия пользователя и приложения.
//Класс окна — структура, определяющая его свойства.

Перед любой строковой константой ставить L. ( L"so

Код из статьи- опробовать вечером. {//https://prog-cpp.ru/winmain/
//https://prog-cpp.ru/winelements/ а в этой статье указано об создании элементов управления.
//https://prog-cpp.ru/category/windows/ вся серия статей.
#include <windows.h>
LONG WINAPI WndProc(HWND, UINT, WPARAM,LPARAM);
int WINAPI WinMain (HINSTANCE hInstance, HINSTANCE hPrevInstance,
                             LPSTR lpCmdLine, int nCmdShow)
{
  HWND hwnd; // дескриптор окна
  MSG msg; // структура сообщения
  WNDCLASS w; // структура класса окна
  // Регистрация класса окна
  memset(&w,0,sizeof(WNDCLASS));
  w.style = CS_HREDRAW | CS_VREDRAW;
  w.lpfnWndProc = WndProc; // имя оконной функции //Оконная функция - обработка сообщений окна создана отдельно.
  w.hInstance = hInstance;
  w.hbrBackground = (HBRUSH)(WHITE_BRUSH);
  w.lpszClassName = L"My Class";
  RegisterClass(&w);
  // Создание окна
  hwnd = CreateWindow(L"My Class",L"Окно пользователя",
  WS_OVERLAPPEDWINDOW, 500, 300, 500, 380, NULL, NULL, hInstance, NULL);
  ShowWindow(hwnd,nCmdShow); // отображение
  UpdateWindow(hwnd);          // перерисовка
  // Цикл обработки сообщений
  while(GetMessage(&msg,NULL,0,0))
  {
    TranslateMessage(&msg);
    DispatchMessage(&msg);
  }
  return msg.wParam;
}

//Оконная функция - обработка сообщений окна
 //Минимальный вид оконной функции представлен ниже:
LONG WINAPI WndProc(HWND hwnd, UINT Message, WPARAM wparam, LPARAM lparam)
{
  switch (Message)
  {
    case WM_DESTROY:
      PostQuitMessage(0);
      break;
    default:
      return DefWindowProc(hwnd, Message, wparam, lparam);
  }
  return 0;
}


	
}//Конец Код из статьи- опробовать вечером. https://prog-cpp.ru/winmain/

Продолжение кода из статьи, описанной выше{//(см Код из статьи- опробовать вечером. {//https://prog-cpp.ru/winmain/)
//Сама ссылка на статью: https://prog-cpp.ru/winelements/

//Создание элементов управления окна  осуществляется функцией
HWND WINAPI CreateWindow(
  _In_opt_ LPCTSTR lpClassName, // имя предопределенного класса
  _In_opt_ LPCTSTR lpWindowName, // текст
  _In_ DWORD dwStyle, // стиль
  _In_ int x, // координата x
  _In_ int y, // координата y
  _In_ int nWidth, // ширина
  _In_ int nHeight, // высота
  _In_opt_ HWND hWndParent, // дескриптор родительского окна
  _In_opt_ HMENU hMenu, // номер пункта меню
  _In_opt_ HINSTANCE hInstance, // дескриптор приложения
  _In_opt_ LPVOID lpParam ); // NULL

int WINAPI WinMain(
      HINSTANCE hInstance, //hInstance – дескриптор процесса (instance handle) – число, идентифицирующее программу, когда она работает под Windows. Если одновременно работают несколько копий одной программы, каждая копия имеет свое значение hInstance.
      HINSTANCE hPrevInstance,//hPrevInstance — предыдущий дескриптор процесса (previous instance) — в настоящее время устарел, всегда равен NULL.
      PSTR szCmdLine, //szCmdLine — указатель на оканчивающуюся нулем строку, в которой содержатся параметры, переданные в программу из командной строки. Можно запустить программу с параметром командной строки, вставив этот параметр после имени программы в командной строке.
      int iCmdShow) {...}  //iCmdShow — целое константное значение, показывающее, каким должно быть выведено на экран окно в начальный момент. Задается при запуске программы другой программой.  В большинстве случаев число равно 1 (SW_SHOWNRMAL).
  
Пример на С++ Найти сумму двух чисел
Программа создает два поля редактирования для ввода чисел и кнопку "Рассчитать", 
при нажатии на которую выводится статический текст, соответствующий сумме.{

#include <windows.h>
LONG WINAPI WndProc(HWND, UINT, WPARAM, LPARAM); // функция обработки сообщений окна
// Функция преобразования строки в число
int StrToInt(char *s)
{
  int temp = 0; // число
  int i = 0;
  int sign = 0; // знак числа 0- положительное, 1 - отрицательное
  if (s[i] == '-')
  {
    sign = 1;
    i++;
  }
  while (s[i] >= 0x30 && s[i] <= 0x39)
  {
    temp = temp + (s[i] & 0x0F);
    temp = temp * 10;
    i++;
  }
  temp = temp / 10;
  if (sign == 1)
    temp = -temp;
  return(temp);
}
// Функция преобразования числа в строку
char* IntToStr(int n)
{
  char s[40], t, *temp;
  int i, k;
  int sign = 0;
  i = 0;
  k = n;
  if (k<0)
  {
    sign = 1;
    k = -k;
  }
  do {
    t = k % 10;
    k = k / 10;
    s[i] = t | 0x30;
    i++;
  } while (k>0);
  if (sign == 1)
  {
    s[i] = '-';
    i++;
  }
  temp = new char[i];
  k = 0;
  i--;
  while (i >= 0) {
    temp[k] = s[i];
    i--; k++;
  }
  temp[k] = '\0';
  return(temp);
}
// Стартовая функция
int  WINAPI  WinMain(HINSTANCE  hInstance,
  HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)
{
  HWND hwnd; // дескриптор окна
  MSG msg;   // структура сообщения
  WNDCLASS w; // структура класса окна
  memset(&w, 0, sizeof(WNDCLASS)); // очистка памяти для структуры
  w.style = CS_HREDRAW | CS_VREDRAW;
  w.lpfnWndProc = WndProc;
  w.hInstance = hInstance;
  w.hbrBackground = CreateSolidBrush(0x00FFFFFF);
  w.lpszClassName = "MyClass";
  RegisterClass(&w); // регистрация класса окна
  // Создание окна
  hwnd = CreateWindow("MyClass", "Сумма двух чисел",
    WS_OVERLAPPEDWINDOW,
    500, 300, 500, 380,
    NULL, NULL, hInstance, NULL);
  ShowWindow(hwnd, nCmdShow); // отображение окна
  UpdateWindow(hwnd);         // перерисовка окна
  // Цикл обработки сообщений
  while (GetMessage(&msg, NULL, 0, 0)) {
    TranslateMessage(&msg);
    DispatchMessage(&msg);
  }
  return msg.wParam;
}
// Функция обработки сообщений
LONG WINAPI WndProc(HWND hwnd, UINT Message,
  WPARAM wparam, LPARAM lparam) {
  HDC hdc;
  HINSTANCE hInst;
  PAINTSTRUCT ps;
  static HWND hBtn; // дескриптор кнопки
  static HWND hEdt1, hEdt2; // дескрипторы полей редактирования
  static HWND hStat; // дескриптор статического текста
  TCHAR StrA[20];
  int a, b, sum, Len;
  switch (Message) {
  case WM_CREATE: // сообщение создания окна
    hInst = ((LPCREATESTRUCT)lparam)->hInstance; // дескриптор приложения
    // Создаем и показываем первое поле редактирования
    hEdt1 = CreateWindow("edit", "0",
      WS_CHILD | WS_VISIBLE | WS_BORDER | ES_RIGHT, 50, 50, 60, 20,
      hwnd, 0, hInst, NULL);
    ShowWindow(hEdt1, SW_SHOWNORMAL);
    // Создаем и показываем второе поле редактирования
    hEdt2 = CreateWindow("edit", "0",
      WS_CHILD | WS_VISIBLE | WS_BORDER | ES_RIGHT, 150, 50, 60,
      20, hwnd, 0, hInst, NULL);
    ShowWindow(hEdt2, SW_SHOWNORMAL);
    // Создаем и показываем кнопку
    hBtn = CreateWindow("button", "Рассчитать",
      WS_CHILD | WS_VISIBLE | WS_BORDER,
      50, 100, 120, 30, hwnd, 0, hInst, NULL);
    ShowWindow(hBtn, SW_SHOWNORMAL);
    // Создаем и показываем поле текста для результата
    hStat = CreateWindow("static", "0", WS_CHILD | WS_VISIBLE,
      150, 180, 120, 20, hwnd, 0, hInst, NULL);
    ShowWindow(hStat, SW_SHOWNORMAL);
    break;
  case WM_COMMAND:  // сообщение о команде
    if (lparam == (LPARAM)hBtn)    // если нажали на кнопку
    {
      Len = GetWindowText(hEdt1, StrA, 20);
      a = StrToInt(StrA); // считываем число из первого поля
      Len = GetWindowText(hEdt2, StrA, 20);
      b = StrToInt(StrA); // считываем число из второго поля
      sum = a + b;  // находим сумму двух чисел
      SetWindowText(hStat, IntToStr(sum)); // выводим результат в статическое поле
    }
    break;
  case WM_PAINT: // перерисовка окна
    hdc = BeginPaint(hwnd, &ps); // начало перерисовки
    TextOut(hdc, 50, 20, "Введите два числа", 18); // вывод текстовых сообщений
    TextOut(hdc, 50, 180, "Результат:", 10);
    EndPaint(hwnd, &ps); // конец перерисовки
    break;
  case WM_DESTROY: // закрытие окна
    PostQuitMessage(0);
    break;
  default: // обработка сообщения по умолчанию
    return DefWindowProc(hwnd, Message, wparam, lparam);
  }
  return 0;
}
	
}//Конец Пример на С++ Найти сумму двух чисел
  
  
  

}// Конец Продолжение кода из статьи, описанной выше

}

Для любого Windows приложения требуется написать как минимум 2 функции:
Точка входа в приложение, в которой необходимо:
	1-зарегистрировать класс окна
	2-создать окно
	3-запустить цикл обработки сообщений
	пример точки входа{
	#include <windows.h> //добавляем к проекту заголовочный файл с основными функциями и макросами Windows API
 
	int WINAPI WinMain(HINSTANCE hInst,	//хендл на это приложение
	HINSTANCE hPrev,		//оставлен для совместимости с Win16, всегда = 0
	LPSTR szCmdLine,		//командная строка этого приложения
	int nShowCmd)			//параметры, указывающие, как надо запускать приложение
	{//здесь будет текст программы
	}
	
	}

	Пример окошка с надписью:{ //Проверил работает.
//Visual C++ выбираем пункт Win32, там и будет «Проект Win32». 
//По-умолчанию у надписи «Пустой проект» галочка отсутствует. Нам нужно её поставить и убедиться, что у нас «Тип Приложения» — Приложение Windows. 

Кликаем по «Файлы исходного кода» правой кнопкой мыши, в раскрывающемся списке выбираем вкладку – «Добавить», далее «Создать элемент…». В результате у нас должно появиться такое окно:


#include <windows.h> // заголовочный файл, содержащий функции API
 
// Основная функция - аналог int main() в консольном приложении:
int WINAPI WinMain(HINSTANCE hInstance, // дескриптор экземпляра приложения
                   HINSTANCE hPrevInstance, // в Win32 не используется
                   LPSTR lpCmdLine, // нужен для запуска окна в режиме командной строки
                   int nCmdShow) // режим отображения окна
{// Функция вывода окна с кнопкой "ОК" на экран (о параметрах позже)
MessageBox(NULL, L"Привет, мир!!!", L"Оконная процедура", MB_OK);
return NULL; // возвращаем значение функции
}



}

GUI on api{
	




int MessageBox(HWND hWnd, // дескриптор родительского окна
               LPCTSTR lpText, // указатель на строку с сообщением
               LPCTSTR lpCaption, // указатель на строку с текстом заголовка              
               UINT uType);// флаги для отображения кнопок, стиля пиктограммы и прочее
			   
			   
Функция WinMain – первая функция, которая выполнятся в программе (ее еще называют «точка входа» или «entry point»). С нее все начинается, и ею (желательно) все должно закончиться.
	HINSTANCE hInstance – дескриптор экземпляра приложения. Этот дескриптор содержит адрес начала кода программы в ее адресном пространстве. Дескриптор hInstance чаще всего требуется функциям, работающим с ресурсами программы.
	HINSTANCE hPrevInstance – дескриптор предыдущего экземпляра приложения. Этот дескриптор остался от старых версий Windows - скорее всего, вам он никогда не пригодится.
	LPSTR lpCmdLine – указатель на начало командной строки, введенной при запуске программы.
	int nCmdShow – это значение содержит желаемый вид окна (например, свернутый или развернутый)
			   


char работает с ASCII
wchar_t – с Unicode
Они оба используются в макросе TCHAR который позволяет их “перещелкивать” в зависимости от настроек проекта (компилируется под ASCII или под Unicode)
Также, в WinAPI зачастую есть 2 по сути одинаковые функции:
	FuncNameA – для работы с ASCII
	FuncNameW – для работы с Unicode
Строковые типы в WinAPI:
LPSTR – char*
LOWSTR – wchar_t*
LPISTR – TCHAR*
LPCSTR – const char*
LPCWSTR – const wchar_t*
LPCTSTR – const TCHAR*

int WINAPI WinMain WinAPI скрывает под собой используемое соглашение вызова — __stdcall, по которому параметры заносятся в стек справа налево (что позволяет вызывать функции с переменным числом параметров), а очищается он вызываемой функцией.

Регистрация окна осуществляется в два этапа:
	1-заполнение структуры окна
	2-передача структуры на регистрацию
	

// 1й этап
// регистрируется класс
WNDCLASSEX wcx = {0};//обнуляем сразу все поля структуры, чтобы ничего не забыть, т.к. понадобятся нам пока не все// я же говорил что WNDCLASSEX можно не юзать, но MSDN ругается
wcx.cbSize = sizeof(WNDCLASSEX); //по размеру структуры Windows определит, какая версия API была использована
wcx.style = CS_HREDRAW | CS_VREDRAW;// говорим окну перерисовываться при изменении размеров окна
wcx.lpfnWndProc = WndProc;// указываем функцию обработки сообщений
wcx.hInstance = hInst;	// хендл на наше приложение
wcx.hbrBackground = (HBRUSH)GetStockObject(WHITE_BRUSH); // GetStockObject возвращает хендл на белую кисточку, для фона окна
wcx.lpszClassName = TEXT("[lexpenz.com] Win32.");// имя данного класса. Должно быть уникальным, иначе, если класс с таким именем уже зарегестрирован, то в регистрации будет отказано
 
if ( !RegisterClassEx(&wcx) )
return 1;// регистрируем ( не получилось - уходим по английски ) с кодом ошибки (1)
 
// Что делает макрос TEXT? Ответ: Он, если идет компиляция с использованием Unicode, добавляет префикс «l» к переданной ему строке, что делает её Unicode-строкой для компилятора.
 
//Далее идет создание окна:
// 2й этап
// создается окно
HWND hWnd = CreateWindowEx(0,
TEXT("[lexpenz.com] Win32."),//имя класса
TEXT("[lexpenz.com] Win32. Первое приложение Win32."),//заголовок окна
WS_OVERLAPPEDWINDOW, //тип окошка (включает отображение системного меню, кнопок в верхнем правом углу и т.п.)
CW_USEDEFAULT,0,//место появления окна (координаты х и y). Здесь указано место “по умолчанию”, поэтому второй параметр игнорируется
CW_USEDEFAULT,0,//ширина окна (определяется аналогично месту появления)
0, //ссылка на родительское окно
0,//хендл меню
hInst,
0);//код, передаваемый с сообщением WM_CREATE
 
if (!hWnd)    //проверяем успешность создания окна
return 2;
 
// теперь показываем окошко ( nShowCmd - как его показать? минимизированным, обычным или ... )
ShowWindow(hWnd, nShowCmd);
// говорим окну обновиться
UpdateWindow(hWnd);
 
//И, наконец,
// 3й этап
// запуск главного цикла обработки сообщений
MSG msg = {0};// создаем структуру сообщения, которую будем обрабатывать
while( GetMessage(&msg,
0,//говорим получать сообщения от всех окон
0, 0) )//диапазон значений получаемых сообщений (сейчас получаем все)
{	// ждем сообщение
TranslateMessage(&msg);	// преобразуем виртуальную клавишу в ASCII-код и посылаем сообщение WM_CHAR (тут не нужно.Необходимо, если надо работать с текстом, вводимым с клавиатуры)
DispatchMessage(&msg);	// передаем сообщения для обработки в "главную функцию обработки сообщений"
}	


// главная функция обработки сообщений
LRESULT CALLBACK WndProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
switch(msg) {
case WM_DESTROY:// если этого не сделать, то все ваши жалкие попытки закрыть окно будут проигнорированы
PostQuitMessage(0);// отправляет приложению сообщение WM_QUIT. Принимает код ошибки, который заносится в wParam сообщения WM_QUIT
break;
}
return DefWindowProc(hWnd, msg, wParam, lParam);//обрабатываем все остальные сообщения обработчиком "по умолчанию"
}




}

В Windows при каждом событии, произошедшем в системе, отсылается «сообщение Windows» («windows message»). Эти сообщения уведомляют программу о событиях в системе, а программа в свою очередь, может на них реагировать. Сообщения может отсылать не только Windows, но и сами приложения. Это является одним из способов организации связи между процессами в системе. Конечно, программа может отсылать сообщения и самой себе.
СОВЕТ
Сообщение можно отослать функцией SendMessage или ее асинхронным аналогом PostMessage.
Для приема сообщений в программе должен находиться «цикл сообщений» («message loop») который обычно выглядит так:
  //цикл сообщений приложения
  MSG msg = {0};    //структура сообщения
  int iGetOk = 0;   //переменная состояния
  while ((iGetOk = GetMessage(&msg, NULL, 0, 0 )) != 0) //цикл сообщений
  {
    //если GetMessage вернул ошибку - выход
    if (iGetOk == -1) return 3;
    TranslateMessage(&msg);    
    DispatchMessage(&msg);
  }
 Функция GetMessage принимает следующие параметры:

LPMSG lpMsg – указатель на структуру сообщения, в которую GetMessage вернет результат.
HWND hWnd – описатель окна, от которого GetMessage примет сообщение (NULL означает, что GetMessage принимает сообщения от всех окон, принадлежащих потоку).
UINT wMsgFilterMin – наименьший идентификатор сообщения, которое примет GetMessage.
UINT wMsgFilterMax – наибольший идентификатор сообщения, которое примет GetMessage (если в значениях параметров wMsgFilterMin и wMsgFilterMax передать 0, функция будет принимать ВСЕ сообщения).
Функция GetMessage не отдает управление программе, пока не придет какое-либо сообщение. Если пришедшее сообщение – WM_QUIT, функция GetMessage вернет 0. Тогда цикл прервется, и программа завершит свою работу. При любом другом сообщении функция GetMessage возвращает значение больше нуля, и начинатся выполнение тела цикла. При ошибке GetMessage возвращает -1.
СОВЕТ
Сообщение WM_QUIT лучше посылать с помощью специальной функции PostQuitMessage(int iExitCode). Эта функция отошлет сообщение WM_QUIT, а в параметре wParam передаст код завершения программы, указанный в iExitCode.

Функция DispatchMessage должна вызвать «функцию обработки сообщений». В простейшем варианте она выглядит так:

LRESULT CALLBACK WndProc(HWND hWnd, UINT message, 
  WPARAM wParam, LPARAM lParam)
{
  // выборка и обработка сообщений
  switch (message)
  {
    case WM_LBUTTONUP:
      //реакция на сообщение
      MessageBox(hWnd,"Вы кликнули!","событие",0); 
      break;
    case WM_DESTROY:
      //реакция на сообщение
      PostQuitMessage(0);
      break;
    //все необработанные сообщения обработает сама Windows
    default:
      return DefWindowProc(hWnd, message, wParam, lParam);
  // switch (message)
  }
  return 0;
} // конец функции обработчика сообщений

При вызове этой функции ей передаются следующие параметры:

HWND hWnd – описатель окна, от которого пришло сообщение.
UINT message – идентификатор сообщения.
WPARAM wParam и LPARAM lParam – параметры сообщения.
Функция обработки сообщений не обязательно должна иметь имя WndProc. Таких функций в программе может быть несколько, но их прототипы обязательно должны выглядеть так:

LRESULT CALLBACK WndProc(HWND hWnd, UINT message, 
  WPARAM wParam, LPARAM lParam)
При вызове этой функции DispatchMessage передает в параметре message идентификатор сообщения. По этому идентификатору производится выборка и выполняется какое-либо действие («реакция на сообщение»).

В Windows существует очень много сообщений! Писать обработчики для всех сообщений – нереальная задача. Чтобы Windows сама обработала бесполезное для вас сообщение, необходимо вызвать функцию DefWindowProc:

LRESULT DefWindowProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
Желательно передавать все необработанные сообщения этой функции, а результат ее выполнения возвращать при выходе из WndProc. Это очень важно, так как от обработки некоторых сообщений Windows ждет возврата конкретных результатов или действий.

Одной функцией обработки сообщений могут пользоваться несколько окон, но для одного окна может существовать только одна функция обработки сообщений! Как же система определяет, какой именно функцией обработки сообщения пользоваться для конкретного окна и где она находится?! За это отвечает «класс окна» («window class»).

Полный пример{ //Теория и пример
CLASSные окна
При создании нового окна ему присваивается «Класс окна» (window class). Класс окна задает оконную функцию, используемую по умолчанию. Кроме этого, класс окна задает другие параметры окна, такие, как стиль, меню окна, цвет рабочей области и т.д. Разные классы окон могут указывать на одну и ту же функцию обработки сообщений. Для создания класса его необходимо зарегистрировать.

Итак, регистрация! За нее отвечает функция RegisterClass. В ее параметре необходимо передать указатель на структуру WNDCLASS. Обычно для заполнения структуры и вызова RegisterClass создают отдельную функцию. Но это - дело вкуса.

Вот простейший пример такой функции:

ATOM RegMyWindowClass(HINSTANCE hInst, LPSTR lpzClassName)
{
  WNDCLASS wcWindowClass = {0};
  //адрес ф-ции обработки сообщений
  wcWindowClass.lpfnWndProc = (WNDPROC)WndProc;
  //стиль окна
  wcWindowClass.style = CS_HREDRAW|CS_VREDRAW; 
  //дискриптор экземпляра приложения
  //название класса
  wcWindowClass.hInstance = hInst; 
  wcWindowClass.lpszClassName = lpzClassName; 
  //загрузка курсора
  wcWindowClass.hCursor = LoadCursor(NULL, IDC_ARROW); 
  //загрузка цвета окон
  wcWindowClass.hbrBackground = (HBRUSH)COLOR_APPWORKSPACE;  

  //регистрация класса
  return RegisterClass(&wcWindowClass);
}
WNDPROC lpfnWndProc – адрес функции обработки сообщений.
HINSTANCE hInstance – уже знакомая переменная, описывающая экземпляр.
LPCTSTR lpszClassName – имя нового класса.
HICON hCursor – описатель курсора мыши.
HBRUSH hbrBackground – цвет рабочей области окна.
Функция RegisterClass возвращает уникальный «описатель класса окна» типа ATOM. Если при регистрации класса произошла ошибка, это значение будет равно нулю. Чтобы узнать, что произошло, можно вызвать функцию GetLastError().

Существует также функция RegisterClassEx. Это аналог функции RegisterClass с возможностью присвоения окнам маленькой иконки. При работе с этой функцией необходимо пользоваться структурой WNDCLASSEX.

ПРИМЕЧАНИЕ
Если вы решились работать с GUI Windows вручную, то пользоваться нужно именно RegisterClassEx, поскольку приложение, не имеющее маленькой иконки, сегодня выглядит в Windows как минимум странно. – прим.ред.

СОВЕТ
Следите, чтобы имя вашего класса не совпадало с именами системных классов (например: button или edit).

ПРИМЕЧАНИЕ
Я описал не всю структуру. Все незаполненные поля, которых нет в примере, сейчас равны нулю. Об их значениях можно узнать из MSDN.

Сообщения от окон, созданных на базе класса, зарегистрированного описанной выше функцией RegMyWindowClass, будут обрабатываться функцией с именем WndProc. Чтобы функция WndProc поняла, от какого именно окна пришло сообщение, ей передается уникальный описатель окна HWND.

Our Windows
На вашем месте у меня возникло бы желание увидеть те самые пресловутые окна, из-за которых столько шума. Окно в Windows создается функцией CreateWindow. Вот ее прототип:

HWND CreateWindow(LPCTSTR lpClassName, 
  LPCTSTR lpWindowName, 
  DWORD wStyle,
  int x,
  int y,
  int nWidth,
  int nHeight,
  HWND hWndParent,
  HMENU hMenu,
  HINSTANCE hInstance,
  LPVOID lpParam);
Как видите, у функции множество параметров:

LPCTSTR lpClassName – имя класса для создаваемого окна (это имя использовалось при регистрации класса).
LPCTSTR lpWindowName – имя окна.
DWORD dwStyle – стиль окна.
int x – позиция по горизонтали верхнего левого угла окна.
int y – позиция по вертикали.
int nWidth – ширина окна.
int nHeight – высота окна.
HWND hWndParent – используется для создания «дочернего окна» («child window»). Сюда передается описатель «родительского окна» («parent window»).
HMENU hMenu – описатель меню (если hMenu равно нулю, используется меню класса, указанного в lpClassName).
HINSTANCE hInstance – экземпляр приложения.
LPVOID lpParam – указатель на пользовательский параметр окна. Этот указатель со всеми остальными параметрами функции CreateWindow будет занесен в структуру CREATESTRUCT. В сообщениях WM_CREATE или WM_NCCREATE параметр lParam будет содержать указатель на эту структуру.
Функция CreateWindow возвращает уникальный описатель окна HWND. Если функция вернула ноль, значит, во время создания окна произошла ошибка. Какая именно, можно узнать, вызвав функцию GetLastError.

ПРИМЕЧАНИЕ
Существует также функция CreateWindowEx, в которой дополнительно присутствует параметр dwExStyle. С его помощью можно создать окно с дополнительными стилями.

План полета
Итак, сейчас я упрощенно расскажу, что же произойдет, если щелкнуть по окну левой кнопкой мыши.

Пользователь нажимает левую кнопку мыши в то время когда курсор мыши находится над рабочей областью окна.
Windows помещает сообщение WM_LBUTTONDOWN в очередь потока.
Цикл обработки сообщения должен вынуть сообщение с помощью функции GetMessage и передать его на обработку функции DispatchMessage.
Функция DispatchMessage находит окно, которому предназначено сообщение и помещает сообщение в его очередь.
Функция окна обрабатывает сообщение WM_LBUTTONDOWN и возвращает результат.
Тело цикла заканчивается, и управление снова передается функции GetMessage для ожидания новых сообщений.
Итого
WinMain, регистрация класса, цикл сообщений, функция обработки сообщений, создание окна... Как все это связать?! Вот код, который объединяет все написанное выше в одну программу:

#include <windows.h>

// объявление функций
LRESULT CALLBACK WndProc(HWND, UINT, WPARAM, LPARAM);
ATOM RegMyWindowClass(HINSTANCE, LPCTSTR);

////////////////////////////////////////////////////////////////////////// 
// функция вхождений программы WinMain
int APIENTRY WinMain(HINSTANCE hInstance,
             HINSTANCE         hPrevInstance,
             LPSTR             lpCmdLine,
             int               nCmdShow)
{

  // имя будущего класса
  LPCTSTR lpzClass = TEXT("My Window Class!");

  // регистрация класса
  if (!RegMyWindowClass(hInstance, lpzClass))
    return 1;

  // вычисление координат центра экрана
  RECT screen_rect;
  GetWindowRect(GetDesktopWindow(),&screen_rect); // разрешение экрана
  int x = screen_rect.right / 2 - 150;
  int y = screen_rect.bottom / 2 - 75;

  // создание диалогового окна
  HWND hWnd = CreateWindow(lpzClass, TEXT("Dialog Window"), 
    WS_OVERLAPPEDWINDOW | WS_VISIBLE, x, y, 300, 150, NULL, NULL, 
    hInstance, NULL);

  // если окно не создано, описатель будет равен 0
  if(!hWnd) return 2; 

  // цикл сообщений приложения
  MSG msg = {0};    // структура сообщения
  int iGetOk = 0;   // переменная состояния
  while ((iGetOk = GetMessage(&msg, NULL, 0, 0 )) != 0) // цикл сообщений
  {
    if (iGetOk == -1) return 3;  // если GetMessage вернул ошибку - выход
    TranslateMessage(&msg);    
    DispatchMessage(&msg);
  }

  return msg.wParam;  // возвращаем код завершения программы
}

////////////////////////////////////////////////////////////////////////// 
// функция регистрации класса окон
ATOM RegMyWindowClass(HINSTANCE hInst, LPCTSTR lpzClassName)
{
  WNDCLASS wcWindowClass = {0};
  // адрес ф-ции обработки сообщений
  wcWindowClass.lpfnWndProc = (WNDPROC)WndProc;
  // стиль окна
  wcWindowClass.style = CS_HREDRAW|CS_VREDRAW;
  // дискриптор экземпляра приложения
  wcWindowClass.hInstance = hInst;
  // название класса
  wcWindowClass.lpszClassName = lpzClassName;
  // загрузка курсора
  wcWindowClass.hCursor = LoadCursor(NULL, IDC_ARROW);
  // загрузка цвета окон
  wcWindowClass.hbrBackground = (HBRUSH)COLOR_APPWORKSPACE;
  return RegisterClass(&wcWindowClass); // регистрация класса
}

////////////////////////////////////////////////////////////////////////// 
// функция обработки сообщений
LRESULT CALLBACK WndProc(
  HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
  // выборка и обработка сообщений
  switch (message)
  {
  case WM_LBUTTONUP:
     // реакция на сообщение
    MessageBox(hWnd, TEXT("Вы кликнули!"), TEXT("событие"), 0);
    break;
  case WM_DESTROY:
    PostQuitMessage(0);  // реакция на сообщение
    break;
  default:  
    // все сообщения не обработанные Вами обработает сама Windows
    return DefWindowProc(hWnd, message, wParam, lParam);
  }
  return 0;
}
Вот, в принципе, и все! Это полноценное приложение на WinAPI.

Программа регистрирует класс, создает окно этого класса и обслуживает сообщение WM_LBUTTONUP (оно приходит по событию отпускания левой кнопки мыши), показывает окно, и после обработки сообщения снова возвращается в цикл сообщений, находящийся в WinMain.
}


}

ПЕРСПЕКТИВЫ которым нужно уделить внимание:{
реализацию длинной арифметики на с++


server in-process- сервер "в процессе" (в COM-технологиях - тип сервера, который реализуется как DLL, исполняемая в том же процессе, что и клиент).
сервер «в процессе», который реализуется в виде динамической библиотеки (.dll), т.е. исполняется в одном адресном пространстве с клиентом;



Как в С++ реализована память? Архитектура памяти, где находяться статические переменные в памяти?

Valgrind или AddressSanitize -проверка на утечку памяти.

Попробовать:
	https://ru.wikipedia.org/wiki/FLTK  //configure: error: Configure could not find required X11 libraries
	Пример повторить дома:{
		
		
		Следующий пример для FLTK 1.x создаёт окно с кнопкой «Нажми», и по нажатию заменяет её текст:

#include <FL/Fl.H>
#include <FL/Fl_Window.H>
#include <FL/Fl_Button.H>
 
void
button_callback(Fl_Widget* o, void*)
{
	Fl_Button* button = (Fl_Button*) o;
	button->label("Уиииии!");
	button->redraw();
}
 
int
main()
{
	/**
	 * Инициализировать окно шириной 300px,
	 * высотой 200px и названием "Тест".
	 */
	Fl_Window window(300, 200, "Тест.");

	/**
	 * В блоке между методами begin() и end() объявляем кнопку,
	 * левый верхний край которой расположен в (10; 150),
	 * шириною 100px и высотою 30px.
	 */
	window.begin();
		Fl_Button button(10, 150, 100, 30, "Нажми");
	window.end();

	/* Привязать callback-функцию к кнопке. */
	button.callback(button_callback);

	/* Показать окно. */
	window.show();
	return Fl::run();
}
g++ test.cpp -o test -lfltk


	}//КонецОбласти Пример повторить дома

http://docs.wxwidgets.org/stable/overview_helloworld.html //Не получилось


Qt, wxWidgets, JUCE, Nana, eGUI, etc
Qt, GTK, Motiff, Tk, U++
Для разработки интерфейса приложения имеются два основных средства — Windows Forms (WinForms) и Windows Presentation Foundation (WPF).
Кажется это gui типо вин апи: 
Основа https://code-live.ru/post/first-windows-form/ //Тоже не получилось VS просто при создании конструктора форм выдает ошибку
https://habrahabr.ru/post/244281/
http://vscode.ru/helpful-things/kak-pomenyat-tsvet-fona-elementov-v-windows-forms.html
http://www.cyberforum.ru/cpp-cli-winforms/thread1629331.html

juce {\\https://juce.com/tutorials 
https://habrahabr.ru/post/209956/ 
На интуине есть лекция https://www.intuit.ru/studies/courses/2338/638/lecture/13837
Для vs 17:
Перейдите в папку <каталог Juce>/juce/extras/the jucer/build/vc8, откройте проект jucer.vcproj, выберите в выпадающем списке "Конфигурация решений" стандартной панели инструментов значение Release и нажмите клавишу F7, чтобы собрать программу.

Он собрался в:
 C:\Users\User\Desktop\С++\juce\JUCE\extras\binarybuilder\Builds\VisualStudio2017\x64\Debug\ConsoleApp\BinaryBuilder.exe
 
В целом можно открыть :
C:\Users\User\Desktop\С++\juce\JUCE\examples\AnimationAppExample\Builds\VisualStudio2017\AnimationAppExample_App.vcxproj и скомпилировать его.

В папке examples есть примеры, в которых есть папка Builds\VisualStudio2017 там надо открыть файл с расширением vcxproj и он компилируется.
}//Конец области juce

GTK+
wxWidgets
Nana
Tcl/Tk //Не родной
список{
	On Microsoft Windows
The Microsoft Foundation Classes (MFC), a C++ wrapper around the Windows API.
The Windows Template Library (WTL), a template-based extension to ATL and a replacement of MFC
The Object Windows Library, Borland's alternative to MFC.
The Visual Component Library (VCL) is Borland's toolkit used in its C++ Builder and Delphi products.
Windows Forms is .NET's set of classes that handle GUI controls. In the cross-platform Mono implementation, it is an independent toolkit, implemented entirely in managed code (not wrapping the Windows API, which doesn't exist on other platforms).[3]
The Windows Presentation Foundation is the graphical subsystem of the .NET Framework 3.0. User interfaces can be created in WPF using any of the CLR languages (e.g. C#) or with the XML-based language XAML. Microsoft Expression Blend is a visual GUI builder for WPF.
On Unix, under the X Window System
Note that the X Window System was originally primarily for Unix-like operating systems, but it now runs on Microsoft Windows as well using, for example, Cygwin, so some or all of these toolkits can also be used under Windows.

InterViews, a toolkit written in C++.
LessTif, an open source (LGPL) version of Motif.
MoOLIT, a bridge between the look-and-feel or OPEN LOOK and Motif
Motif used in the Common Desktop Environment.
OLIT, an Xt-based OPEN LOOK intrinsics toolkit
Xaw, the Project Athena widget set for the X Window System.
XView, a SunView compatible OPEN LOOK toolkit
	Cross-platform
Based on C (including bindings to other languages)
Elementary, open source (LGPL), a part of the Enlightenment Foundation Libraries, a fast, stable, and scalable library that can be used to create both rich and fast applications that can be used on anything from every day desktop computers to small PDA's and set-top boxes.
GTK+, open source (LGPL), primarily for the X Window System, ported to and emulated under other platforms; used in the GNOME, Rox, LXDE and Xfce desktop environments. The Windows port has support for native widgets.
IUP, open source (MIT), a minimalist GUI toolkit in ANSI C for Windows, UNIX and Linux.
Tk, open source (BSD-style), a widget set accessed from Tcl and other high-level script languages (interfaced in Python as Tkinter).
XForms, the Forms Library for X
XVT, Extensible Virtual Toolkit
Based on C++ (including bindings to other languages)
CEGUI, open source (MIT License), cross-platform widget toolkit designed for game development, but also usable for applications and tool development. Supports multiple renderers and optional libraries.
FLTK, open source (LGPL), cross-platform toolkit designed to be small and fast.
FOX toolkit, open source (LGPL), cross-platform toolkit.
GLUI, a very small toolkit written with the GLUT library.
gtkmm, C++ version of GTK+
Juce provides GUI and widget set with the same look and feel in Microsoft Windows, X Window Systems, OS X and Android. Rendering can be based on OpenGL.
Nana C++, open source (Boost license), a cross-platform toolkit designed to enable modern C++ GUI programming
Qt, commercial and open source (GPL, LGPL) available under Unix and Linux (with X11 or Wayland), MS Windows (Desktop, CE and Phone 8), OS X, iOS, Android, BlackBerry 10 and embedded Linux; used in the KDE, Trinity, LXQt, and Lumina desktop environment, it's also used in Ubuntu's Unity shell.
Rogue Wave Views (formerly ILOG Views) provides GUI and graphic library for Windows and the main X11 platforms.
TnFOX, open source (LGPL), a portability toolkit.
Ultimate++ is a free Win32/X11 application framework bundled with an IDE (BSD license)
The Visual Component Framework (VCF) is an open source (BSD license) C++ framework project.
wxWidgets (formerly wxWindows), open source (relaxed LGPL), abstracts toolkits across several platforms for C++, Python, Perl, Ruby and Haskell.
YAAF, open source (YAAF Open Source License), designed to facilitate creating cross-platform applications.
Zinc Application Framework, cross-platform widget toolkit.
Based on OpenGL
GLUI (LGPL) is a GLUT-based C++ user interface library which provides controls such as buttons, checkboxes, radio buttons, and spinners to OpenGL applications.
Clutter (LGPL) (in C) is an open source software library for creating fast, visually rich and animated graphical user interfaces.
Based on Flash
Adobe Flash allows creating widgets running in most web browsers and in several mobile phones.
Adobe Flex provides high-level widgets for building web user interfaces. Flash widgets can be used in Flex.
Flash and Flex widgets will run without a web browser in the Adobe AIR runtime environment.
Independent software vendors propose to embed the flash application into an executable: MDM Zinc, mProjector and more. Those solutions are cross-platform (depending on the vendors solution).
Based on XML
GladeXML with GTK+
XAML with Silverlight or Moonlight
XML User Interface A Java and XML toolkit for building rich Internet applications.
XUL
Based on JavaScript
Main article: JavaScript library
General

Acid.JS
AJAX Calendar.NET developer control
Backbase Enterprise Ajax Framework
Cappuccino
jQuery UI
MooTools
Qooxdoo Could be understood as Qt for the Web
Script.aculo.us
RIAs

Adobe AIR
DevExtreme by DevExpress
DHTMLX
Dojo Toolkit
Sencha (formerly Ext JS)
Telerik Kendo UI
TIBCO General Interface, a rich set of GUI components that include vector charts and is now also available through an open source BSD license
Webix
WinJS
React
Full-stack framework

Echo3
SmartClient
SproutCore
Telerik UI for ASP/PHP/JSP/Silverlight
UIZE JavaScript Framework
Vaadin - Java
ZK - A Java Web framework for building rich Ajax and mobile applications
Resource-based

Google Web Toolkit (GWT)
Pyjs
RubyJS
FBML －Facebook Markup Language
Web Application Markup Language
No longer developed

Ample SDK
Cooee
Rialto Toolkit
YUI (Yahoo! User Interface Library)
Based on SVG
Raphaël is a JavaScript toolkit for SVG interfaces and animations
Based on .NET
Gtk#, C# wrappers around the underlying GTK+ and GNOME libraries, written in C and available on Linux, MacOS and Windows.
Windows Forms. There is an original Microsoft's implementation that is a wrapper around the Windows API and runs on windows, and Mono's alternative implementation that is cross platform.
Xwt, Mono's toolkit that maps API calls to native platform calls of the underlying platform. In this way it exposes one unified API across different platforms and makes possible for the graphical user interfaces to have native look and feel on different platforms. Runs on Linux, MacOS and Windows.
ETO.Forms, a C# facade for • Windows Forms (based on GDI/GDI+ or Direct2D) and WPF in .NET under Windows, • GTK# (Gtk2 und Gtk3) in MONO under X11, • Aqua/Cocoa (based om MonoMac 32 Bit, MonoMac 64 Bit or Xamarin.Mac) in MONO under OS X, • iOS in MONO, • Android in MONO (Oct. 2017 still under development) and • Windows 8.x/Windows Phone in .NET under WinRT (Oct. 2017 still under development)
Based on Java
The Abstract Window Toolkit (AWT) is Sun Microsystems' original widget toolkit for Java applications. It typically uses another toolkit on each platform on which it runs.
Swing is a richer widget toolkit supported since J2SE 1.2 as a replacement for AWT widgets. Swing is a lightweight toolkit, meaning it does not rely on native widgets.
Apache Pivot is an open-source platform for building rich web applications in Java or any JVM-compatible language, and relies on the WTK widget toolkit.
JavaFX and FXML.
The Standard Widget Toolkit (SWT) is a native widget toolkit for Java that was developed as part of the Eclipse project. SWT uses a standard toolkit for the running platform (such as the Windows API, OS X Cocoa, or GTK+) underneath.
Qt Jambi, the official Java binding to Qt from Trolltech. The commercial support and development has stopped[4]
Based on Object Pascal
IP Pascal uses a graphics library built on top of standard language constructs. Also unusual for being a procedural toolkit that is cross-platform (no callbacks or other tricks), and is completely upward compatible with standard serial input and output paradigms. Completely standard programs with serial output can be run and extended with graphical constructs.
Lazarus LCL (for Pascal, Object Pascal and Delphi via Free Pascal compiler), a class library wrapping GTK+ 1.2, Gtk+ 2.x and the Windows API (Carbon, Windows CE and Qt4 support are all in development).
fpGUI is created with the Free Pascal compiler. It doesn't rely on any large 3rdParty libraries and currently runs on Linux, Windows and Windows CE. A Carbon (OS X) port is underway.
CLX (Component Library for Cross-platform), used with Borland's Delphi, C++ Builder, and Kylix, for producing cross-platform applications. It is based on Qt, wrapped in such a way that its programming interface is similar to that of the VCL toolkit.
Based on Ada
RAPID is the Rapid Ada Portable Interface Design tool. Current implementations utilize the TASH binding to Tcl/Tk, the GNAT to JVM compiler, the Microsoft .NET Framework, or GtkAda.
GWindows is a GUI framework that mostly supports Windows development, but also has incomplete implementations for OS X and Linux.
QtAda, the official Ada binding to Qt.
Based on Objective-C
GNUstep
Cocoa
newSTEP
Based on Eiffel
EiffelVision is a cross-platform, object-oriented framework for graphical user interface development.
Based on Ruby
Shoes (GUI toolkit) is a cross platform framework for graphical user interface development.
}//Конец области список.

Разделение gui и логики программы{
	
Как можно отделить визуальный интерфейс приложения от алгоритма/логики. В qt получается что код строится вокруг GUI, это неприятно >.,.< Хотелось бы писать код и потом связывать его с интерфейсом, но слишком мало опыта в таких вещах. Что можно использовать для этого? Кроссплатформенность не так важна

Для решения этой задачи существует ряд схожих паттернов проектирования.
В частности, это MVC, MVP и MVVM. 
Не имею опыта работы с Qt (думаю, знающие люди подскажут), однако эти паттерны, 
как и любой уважающий себя шаблон проектирования, независимы от конкретных языков
и технологий. Пару слов о самом известном из них - MVC. 
Состоит, как можно видеть, из трех основных частей - 
модели (M), представления(V) и контроллера (C). 
Модель отвечает за реализацию логики приложения, 
представление - за отображение модели,
контроллер является связующим звеном между первыми двумя. 
Здесь важно помнить следующие особенности - модель должна быть независима как от представления, так и от контроллера. Тем самым повышается возможность повторного использования модели, уменьшается связность кода и становится более удобным тестирование бизнес-логики. Второй очень важной особенностью является то, что контроллер должен быть не более чем посредником между моделью и представлением, а потому категорически не рекомендуется сваливать на него функции модели (такое бывает, когда модель вырождается до сущности, отвечающей за работу с данными, а контроллер берет на себя всю бизнес-логику). Такого "раздувания" контроллеров обычно зовется Fat Stupid Ugly Controllers (или ТТУК - Толстые Тупые Уродливые Контроллеры). Это крайне нежелательно, поскольку сводит на нет преимущества MVC-подхода.

Напоследок простой совет (как "выжимка" из вышеозначенного словоблудия) - никогда не запихивайте логику в обработчики событий. Это очень дурная практика, от каждого случая применения которой умирают десять маленьких невинных котят
}

Если стоит задача ускорить исполнение, то можно 
выявить узкие места профайлером 
и переписать эти места с помощью C extensions, получится, что будет 
работать тот же код, но быстрее. 
Подробнее тут Extending Python with C or C++ //https://docs.python.org/3/extending/extending.html
Extending Python with C or C++
	
	
Добавлю к ответу Sergey Lerg что узкие места приложения //https://github.com/albertz/music-player
всегда можно переписать на Си или тех-же плюсах. 
Если реально загоняться по производительности то тогда уж 
лучше реально написать большую часть логики на python а критичные к производительности места на С. Пример: albertz.github.io/music-player

дмс (что такое DMS?)

Кросс-компиляция из Windows под Linux. Получение бинарных файлов под Linux{
	http://www.mingw.org/wiki/HostedCrossCompilerHOWTO
	Build a MinGW Hosted Cross Compiler for Other Platforms
}
Автор - провокатор.
Под какой Linux копилять?
В каждой версии каждого дистра свои версии библиотек.
Hello world наверное везде заработает, а вот что-нибудь посерьёзнее...
Майнентейнеры пакетов в дистрах чем по-вашему занимаются?

Чтобы собрать в Cygwin или ещё в чём программу под Linux. Сначала надо:
1. Определиться с целевым дитстрибутивом
2. Загнать в среду сборки то же окружение что и в целевом дистрибутиве
3. Собрать
4. Всё равно прийдётся тестировать что заработает.

ИМХО проще собирать сразу в целевой системе (если целевая система не на чахлом arm'е работает). Если требуется организовать автоматизированную сборку и управлять ею с компьютера с установленным оффтопиком - это решается по другому.

P.S. Пожалуй единственный вариант когда оправдано собирать подобным образом софт под Linux - если Вы начинаете собирать LFS.

http://forums.codeblocks.org/index.php?topic=3343.0 //Howto - Cross Compiling in Linux using MingW32

установить мак ос.

}//Конец области ПЕРСПЕКТИВЫ

Переодически перечитывать:{

Почему вам должно быть скучно на работе {//https://habrahabr.ru/post/348614/	

Эти советы, возможно, не все найдут полезными. Они адресованы тем, кому на работе бывает скучно. Так скучно, что уныние немного скрашивают лишь утренний контактик и послеобеденный ютубчик. Вот именно от них вам придется отказаться. Зачем? Сейчас узнаете.

Серьезно, выключите ютуб. Волевым движением мышки закройте «Вконтакте». Отпишитесь от каналов с новостями и приколами. Чувствуете? Чувствуете, как наступает тишина, пустота и невыносимая скукотища? Да, именно это нам и нужно! Пусть это чувство охватит вас! Прочувствуйте его! Ощутите, как изнывает от голода мозг. Как он просит хоть кусочек информации. Хоть что-нибудь, над чем можно подумать! Он хочет вестей о кровавом режиме и о смешных котиках. Как, не будет котиков? Ни одного, даже самого завалящего? Ну, тогда… Эй, а помнишь, тебе никак не удавалось написать тот модуль асинхронной загрузки? Выровнять кнопку по вертикали? Задизайнить выпадающий список? Может, хотя бы над этим подумаем? Или взять тот текст, отвергнутый отделом маркетинга? К какому слову они придрались, «очумелый»? А если поменять на «безбашенный»? А, ну как тебе? Скорее открывай редактор! Ты не знал, как реализовать ту функцию — давай напишем сначала тест! Распараллелим потоки! Обернем флексбоксом!

Вы поняли, что произошло с мозгом? Ему было нечем заняться, и он сам начал искать себе задачи и решать их – ведь у него просто не было выбора! Когда нет развлечений, развлечением становится само программирование (верстка/дизайн/копирайтинг…). На любую задачу, достаточно сложную и творческую, мозг набросится с благодарностью. Она станет ему интересна! Вы сможете подсунуть ему все «крепкие орешки», за которые боялись взяться. То есть именно те задачи, которые мы так любим откладывать – ведь совершенно непонятно даже, с какого бока к ним подступиться. Как только вы вспоминаете о такой задаче, рука сама собой тянется к мышке, чтобы открыть вкладку с котиками. Самая настоящая прокрастинация. Вот в этот момент вам надо удержаться. Если вы не знаете, как решить эту задачу – окей, не решайте ее, но и не отвлекайтесь на котиков! Разрешите себе просто посидеть, ничего не делая. Смотрите в потолок или просто закройте глаза. Не думайте ни о чем. Приведите мозг в состояние знакомого уже информационного голода, проще говоря – скуки. И дело сдвинется с места!

Хорошо, вы разобрались со сложной задачей. Вы написали решение. Теперь вы ждете, пока скомпилируется и запустится проект или выполнятся тесты (или маркетинг одобрит ваш текст). Это еще один опасный момент, когда вы можете сорваться. Казалось бы, вы молодец и уже можно идти смотреть на котиков? Нет, котикам и здесь не место! Ваш мозг всегда должен быть на голодном пайке. Откройте доску задач или список багов и просто смотрите на них. Можете ничего не делать! (Но я не удивлюсь, если вам захочется прочитать один баг… а потом посмотреть, воспроизводится ли он… а потом вы решите, что его можно исправить за секунду…)

А как быть, если задача недостаточно сложная, и даже «голодному» мозгу с ней скучно? Ведь бывают задачи простые, но нудные и монотонные. Обычно это такие процессы, в которых нужно повторять одно и то же действие с некоторыми вариациями. Здесь мозгу можно дать задание подумать над самим процессом. Можно ли его как-то упростить? Выделить повторяющиеся и изменяющиеся части, а затем автоматизировать? Такая задачка наверняка будет мозгу интересна. То есть принцип все тот же: мыслительные ресурсы, которые раньше уходили на развлечения — то есть на то, что не связано с вашими текущими задачами — вы перенаправляете в созидательное русло.

Еще есть тот краткий миг между прошлым и будущим, когда вы уже вернулись с обеда, а обеденный перерыв еще не закончился. Вот здесь можно расслабиться и полюбоваться на котиков… но только на аналоговых, оффлайновых! Или пообщаться с коллегами, погулять вокруг офиса, сыграть в пинг-понг. Мозг должен отдыхать без компьютера! Если он сейчас нахватается видосов с приколами, то испортит аппетит, и ваша «диета» пойдет насмарку.

Наконец, некоторым бывает сложно приступить к работе утром или после перерыва. Поможет такой способ: пока вы идете на работу, вообразите себе то, что сделаете в первую очередь. Представьте себе, что вы уже пришли в офис, сели в свое кресло и включили компьютер. С чего вы начнете? Какой откроете файл? Вы наберете первую строчку кода – что это будет? Когда вы придете и сядете за компьютер, вам останется лишь проделать то, что вы представили. Более того, вам захочется сделать это поскорее: мозг не любит, когда над ним «висят» дела, которые он уже обдумал и полностью готов сделать.

Итак, в этом суть: пусть ресурсы вашего мозга не тратятся впустую. Да, ведь и на чтение приколов требуются ресурсы. К тому же из-за постоянного потока развлечений мозг разучивается думать над тем, что требует больше времени и сосредоточенности. Не говоря уже о том, что посторонние мысли засоряют сознание! Посадите свой мозг на диету. Приучайте его к полезной «пище» — хоть ее и сложнее «переварить», в конечном итоге именно она развивает умение мыслить. Не бойтесь скуки: это состояние, которое предшествует вдохновению. И, как сказал Пелевин: «сознание не надо расширять или углублять… его надо постепенно очищать».	
	
}

слова Шона Парент (Sean Parent) с CppCon 2013: “Если вы хотите улучшить качество кода в организации, замените все принципы кодинга одной целью: никаких сырых циклов!”.
Дословно: если вы пишете сырой цикл, скорее всего вы просто не знаете алгоритмов STL.


}

Термины (Не знаю зачем, но пусть будут):{//Выборочно выписываю вручную термины. Не копи паста.
Аргумент ( argument ) - Значение, передаваемое функции.

Библиотечный тип ( library type ) - Тип, определенный в стандартной библиотеке.

Блок ( block ) - Последовательность операторов, заключенных в фигурных скобках.

Буффер ( buffer ) - Область памяти, используемая для хранения данных. Средства ввода (или вывода) зачастую
хранят вводимые и выводимые данные в буфере, работа которого никак не зависит от действий программы.
Буферы вывода могут быть сброшены явно, чтобы принудительно осуществить запись на диск.
По умолчанию буфер объекта cin сбрасывается при обращении к объекту cout, а буфер объекта cout сбрасывается на диск по заверщении программы.

Встроенный тип ( built-in type ) - Тип данных, определенный в самом языке (например int).

Выражение ( expression ) - Наименьшая единица вычислений. Выражение состоит из одного или нескольких операндов или оператора.
Вычисление выражений определяет результат. Например, сложение целочисленных значений ( i + j ) - это арифметическое выражение,
результатом которого является сумма двух значений.

Директива #include делает код в указанном заголовке доступным в программе.

Заголовок ( header ) Механизм, позволяющий сделать определение классов или других имен доступными в нескольких программах. 
Заголовок включается в код программы при помощи директивы #include.

Имя функции ( function name ) - Имя, под которым функция изместна и может быть вызвана.

Инициализация ( initialize ) - Присвоение значения объекту в момент его создания.

Класс ( class ) - Средство определения собственной структуры данных, а также связанных с ними действиями.
Классами являются такие библиотечные типы, как istream и ostream.

Комментарий ( comment ) Игнорируемый компилятором текст в исходном коде.

Конец файла ( end-of-file ) -Специфический для каждой операционной системы маркер, указывающий на заверщение последовательности данных файла.

Манипулятор ( manipulator ) -Объект, непосредственно манипулирующий потоком ввода или вывода ( такой, как std::endl).

Метод ( method ) - Синоним термана функция-член.

Неинициализированная переменная ( uninitialized variable ) -Переменная, которая не имеет исходного значения.
Переменные тип класса, для которых не определено никакого исходного значения, инициализируются согласно определению класса.
Переменные встроенного типа, определенные в функции, являются неинициализируемыми, если они не были инициализированны явно.
Использование значения неинициализированной переменной является ошибкой.

Объект cerr - Объект типа ostream, связанного с потоком стандартного отображения сообщений об ошибке,
который зачастую совпадает с потоком стандартного устройства вывода. По умолчанию запись в объект cerr не буферизируется.
Обычно используется для вывода сообщений об ошибках и других данных, не являющихся частью нормальной логики программы.

Объект cin - Объект типа istream, обычно используемый для чтения данных со стандартного устройства вывода.

Объект clog Объект типа ostream, связанных с потоком стандартного сообщения об ошибке. 
По умолчанию запись в объект clog буферизируется. Обычно используется для записи о ходе выполнения программы в файл журнала.

Объект cout - Объект типа ostream, используемый для записи на стандартной устройство вывода. Обычно используется для вывода данных программы.

Оператор != Не равно. Проверяет неравенство левого и правого операнда.

Оператор () Оператор вызова. Пара круглых скобок () после имени функции.
Приводит к вызову функции. Передаваемые при вызове аргументы функции указывают в круглых скобках.

Оператор ( statement ) -Часть программы, определяющая действие, предпринимаемое при выполнении программы. 
Выражение, заверщающеся точкой с запятой, являектся оператором. Такие операторы, как if for while, имеют блоки, способные содержать другие операторы.

Оператор --. Оператор дискремента. Вычитает единицу из операнда. Например, выражение --i эквивалентно выражению i = i -1.

Оператор . (это не точка, это оператор). Получает два операнда: левый операнд - объект, правый - имя члена класса этого объекта.
Оператор обеспечивает доступ к члену класса именованного объекта.

Оператор ::. Оператор области видимости. Кроме всего прочего, оператор области видимости используется для доступа к элементам по именам в пространстве имен.
Например запись std::cout указывает, что используемое имя cout определено в пространстве имен std.

Оператор ++. Оператор инкремента. Добавляет к операнду единицу. Например выражение ++i эквивалентно выражению i = i + 1.

Оператор <<. Оператор вывода. Записывает правый операнд в поток вывода, указанный левым операндом.

Переменная ( variable ). Именованный объект.

Присвоение ( assigment ). Удаляет текущее значение объекта и заменяет его новым.

Пространство имен ( namespace ). Механизм применения имен, определенных в библиотеках. Имена, определенные в стандартной библиотеке С++ находятся в пространстве имен std.

Редактирование, компиляция, отладка ( edit-compile-debug ). Процесс, опеспечивающий правильной выполнение программы.

Символьный строковой литерал ( character string literal ). Синоним термина строковый литерал.

Список параметров (parameter list ). Часть определения функции. Список параметров определяет аргументы, применяемые при вызове функции. Список параметров может быть пуст.

Строковой литерал ( string literal ). Последовательность символов, заключенных в двойные кавычки.

Структура данных ( data structure ). Логическое объединение типов данных и возможных для них операций.

Тип класса ( class type ). Тип, определенный классом. Имя типа совпадает с именем класса.

Файл исходного кода ( source file ). Термин, используемый для описания файла, который содержит текст программы на языке С++.

Функция ( function ). Именованный блок операторов.

Функция-член ( member function ). Операция, определенная классом. Как правило, функции-члены применяются для работы с определенным объектом.
	
Адрес ( address ) -Номер байта в памяти, начиная с которого распологается объект.

Арифметический тип ( arithmetic type ). Встроенные типы, представляющие логические значения, символы, целые числа и числа с плавающей запятой.

Базовый тип ( base type ). Спецификатор типа, возможно со спецификатором const, который предшествует оператору объявления в объявлении. Базовый тип представляет общий тип, на основании которого строятся операторы объявления в объявлении.

Байт ( byte ). Наименьший адресуемый блок памяти. На большинстве машин байт составляет 8 битов.

Беззнаковый тип ( unsigned ). Целочисленный тип данных, переменные которого способны хранить значения больше или равные нулю.

В области видимости ( in scope ). Имя, которое видимо от текущей области видимости.

Внешняя область видимости ( outer scope ). Область видимости, включающая другую область видимости.

Внутренняя область видимости ( inner scope ). Область видимости, вложенная в другую область видимости.

Внутриклассовый инициализатор ( in-class initializer ). Инициализатор, представленный, как часть объявления переменной-члена класса. За внутриклассовым инициализатором следует символ =, или он заключается в фигурные скобки.

Временный объект ( temporary ). Безымянный объект, создаваемый компилятором при вычислении выражения. Временный объект существует до конца вычисления всего выражения, для которого он был создан.

Глобальная область видимости ( global scope ). Область видимости, внешняя для всех остальных областей видимости.

Идентификатор ( identifier ). Последовательность символов, составляющая имя. Идентификатор зависит от регистра символов.

Инициализация ( initialization ). Присвоение переменной исходного значения при её определении. Обычно переменные следует инициализировать.

Неопределенное поведение ( undefined behavior ). Случай, для которого стандарт языка не определяет значения. Осознанно или неосознанно, но полагаться на неопределенное поведение нельзя. Оно является источником трудно обнаружимаемых ошибок времени выполнения, проблем безопасности и переносимости.

Объект (object). Область памяти, которая имеет тип.
}//Конец области термины

Windows Forms{
Windows Forms — интерфейс программирования приложений (API), отвечающий за графический интерфейс пользователя и являющийся частью Microsoft .NET Framework.
Данный интерфейс упрощает доступ к элементам интерфейса Microsoft Windows за счет создания обёртки для существующего Win32 API в управляемом коде. 
Windows Forms рассматривается как замена более старой и сложной библиотеке MFC.

“Создать проект” слева выберите группу “Visual C++”, а в ней пункт “CLR”. Щелкните по “Пустой проект CLR”, введите имя проекта и нажмите кнопку “OK”.
в “Обозревателе решений” на названии проекта правой кнопкой мыши, выберите пункт “Добавить” и затем “Создать элемент…”. Либо просто нажмите на клавиатуре сочетание клавиш Ctrl + Shift + A.

Загрузится окно “Добавление нового элемента”. В нём щёлкните левой кнопкой мыши по группе UI в выберите элемент “Форма Windows Forms – Visual C++”. Можете изменить имя создаваемой формы. По завершении нажмите кнопку “Добавить”.

Далее откройте файл исходного кода “MyForm.cpp” (если вы изменяли название формы, то файл будет иметь другое имя). В него добавьте следующий текст:
#include "MyForm.h"
using namespace System;
using namespace System::Windows::Forms;
 
[STAThread]
int main(array<String^>^ arg) {
    Application::EnableVisualStyles();
    Application::SetCompatibleTextRenderingDefault(false);
 
    WinFormsTest::MyForm form; //WinFormsTest - имя вашего проекта
	//Project3::MyForm1 form; //У меня так вышло.
	//MyForm1 это класс из MyForm.h
	//public ref class MyForm1 : public System::Windows::Forms::Form
    Application::Run(%form);
}

//27.02.2018 Проверил, работает. Чтобы открылся конструктор, надо:
Щёлкните по названию проекта в “Обозревателе решений” правой кнопкой мыши и затем нажмите кнопку “Свойства”. Либо сразу нажмите сочетание клавиш Alt + Enter.

В “Странице свойств” проекта слева выберите группу “Компоновщик” → “Система”. В раскрывающемся списке “Подсистема” укажите Windows и нажмите кнопку “Применить”.
//Компоновник->Система->Подсистема /* выбираем */ Windows(/Sussysten:Windows)
Далее в разделе “Дополнительно” группы “Компоновщик” в качестве “Точки входа” укажите функцию main (напишите словом). Щелкните кнопку “Применить”, а затем “ОК”.
}//Конец области "Windows Forms"

Внешняя компонена{
Com объект, реализованный, как  inprocess server: https://infostart.ru/public/115486/
Статью целиком читайте в журнале «Системный администратор», №7-8 за 2015 г. на страницах 50-53 http://samag.ru/archive/article/2991
Филиппов О. Расширяем функциональность 1С:Предприятия. Часть 1. Внешние компоненты COM. // «Системный администратор», №7-8, 2015 г. – С. 50-53
Шаблоны внешних компонент на 1С – http://its.1c.ru/db/files/1CITS/EXE/VNCOMPS/VNCOMPS.zip?country=ru.
Обсуждение внешней компоненты: https://habrahabr.ru/post/191014/
Подробное создание вк- https://infostart.ru/public/184119/
Руководство: https://its.1c.ru/db/metodtorg/content/3221/hdoc   https://its.1c.ru/db/content/metod8dev/src/developers/platform/i8103221.htm?_=1519310091


Для создания внешних компонентов используется технология Native API – собственный интерфейс системного программирования 1С:Предприятия 8. Она  поддерживает операционные системы Windows и Linux,  и дает возможность создавать внешние компоненты, работающие как под одной, так и под другой операционной системой.

Внешняя компонента системы «1С: Предприятие» представлена в виде DLL-библиотеки. В коде библиотеки описывается класс-наследник IComponentBase. В создаваемом классе должны быть определены методы, отвечающие за реализацию функций внешней компоненты.

Внешняя компонента может порождать события, обрабатываемые в предопределенной процедуре языка ОбработкаВнешнегоСобытия. Это позволяет подключать к системе 1С:Предприятие 8 сканеры и другие устройства, требующие асинхронного обмена данными.

Внешняя компонента реализует один или несколько объектов компоненты, которые могут использоваться в "1С:Предприятии". Каждый объект компоненты должен наследоваться от абстрактного класса IComponentBase (файл ComponentBase.h входит в комплект поставки) и реализовать все его методы.

Внешняя компонента, разработанная по этой технологии, должна экспортировать из библиотеки четыре функции:
	const WCHAR_T* GetClassNames()	//Получение списка имен объектов компоненты.
	long GetClassObject(const WCHAR_T* clsName, IComponentBase** pIntf)	//Создание экземпляра объекта компоненты. Если объект не может быть создан или не найден объект с указанным именем – возвращается 0.
	long DestroyObject(IComponentBase** pIntf)	//Удаление экземпляра ранее созданного объекта. Компонента должна своими средствами удалить объект и освободить используемую им память. При успешном завершении возвращается 0, иначе – код ошибки (Runtime error).
	AppCapabilities SetPlatformCapabilities(const AppCapabilities capabilities)	//Устанавливает версию поддерживаемых платформой возможностей. Компонента должна вернуть версию, с которой она может работать. Если функция не реализована, то для компоненты не будут доступны возможности вывода сообщений, запроса информации о платформе.
	
Интерфейс компоненты:

Init -при загрузке 1С инициализирует объект компоненты, вызывая метод Init.
setMemManager -Установка менеджера памяти для компоненты.
GetInfo - 1С вызывает этот метод для получения информации о компоненте.
Done - 1С вызывает этот метод при завершении работы с объектом компоненты.
RegisterExtensionAs - В аргумент помещается наименование расширения. 
GetNProps - Возвращает количество свойств данного расширения.
FindProp - Возвращает порядковый номер свойства.
GetPropName - возвращает имя свойства.
GetPropVal - в аргумент помещается значение свойства
SetPropVal - аргумент содержит значение свойства.
IsPropReadable - в аргумент помещается флаг возможности чтения свойства.
IsPropWritable - в помещается флаг возможности записи свойства
GetNMethods - в аргумент помещается количество методов данного расширения.
FindMethod - в аргумент помещается порядковый номер метода.
GetMethodName - в аргумент помещается имя метода с порядковым номером.
GetNParams - в аргумент помещается количество параметров метода.
GetParamDefValue - в аргумент помещается значение по умолчанию метода.
HasRetVal - в аргумент помещается флаг наличия возвращаемого значения у метода.
CallAsProc - Выполняется метод с порядковым номером аргумент.
CallAsFunc - Выполняется метод с порядковым номером аргумент.

Для диалога с пользователем, объект может использовать интерфейс IMsgBox, стандартный для COM Интерфейс IMsgBox унаследован от IUnknown (текст вопроса и две кнопки.)

При возникновении асинхронного события (например, считывания штрих-кода) объект может использовать интерфейс IAsyncEvent для создания внешнего события в "1С:Предприятии". Интерфейс IAsyncEvent унаследован от IUnknown. Все события помещаются в очередь и обрабатываются по порядку появления. Количество запоминаемых событий ограничено длиной очереди. При инициализации длина очереди устанавливается равной 1 и может быть изменена вызовом SetEventBufferDepth, а текущий размер очереди получен с помощью метода GetEventBufferDepth и. Для каждого объекта внешней компоненты поддерживается своя очередь событий. Обработка внешнего события производится предопределенной процедурой ОбработкаВнешнегоСобытия и обработчиками внешних событий в модулях форм.

Внешние компоненты могут создавать свои окна для отображения различной информации, используя интерфейс IExtWndsSupport. Компонента может создавать два типа окон: модальные диалоги, немодальные диалоги.
	Модальные диалоги:
		Модальные диалоги создаются самой компонентой, но при их создании необходимо в качестве родительского окна указать окно, возвращаемое методом GetAppMainFrame для того, чтобы диалог не воспринимался операционной системой как отдельная задача с кнопкой на полосе задач. Работа системы "1С:Предприятие" приостанавливается до завершения работы с диалогом.
	Немодальные диалоги:
		Немодальные диалоги также создаются самой компонентой, но при их создании необходимо в качестве родительского окна указать окно, возвращаемое методом GetAppMDIFrame для того, чтобы диалог не воспринимался операционной системой как отдельная задача с кнопкой на полосе задач. Диалог не останавливает работу 1С:Предприятия и по сути аналогичен формам 1С:Предприятия. Однако следует учесть, что созданный диалог не входит в список открытых окон и не появляется на панели окон, поэтому использование таких диалогов не рекомендуется (вместо них можно использовать формы самого 1С:Предприятия).

Внешние компоненты могут быть упакованы в ZIP-архив. В составе архива включается файл MANIFEST.XML с описанием содержимого. 


}//Конец области "Внешняя компонента"

Проекты{

Leo win api{
g++ w.cpp -L. -static-libgcc -static-libstdc++ -lgdi32 -mwindows   

#include <windows.h>
#include <string>
#include <iostream>

LONG WINAPI WndProc(HWND, UINT, WPARAM, LPARAM); // функция обработки сообщений окна

// Стартовая функция
int  WINAPI  WinMain(HINSTANCE  hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)  {
	HWND hwnd; // дескриптор окна
	MSG msg;   // структура сообщения
	WNDCLASS w; // структура класса окна
	memset(&w, 0, sizeof(WNDCLASS)); // очистка памяти для структуры
	w.style = CS_HREDRAW | CS_VREDRAW;
	w.lpfnWndProc = WndProc;
	w.hInstance = hInstance;
	w.hbrBackground = CreateSolidBrush(0x00FFFFFF);
	w.lpszClassName = "MyClass";
	RegisterClass(&w); // регистрация класса окна
					   // Создание окна
	hwnd = CreateWindow("MyClass", "Сумма двух чисел",
		WS_OVERLAPPEDWINDOW,
		600,//позиция по х где отобразиться окно позиция по горизонтали верхнего левого угла окна.
		300,//позиция по y где отобразиться окно позиция по вертикали.
		650,//длина окна (координаты х), на сколько по х растянется окно по горизонтале.
		300,//высота окна (координаты y)-на сколько по вертикале растянется окно.
		NULL, NULL, hInstance, NULL);
	ShowWindow(hwnd, nCmdShow); // отображение окна
	UpdateWindow(hwnd);         // перерисовка окна
								// Цикл обработки сообщений

	while (GetMessage(&msg, NULL, 0, 0)) {
		TranslateMessage(&msg);
		DispatchMessage(&msg);
	}
	return msg.wParam;
}


// Функция обработки сообщений
LONG WINAPI WndProc(HWND hwnd, UINT Message,
	WPARAM wparam, LPARAM lparam) {
	HDC hdc;
	HINSTANCE hInst;
	PAINTSTRUCT ps;
	static HWND Buttom1; // дескриптор кнопки
	static HWND Buttom2; // дескриптор кнопки
	static HWND Buttom3; // дескриптор кнопки
	static HWND Buttom4; // дескриптор кнопки
	static HWND hStat; // дескриптор статического текста
	//TCHAR StrA[20];
	/*int a, b, sum, Len;*/
	//int Len;
	//std::string a, b, sum;
	//int a1, b1, sum1;
	RECT rect;

	switch (Message) {
	case WM_CREATE: // сообщение создания окна
		hInst = ((LPCREATESTRUCT)lparam)->hInstance; // дескриптор приложения
					
					
	


		
		// Создаем и показываем кнопку
		//Первое число это х, второе это y.
		//Отступ 50-кнопка1 -отступ 50-кнопка2 -отступ 50-кнопка3 -отступ 50-кнопка4 -отступ 50
		// 			50					200  				350					500			=650
		Buttom1 = CreateWindow("BUTTON","Кнопка1",
			WS_CHILD | WS_VISIBLE | WS_BORDER,
			50, 100, 100, 30, hwnd, 0, hInst, NULL);
		ShowWindow(Buttom1, SW_SHOWNORMAL);
		
		Buttom2 = CreateWindow("button", "Кнопка2",
			WS_CHILD | WS_VISIBLE | WS_BORDER,
			200, 100, 100, 30, hwnd, 0, hInst, NULL);
		ShowWindow(Buttom2, SW_SHOWNORMAL);
		
		Buttom3 = CreateWindow("button", "Кнопка3",
			WS_CHILD | WS_VISIBLE | WS_BORDER,
			350, 100, 100, 30, hwnd, 0, hInst, NULL);
		ShowWindow(Buttom3, SW_SHOWNORMAL);
		
		Buttom4 = CreateWindow("button", "Кнопка4",
			WS_CHILD | WS_VISIBLE | WS_BORDER,
			500, 100, 100, 30, hwnd, 0, hInst, NULL);
		ShowWindow(Buttom4, SW_SHOWNORMAL);
		// Создаем и показываем поле текста для результата
		//hStat = CreateWindow("static", "0", WS_CHILD | WS_VISIBLE,
		//	150, 180, 120, 20, hwnd, 0, hInst, NULL);
		//ShowWindow(hStat, SW_SHOWNORMAL);
		break;
	case WM_COMMAND:  // сообщение о команде
		if (lparam == (LPARAM)Buttom1)    // если нажали на кнопку
		{
			
			//Получаем текст, который  кнопке, [элемент, буфер для текст, размер]
			//Len = GetWindowText(hEdt2, StrA, 20);

			//b1 = std::stoi(StrA);
			//std::string www = std::to_string(sum1);
			//char const * qwe = www.c_str();
			
			//char const * qwe="Клик по кнопке 1";
			//SetWindowText(hStat, qwe); //устанавливаем текст
						
		}
		break;
	case WM_PAINT: // перерисовка окна

			HDC hdc= BeginPaint(hwnd, &ps); 
			
			HBRUSH greenBrush = CreateSolidBrush(RGB(0,255,120));
			//Функция закрашивает область hrgn кистью hbr. 
			//FillRgn(HDC hdc, HRGN hrgn, HBRUSH hbr); 
			HRGN hrgn=CreateRectRgn(50, 100,100,30); 

			FillRgn(hdc,hrgn,greenBrush);
			EndPaint(hwnd, &ps); // конец перерисовки
		//TextOut(hdc, 50, 20, "Введите два числа", 18); // вывод текстовых сообщений
		//TextOut(hdc, 50, 180, "Результат:", 10);
		break;
		
	//Область измененния цвета
	case WM_CTLCOLORBTN:
			std::cout<<"Область измененния цвета"<<std::endl;
			break;
			//hdc = BeginPaint(hwnd, &ps);
			//TextOut(hdc, 50, 20, "Введите два числа", 18);
			//SetTextColor(hdc,RGB(240, 10, 150));
            //SetBkColor(hdc, RGB(240, 10, 150));
			//EndPaint(hwnd, &ps);
			//(LRESULT)CreateSolidBrush(RGB(0, 255, 150) );
			//break;
	//Конец области изменения цвета
	case WM_DESTROY: // закрытие окна
		PostQuitMessage(0);
		break;
	default: // обработка сообщения по умолчанию
		return DefWindowProc(hwnd, Message, wparam, lparam);
	}
	return 0;
}





















}

Leo изменение алгоритма выборки{
#include <iostream> //cout
#include <algorithm>//random_shuffle
#include <vector>	//vector
#include <ctime>	//time
#include <cstdlib>	//rand srand
using namespace std;
int myrandom (int i) {return std::rand()%i;}
void print(vector<int> &myvector){
    for(vector<int>::iterator i=myvector.begin();i!=myvector.end();i++){
        cout<<*i<<" ";
    };
    cout<<endl;
}


vector<int> myvector;
for (int i=0; i!=4; ++i) myvector.push_back(i);
print(myvector);	//0 1 2 3
std::srand ( (int)time(0));
random_shuffle ( myvector.begin(), myvector.end(),myrandom);
print(myvector);	//рандомно перемещаются:1 2 0 3 || 0 3 1 2 ||2 1 0 3

Создадим структуру leo, где есть ру, eng и прочее. Запихнем все в динамическую память и отсортируем.
Пока myvector.size()>=4, извлекаем элемент:
myvector.back() извлекли,потом удалили myvector.pop_back()
Так получаем выбранное слово. А остальные три слова рандомом возьмем.

У виджета будет основной вектор, где вся таблица, вектор с четырмя последними элементами, И int показывающий на номер правильного слова из четырех.
}//Конец области "Leo изменение алгоритма выборки"

Leo и qt c новым алгоритмом{
Нужно создать несколько виджетов:
	русско-английский 1х4
	англо-русский 1х4
	русско-английский ввод
	англо-русский ввод
	русско-английский падающий
	англо-русский падающий
	русско-английский массив
	англо-русский массив
	русско английский аудио 1х6
	англо-русский аудио 1х6
	русско-английский аудирование
	англо-русский аудирование
	кроссворд английское слово-русский перевод

режимы:
	1х4:
		одно слово, и нужно нажать на одну из 4 кнопок, которые определяют перевод.
	ввод:
		дано слово, нужно ввести его перевод правильно.
	падающий:
		сверху падает слово, и нужно нажать на одну из 4 кнопок, которые определяют его перевод, пока слово не коснулось низа.
	массив:
		дано слово, нужно к каждую из клеток массива, строки вписать букву перевода: падать [][][][] (fall)
	аудио 1х6:
		кнопка звука, играет аудио, нужно выбрать одну из 6 кнопок, которая определяет его перевод.
	аудирование:
		кнопка звука, играет аудио, нужно вписать перевод слова.
Доп функционал:
	включение/отключение картинок в 1х4
	включение/отключение картинок аудио везде.
	показать правильный ответ везде.

Реализация:
class MainWindow : public QMainWindow  в котором все будет происходить.
centralWidget ()  буду менять виджеты их понадобиться семь:
	1: 1х4
	2: ввод
	3: падающий
	4: массив
	5: аудио 1х6
	6: аудирование
	7: кроссворд
Наследования:
class Buttom : public QPushButton //цвета и фон для кнопок, размер и прочее
class BaseClass : public QWidget //для фона и цветов всех виджетов.
class OneVsFourWidget : public BaseClass
class InputWidget : public BaseClass
class FallWidget : public BaseClass
class ArrayWidget : public BaseClass
class OneForSixAudioWidget : public BaseClass
class AudioIngWidget : public BaseClass
class CrosswordWidget : public BaseClass
}//Leo и qt c новым алгоритмом

Qt кроссворд{
Сетка кроссворда представлена обычной таблицей TableCrosswordEdit(QTableWidget), слова загружаются в список слов ListWord(QStringList), толкования(вопросы) находятся в списке вопросов ListQuestions(QListWidget).
Полезные ссылки:
ютуб и CrosswordGenerator
С++ Составитель кроссвордов
Возможный алгоритм:
1- Сортируем базу слов, чтобы самые длинные располагались в начале;
2- Создаем двумерный символьный массив размерностью N x N, где N можно взять в 1.5 - 2 раза больше, чем самое длинное слово из имеющегося списка;
3- По горизонатли в середину массива помещаем самое длинное слово;
4- Выбираем следующие по длине слово, у которого хоть 1 буква совпадает с первым, и размещаем его в нужном месте по вертикали;
5- Далее реализуем цикл, пока не выберем все слова из нашей базы, или не завершатся возможные позиции для добавления слов:
	1-Поочередно выбираем, добавляем ли мы новое слово по вертикали, или по горизонтали;
	2-Проходим по строкам, или столбцам массива, через 1 (так обеспечим отсутствие "слипания" слов, если добавляем по горизонтали, двигаемся по строкам, иначе - по столбцам), ищем стоки/столбцы, в которых присутствуют обрамленные пустыми ячейками единичные символы, сохраняем эти символы и размер промежутков между ними в элемент некоторого списка, например, из комбинации строк:
	
Каждой ячейке добавим статус false,true. Если клетка граничит с чем-то, ставим 0, иначе ставим 1. Плохая идея. Первое же слово, вокруг себя все единицами пометит.


}//Конец области "Qt кроссворд"	
	
Воспроизведение .wav windows api{
//g++ w.cpp -lwinmm  	
#include <windows.h>
#include <stdlib.h>

using namespace std;
#pragma comment(lib, "winmm.dll")
int main()
// {
    // PlaySound("C:\\Users\\User\\Desktop\\fr\\cartoon001.wav", NULL, SND_FILENAME);
    
    //PlaySound("./cartoon001.wav", NULL, SND_FILENAME);
	PlaySound("./int.wav", NULL, SND_FILENAME);
    system("PAUSE");    
    return 0;
// }
	
}//Конец области Воспроизведение .wav windows api

План: сертификаты{
	
Список платформ с образовательными курсами{//как нибудь посмотреть что там.
Coursera	//платно 2к-6к
EdX	//много курсов. Сертификат 99$
Национальная платформа открытого образования (openedu.ru) //пусто
Udacity		//какой-то непонятный.
Iversity	//пусто
Open2Study	//пусто
Stepic
Лекторий МФТИ (lectoriy.mipt.ru)	//пусто
ИНТУИТ
Универсариум	//пусто
OpenProfession (openprofession.ru)	//пусто
Не участвовал(-а) ранее в курсах на платформах MOOCs		
}//Конец области "Список платформ с образовательными курсами"

Сертификаты чуть ниже, упорядоченные по приоритету-первые, которыми займусь{
В таком порядке:
/*Отмена. Он похоже старый. С компилируемым кодом ассамблера не сходится.*/Ассемблер в Linux для программистов на C //https://www.intuit.ru/studies/courses/3537/779/info
/* №1 */Язык программирования C++ //https://www.intuit.ru/studies/courses/17/17/info
/* №2 */Язык программирования C++ для профессионалов //https://www.intuit.ru/studies/courses/98/98/info
/* №3 */Основы программирования на языке C //https://www.intuit.ru/studies/courses/43/43/info

Программирование //https://www.intuit.ru/studies/courses/13869/1266/info
/*странно*/	Введение в программирование //https://www.intuit.ru/studies/courses/27/27/info
Введение в программирование //https://www.intuit.ru/studies/courses/4453/686/info
Введение в языки программирования C и C++ //https://www.intuit.ru/studies/courses/1039/231/info




win api|формы и qt:
Программирование под Windows в среде Visual C++ 2005 //https://www.intuit.ru/studies/courses/495/351/info
Практикум прикладного программирования на MFC и C++ в среде VS.NET //https://www.intuit.ru/studies/courses/594/450/info
Академия ALT Linux: Программирование на языке С++ в среде Qt Creator //https://www.intuit.ru/studies/courses/3479/721/info

В самом конце:
Алгоритмы на С++ //https://www.intuit.ru/studies/courses/12181/1174/info
Алгоритмизация. Введение в язык программирования С++ //https://www.intuit.ru/studies/courses/16740/1301/info
Академия Microsoft: Структуры и алгоритмы компьютерной обработки данных //https://www.intuit.ru/studies/courses/648/504/info
}//Конец области "упорядоченные по приоритету"
	
	
Сертификаты:
	Английский язык для ИТ-специалистов //https://www.intuit.ru/studies/courses/3691/933/info
Прямая связь с 1С:
	Основы конфигурирования в системе "1С:Предприятие 8.0" //https://www.intuit.ru/studies/courses/86/86/info
	
	Основы разработки для платформы 1С:Предприятие 8.2 в режиме "Управляемое приложение" //https://www.intuit.ru/studies/courses/2318/618/info
	
	Основы разработки прикладных решений для 1С:Предприятие 8.1 //https://www.intuit.ru/studies/courses/617/473/info
	
	Практика бухгалтерского учета в 1С:Бухгалтерии 8 //https://www.intuit.ru/studies/courses/581/437/info	
	
	НИУ ВШЭ (Высшая Школа Бизнес-Информатики): Разработка прикладных решений для платформы "1С:Предприятие 8.1": Разработка прикладных решений для платформы "1С:Предприятие 8.1" //https://www.intuit.ru/studies/professional_skill_improvements/17640/courses/548/info
	
	Разработка прикладных решений для платформы 1С:Предприятие 8.2 в режиме "Управляемое приложение" //https://www.intuit.ru/studies/courses/2321/621/info

	1С:Бухгалтерия 2.0: начало работы //https://www.intuit.ru/studies/courses/2328/628/info

	1С:Бухгалтерия 2.0: особенности учетных работ //https://www.intuit.ru/studies/courses/2329/629/info

	1С:Бухгалтерия 8.1 //https://www.intuit.ru/studies/courses/2333/633/info

Прямая связь с С++/С:
/*странно*/	Введение в программирование //https://www.intuit.ru/studies/courses/27/27/info

	Введение в программирование //https://www.intuit.ru/studies/courses/4453/686/info

	Академия Intel: Введение в разработку мультимедийных приложений с использованием библиотек OpenCV и IPP //https://www.intuit.ru/studies/courses/10621/1105/info

	Академия Intel: Разработка мультимедийных приложений с использованием библиотек OpenCV и IPP //https://www.intuit.ru/studies/courses/10622/1106/info

	Введение в языки программирования C и C++ //https://www.intuit.ru/studies/courses/1039/231/info

	Основы программирования на языке C //https://www.intuit.ru/studies/courses/43/43/info

	Основы разработки программного обеспечения на примере языка С //https://www.intuit.ru/studies/courses/11876/1156/info

	Основы тестирования программного обеспечения //https://www.intuit.ru/studies/courses/48/48/info

	Практикум прикладного программирования на MFC и C++ в среде VS.NET //https://www.intuit.ru/studies/courses/594/450/info

	Программирование //https://www.intuit.ru/studies/courses/13869/1266/info

	Технопарк Mail.ru Group: Программирование на С/С++ //https://www.intuit.ru/studies/courses/3492/734/info

	Программирование на языке C в Microsoft Visual Studio 2010 //https://www.intuit.ru/studies/courses/627/483/info

	Программирование на языке C++ //https://www.intuit.ru/studies/courses/626/482/info

	Академия ALT Linux: Программирование на языке С++ в среде Qt Creator //https://www.intuit.ru/studies/courses/3479/721/info

	Программирование под Windows в среде Visual C++ 2005 //https://www.intuit.ru/studies/courses/495/351/info

	/*Отмена- не интересно, qt приятнее.*/Разработка кроссплатформенных приложений с использованием Juce //https://www.intuit.ru/studies/courses/2338/638/info
	
	Решение вычислительных задач на языке С++ //https://www.intuit.ru/studies/courses/3533/775/info

	Академия Microsoft: Структуры и алгоритмы компьютерной обработки данных //https://www.intuit.ru/studies/courses/648/504/info

	Текстовый ввод-вывод //https://www.intuit.ru/studies/courses/640/496/info

	Язык программирования C //https://www.intuit.ru/studies/courses/97/97/info

	Язык программирования C++ //https://www.intuit.ru/studies/courses/17/17/info

	Язык программирования C++ для профессионалов //https://www.intuit.ru/studies/courses/98/98/info

	Алгоритмизация. Введение в язык программирования С++ //https://www.intuit.ru/studies/courses/16740/1301/info

	Алгоритмы на С++ //https://www.intuit.ru/studies/courses/12181/1174/info

	Ассемблер в Linux для программистов на C //https://www.intuit.ru/studies/courses/3537/779/info

	Введение в CGI //https://www.intuit.ru/studies/courses/36/36/info

Не мешало бы для общего образования:{
Базовые алгоритмы для школьников//https://www.intuit.ru/studies/courses/997/313/info
Базовые и "продвинутые" алгоритмы для школьников //https://www.intuit.ru/studies/courses/998/312/info
Антивирусная защита компьютерных систем //https://www.intuit.ru/studies/courses/2259/155/info
Технопарк Mail.ru Group: Web-технологии //https://www.intuit.ru/studies/courses/3668/910/info
Межсетевые экраны //https://www.intuit.ru/studies/courses/14250/1286/info
Межсетевое экранирование //https://www.intuit.ru/studies/courses/20/20/info
Вирусы и средства борьбы с ними //https://www.intuit.ru/studies/courses/1042/154/info
Академия Microsoft: Введение в современные веб-технологии //https://www.intuit.ru/studies/courses/603/459/info
Академия Microsoft: Лекции по современным веб-технологиям //https://www.intuit.ru/studies/courses/610/466/info
Введение в Django //https://www.intuit.ru/studies/courses/3586/828/info
Введение в алгоритмы //https://www.intuit.ru/studies/courses/1010/320/info
Введение в защиту информации от внутренних ИТ-угроз //https://www.intuit.ru/studies/courses/1013/172/info
Введение в стандарты Web//https://www.intuit.ru/studies/courses/1029/287/info
Введение в схемы, автоматы и алгоритмы //https://www.intuit.ru/studies/courses/1030/205/info
Введение в технологию программирования //https://www.intuit.ru/studies/courses/2262/160/info
Введение во внутреннее устройство Windows //https://www.intuit.ru/studies/courses/10471/1078/info
Инструменты безопасности с открытым исходным кодом //https://www.intuit.ru/studies/courses/7/7/info
Инструментальные средства обеспечения безопасности //https://www.intuit.ru/studies/courses/1053/150/info
Инструменты, алгоритмы и структуры данных //https://www.intuit.ru/studies/courses/683/539/info
Мотивация персонала//https://www.intuit.ru/studies/courses/701/557/info
Основные протоколы интернет //https://www.intuit.ru/studies/courses/2/2/info
Основы SQL //https://www.intuit.ru/studies/courses/5/5/info
Основы информационной безопасности //https://www.intuit.ru/studies/courses/10/10/info
Основы информационной безопасности при работе на компьютере //https://www.intuit.ru/studies/courses/680/536/info
Основы компьютерной грамотности //https://www.intuit.ru/studies/courses/3685/927/info
Основы операционных систем //https://www.intuit.ru/studies/courses/1088/322/info
Академия Intel: Основы операционных систем //https://www.intuit.ru/studies/courses/2192/31/info
Академия Intel: Основы операционных систем. Практикум //https://www.intuit.ru/studies/courses/2249/52/info
Основы офисного программирования и документы Excel //https://www.intuit.ru/studies/courses/114/114/info
Основы программирования //https://www.intuit.ru/studies/courses/1092/538/info
Основы программирования //https://www.intuit.ru/studies/courses/2193/67/info
Основы работы в ОС Linux //https://www.intuit.ru/studies/courses/91/91/info
Академия Microsoft: Основы современных операционных систем //https://www.intuit.ru/studies/courses/641/497/info
Основы сетей передачи данных //https://www.intuit.ru/studies/courses/1/1/info
Академия Microsoft: Парадигмы программирования //https://www.intuit.ru/studies/courses/1109/204/info
Принципы построения и функционирования ЭВМ //https://www.intuit.ru/studies/courses/1117/278/info
Программирование и знакомство с алгоритмами //https://www.intuit.ru/studies/courses/1121/310/info
Академия Microsoft: Программная логика приложений для Windows 8 и их взаимодействие с системой //https://www.intuit.ru/studies/courses/10755/1114/info
Протоколы безопасного сетевого взаимодействия //https://www.intuit.ru/studies/courses/59/59/info
Протоколы и алгоритмы маршрутизации в Интернет //https://www.intuit.ru/studies/courses/1123/200/info
Процедуры, диагностики и безопасность в Интернет //https://www.intuit.ru/studies/courses/1124/201/info
Работа в Microsoft Excel 2010 //https://www.intuit.ru/studies/courses/613/469/info
Современные операционные системы //https://www.intuit.ru/studies/courses/631/487/info
Академия Microsoft: Современные офисные приложения //https://www.intuit.ru/studies/courses/81/81/info
"Продвинутые" алгоритмы для школьников //https://www.intuit.ru/studies/courses/975/311/info
Microsoft Windows для начинающего пользователя //https://www.intuit.ru/studies/courses/95/95/info
Microsoft Word для начинающего пользователя //https://www.intuit.ru/studies/courses/96/96/info
}//Конец области "Не мешало бы для общего образования"

Хрень, но попробовать надо бы:{
Введение в информатику //https://www.intuit.ru/studies/courses/108/108/info
Введение в информатику. Практикум //https://www.intuit.ru/studies/courses/1014/195/info
Академия Microsoft: Введение в технологии создания Интернет-узлов //https://www.intuit.ru/studies/courses/1036/239/info
Локальные сети и интернет //https://www.intuit.ru/studies/courses/509/365/info
Основы личной эффективности в работе с информацией //https://www.intuit.ru/studies/courses/3699/941/info
Основы технологии локальных сетей //https://www.intuit.ru/studies/courses/524/380/info
Работа в интернете //https://www.intuit.ru/studies/courses/3464/706/info
Сетевая безопасность на основе серверных продуктов Microsoft //https://www.intuit.ru/studies/courses/498/354/info
Какая-то муть:
Введение в математическое программирование //https://www.intuit.ru/studies/courses/1020/188/info
Решение олимпиадных задач по информатике //https://www.intuit.ru/studies/courses/2293/593/info
Введение в теорию графов //https://www.intuit.ru/studies/courses/1033/241/info
Академия Microsoft: Web-технологии //https://www.intuit.ru/studies/courses/485/341/info
Администрирование почтовых серверов sendmail //https://www.intuit.ru/studies/courses/116/116/info
Архитектура и организация ЭВМ //https://www.intuit.ru/studies/courses/60/60/info
	
}//Конец области "Хрень, но попробовать надо бы"
		
Прочие курсы:{
	
	https://www.coursera.org/
		платно:
			Starts Mar 05
			https://www.coursera.org/learn/c-plus-plus-white/home
				Основы разработки на C++: белый пояс
				Приобрести курс · 1 637 ₽
	https://www.udacity.com/
		https://www.udacity.com/course/c-for-programmers--ud210
			возможно тут можно получить, но не уверен.
			все на английском, про сертификат ни слова. Так и не понял, правильно я выполнил задание или нет. Странная вещь.
			
	http://certifications.ru/tests/new/id/45/
	
	https://www.specialist.ru/center/about-center/testingcenter

	https://www.udemy.com/
		очень много курсов, есть бесплатные:
			C++ Tutorial for Complete Beginners	
			Сертификат об окончании
			
	https://www.edx.org/
		курсы бесплатные, а сертификат похоже за 5к+:
			https://www.edx.org/course/introduction-c-microsoft-dev210x-6
			Price:  FREE | Add a Verified Certificate for $99 USD
	
}//Конец области "Прочие курсы"

Сертификат «1С Специалистом»{
Требования: Получение предварительного сертификата «1С Профессионал»
	Экзамены можно разделить на 3 группы:
		1С: Специалист по платформе «1С: Предприятие 8.1» (проверяет понимание основных принципов проектирования конфигураций и технологических решений, заложенных в платформе «1С: Предприятие 8» и практические навыки конфигурирования и программирования). Подходит, если вы специализируетесь на разработке программ.
		
		1С: Специалист по прикладным решениям «1С: Предприятие 8.1» (проверяет знание возможностей программы и наличие практических навыков проектирования в среде «1С: Предприятие» для развития существующего и добавления нового функционала программы). Подходит если вы собираетесь дорабатывать прикладные решения, выпускаемые фирмой «1С».
		
		1С: Специалист-консультант по прикладным решениям «1С: Предприятие 8.1» (проверяет умение находить адекватные средства программы для решения специфических задач пользователя, верно диагностировать ситуации, требующие внесения изменений/дополнений в программу, умение ставить корректные задачи программистам по адаптации прикладных решений). Подходит если у вас хорошие знания предметной области, например налогового учета и Вы хотите стать консультантом, преподавателем или связующим звеном между программистами и пользователями.
	
}//Конец области "Сертификат «1С Специалистом»"	
	
1С-Битрикс{
Компания «1С-Битрикс» проводит бесплатное онлайн-обучение и сертификацию пользователей по программным продуктам «1С-Битрикс: Управление сайтом» и «Битрикс24» в облачной и коробочной версиях.	
http://dev.1c-bitrix.ru/learning/#tab-certif-link
У 1С-Битрикс есть черт знает сколько сертификатов, вплодь с:
	Уровень «Базовый»
		Высокий навык работы в рамках типовых возможностей системы: интеграция дизайна (внедрение HTML шаблонов), компоненты, настройка. Это первая ступень, отличный способ проверить себя и показать всем достигнутый уровень для начинающего разработчика. 
			Тесты и экзамены для достижения уровня: 
			Бесплатный тест «Администратор.Базовый» 
			Экзамен «№1 - Интеграция дизайна и настройка платформы» (999 р.)
}//Конец области "1С-Битрикс"

CPA,CPP,CLA,CLP{			
Сайт английский, где куча экзаменов именно по С++. Странно, непонятно, но есть:
	CPA – C++ Certified Associate Programmer Certification
	CPP – C++ Certified Professional Programmer Certification
	CLA – C Programming Language Certified Associate Certification
	CLP – C Certified Professional Programmer Certification
		http://cppinstitute.org/cpa-c-certified-associate-programmer-certification
}//Конец области "CPA,CPP,CLA,CLP"

Сайт о курсах, возможно стоит повнимательнее просмотреть:{
	http://eduabroad.ru/journal/peretyachenko/3
}//Конец области "Сайт о курсах, возможно стоит повнимательнее просмотреть"

}//Конец области "План: сертификаты"

План: книги{
Эндрю Хант, Дэвид Томас — «Программист-прагматик»
Чед Фаулер — «Программист фанатик»
Роберт Мартин — «Идеальный программист»
Джоэл Спольски — «Джоэл о программировании»
Том ДеМарко, Тимоти Листер — «Вальсируя с Медведями»
Роберт Гласс «Факты и заблуждения профессионального программирования»
Игорь Савчук — «Отъявленный программист. Лайфхакинг из первых рук»
Джон Сонмез — «Путь программиста»
Чарльз Петцольд — «Код. Тайный язык информатики»
Стив Макконнелл — «Совершенный код»
}//Конец области "План: книги"	

}//Конец области проекты.

char, кодировки, utf-8, wchar_t, биты,байты{
Чтобы в С++ полезть к байтам можно использовать bitset:
#include <bitset>
bitset<size_t N > name;
N-	Количество БИТ в хранилище. name-имя переменной.
Прокси-класс, который представляет ссылку на бит.
Он работает с битами. В одном байте, может быть не 8 бит.
#include <limits.h> -берем CHAR_BIT	/*Число бит в байте */ //в моем случае это 8
sizeof() Возвращает размер своего операнда относительно размера типа char.
В языке Си размер char равен одному байту.
В общем случае размер типа char на конкретной платформе регулируется значением константы CHAR_BIT, определённой в заголовочном файле limits.h
Пример с int и bitset{
int i=3;
bitset<sizeof(i)*CHAR_BIT>q=i;
for(int i=q.size()-1;i>=0;--i){
	cout<<q[i]<<" ";
};
cout<<endl;
//0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1
q[0]=0;
int w=q.to_ulong();
cout<<w<<endl; //2
}//Конец области "Пример с инт и bitset"

Пример с char i='A'{
char i='A';	
bitset<sizeof(i)*CHAR_BIT>q=i;
cout<<q.size()<<endl; //8
for(int i=q.size()-1;i>=0;--i){
	cout<<q[i]<<" ";
};
cout<<endl; //0 1 0 0 0 0 0 1
q[0]=0;// 01 это 1,
q[1]=1;// 10 это уже 2. Так мы на единицу увеличиваем код символа
cout<<q.to_ulong()<<endl;	//66
char i1=q.to_ulong();
cout<<i1<<endl;	//B
https://www.asciitable.com/index/asciifull.gif
Тут ссылка на таблицу Таблица ASCII
}//Конец области "Пример с char i='A'"

По умолчанию все идет в ASCII, там для символа используется 8 бит. Одним байтом, в котором 8 бит можно описать любой символ из таблицы.
Но получается маленькая таблица-для других символов был введен utf-8
Но у utf-8, один символ русский минимум 2 байта, то есть 16 бит:
Сначало определяется сколько байт надо- от 1 до 4.
Потому генериуются сами байты:
Количество байтов	Значащих бит	Шаблон
1	7	0xxxxxxx
2	11	110xxxxx 10xxxxxx
3	16	1110xxxx 10xxxxxx 10xxxxxx
4	21	11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
char w[16]="Привет я"; //восемь символов.
и если установить w[15] или меньше, будет ошибка: initializer-string for array of chars is too long
Можно попробовать вручную рассмотреть w{
    char w[16]="Привет я";
    cout<<"w[0]: "<<(void*)&w[0]<<endl;
    cout<<"w[1]: "<<(void*)&w[1]<<endl;
    for(int n=0;n!=16;n++){
		bitset<CHAR_BIT>q=w[n];
		for(int i=q.size()-1;i>=0;--i){
			cout<<q[i]<<" ";
		};
		cout<<endl;
    };
Вывело:
w[0]: 0x7ffff20b0290
w[1]: 0x7ffff20b0291
1 1 0 1 0 0 0 0
1 0 0 1 1 1 1 1
1 1 0 1 0 0 0 1
1 0 0 0 0 0 0 0
1 1 0 1 0 0 0 0
1 0 1 1 1 0 0 0
1 1 0 1 0 0 0 0
1 0 1 1 0 0 1 0
1 1 0 1 0 0 0 0
1 0 1 1 0 1 0 1
1 1 0 1 0 0 0 1
1 0 0 0 0 0 1 0
0 0 1 0 0 0 0 0
1 1 0 1 0 0 0 1
1 0 0 0 1 1 1 1
0 0 0 0 0 0 0 0
}//Конец области "Можно попробовать вручную рассмотреть w"

Статья с хабрахабра: Грустная история забытых символов. Как не сойти с ума при работе с кодировками в C++{
	
Говоря о тексте, большинство программистов C++ думают о массивах кодов символов и кодировке, которой эти коды соответствуют. Наиболее опытные разработчики вообще не мыслят понятие текста без указания кодировки, наименее опытные просто считают массив байтов с кодами символов данностью и интерпретируют в понятиях кодировки операционной системы. Фундаментальная разница между этими двумя подходами не только в опыте разработчика, но и в том, что не думать о кодировке намного проще. Пора рассмотреть способ, как не заботиться о хранении кодировки, перекодировке текста, получать свободный доступ к символам и при этом видеть безошибочное представление текста вне зависимости от того, кто и где смотрит на строку текста: в Китае ли, в США или на острове Мадагаскар.

8 бит и все-все-все…

Начнем с главного. Создатели языка си были минималистами. По сей день в стандарте C/C++ не предусмотрено типа «байт». Вместо этого типа используется тип char. Char означает character, иными словами — символ. Соответственно, говоря в С/С++ о типе char, мы подразумеваем «байт», и наоборот. Вот тут и начинается самое интересное. Дело в том, что максимально возможное число символов, кодируемых 8 битами, равно 256, и это при том, что на сегодняшний день в таблице Unicode насчитываются сотни тысяч символов. 

Хитрые создатели ASCII-кодов сразу же зарезервировали первые 128 кодов под стандартные символы, которыми смело можно закодировать практически все в англоязычном мире, оставив нам лишь половину байта под свои нужды, а точнее лишь один свободный старший бит. В результате в первые годы становления информатики все пытались ужаться в эти оставшиеся «отрицательные» числа от –128 до –1. Каждый набор кодов стандартизировался под определенным именем и с этого момента именовался кодировкой. В какой-то момент кодировок стало больше, чем символов в байте, и все они были несовместимы между собой в той части, что выходила за пределы первых 128 ASCII-символов. В результате, если не угадать с кодировкой, все, что не являет собой набор символов первой необходимости для американского сообщества, будет отображено в виде так называемых кракозябр, символов, как правило, вообще нечитаемых.

Мало того, для одних и тех же алфавитов разные системы вводили кодировки, совершенно рассогласованные между собой, даже если это две системы за авторством одной компании. Так, для кириллицы в MS DOS использовались кодировки 855 и 866, а для Windows уже 1251, все для той же кириллицы в Mac OS используется уже своя кодировка, особняком от них стоят KOI8 и KOI7, есть даже ISO 8859-5, и все будут трактовать одни и те же наборы char совершенно разными символами. Мало того, что было невозможно при обработке различных байт-символов пользоваться сразу несколькими кодировками, например при переводе с русского на немецкий с умлаутами, вдобавок сами символы в некоторых алфавитах ну никак не хотели помещаться в оставленные для них 128 позиций. В результате в интернациональных программах символы могли интерпретироваться в разных кодировках даже в соседних строках, приходилось запоминать, какая строка в какой кодировке, что неизбежно вело к ошибкам отображения текста, от забавных до совсем не смешных.

Поставь себе на виртуальную машину любую другую операционную систему с другой кодировкой по умолчанию, нежели на твоей хостовой системе, например Windows c кодировкой 1251, если у тебя Linux с UTF-8 по умолчанию, и наоборот. Попробуй написать код с выводом строки кириллицей в std::cout, который без изменения кода будет собираться и работать под обеими системами одинаково. Согласись, интернационализация кросс-платформенного кода не такая простая задача.

Пришествие Юникода

Задумка Юникода была проста. Каждому символу раз и навсегда присваивается один код на веки вечные, это стандартизуется в очередной версии спецификации таблицы символов Юникода, и код символа уже не ограничен одним байтом. Великолепная задумка во всем, кроме одного: в языки программирования C/C++ и не только в них символ char раз и навсегда ассоциировался с байтом. Повсюду в коде подразумевался sizeof(char), равный единице. Строки текста же были обычными последовательностями этих самых char, заканчивающимися символом с нулевым кодом. В защиту создателей языка си, Ритчи и Кернигана, следует сказать, что в те далекие 70-е годы никто и подумать не мог, что для кодирования символа понадобится так много кодов, ведь для кодирования символов печатной машинки вполне хватало и байта. Как бы то ни было, основное зло было сотворено, любое изменение типа char привело бы к потере совместимости с уже написанным кодом. Разумным решением стало введение нового типа «широкого символа» wchar_t и дублирование всех стандартных функций языка си для работы с новыми, «широкими» строками. Контейнер стандартной библиотеки C++ string также обрел «широкого» собрата wstring. 

Все рады и счастливы, если бы не одно «но»: все уже привыкли писать код на основе байтовых строк, а префикс L перед строковым литералом не добавлял энтузиазма разработчикам на C/C++. Люди предпочитали не использовать символы за пределами ASCII и смириться с ограниченностью латиницы, чем писать непривычные конструкции, несовместимые с уже написанным кодом, работавшим с типом char. Осложняло ситуацию то, что wchar_t не имеет стандартизированного размера: например, в современных GCC-компиляторах g++ он 4 байта, в Visual C++ — 2 байта, а разработчики Android NDK урезали его до одного байта и сделали неотличимым от char. Получилось так себе решение, которое работает далеко не везде. С одной стороны, 4-байтный wchar_t наиболее близок к правде, так как по стандарту один wchar_t должен соответствовать одному символу Юникода, с другой стороны, никто не гарантирует, что будет именно 4 байта в коде, использующем wchar_t.

Альтернативным решением стала однобайтовая кодировка UTF-8, которая мало того, что совместима с ASCII (старший бит, равный нулю, отвечает за однобайтовые символы), так еще и позволяет кодировать вплоть до 4-байтового целого, то есть свыше 2 миллиардов символов. Плата, правда, довольно существенная, символы получаются различного размера, и чтобы, например, заменить латинский символ R на русский символ Я, потребуется полностью перестроить всю строку, что значительно дороже обычной замены кода в случае 4-байтового wchar_t. Таким образом, любая активная работа с символами строки в UTF-8 может поставить крест на идее использовать данную кодировку. Тем не менее кодировка довольно компактно ужимает текст, содержит защиту от ошибок чтения и, главное, интернациональна: любой человек в любой точке мира увидит одни и те же символы из таблицы Юникода, если будет читать строку, закодированную в UTF-8. Конечно, за исключением случая, когда пытается интерпретировать эту строку в другой кодировке, все помнят «кракозябры» при попытке открыть кириллицу в UTF-8 как текст в кодировке по умолчанию в Windows 1251.

Устройство однобайтного Юникода

Устроена кодировка UTF-8 весьма занятно. Вот основные принципы:

Символ кодируется последовательностью байтов, в каждом байте лидирующие биты кодируют позицию байта в последовательности, а для первого байта еще и длину последовательности. Например, так выглядит в UTF-8 символ Я: [1101 0000] [1010 1111]
Байты последовательности, начиная со второго, всегда начинаются с битов 10, соответственно, первый байт последовательности кода каждого символа начинаться с 10 не может. На этом строится основная проверка корректности декодирования кода символа из UTF-8.
Первый байт может быть единственным, тогда лидирующий бит равен 0 и символ соответствует коду ASCII, поскольку для кодирования остается 7 младших бит.
Если символ не ASCII, то первые биты содержат столько единиц, сколько байт в последовательности, включая лидирующий байт, после чего идет 0 как окончание последовательности единиц и потом уже значащие биты первого байта. Как видно из приведенного примера, кодирование символа Я занимает 2 байта, это можно распознать по старшим двум битам первого байта последовательности.
Все значащие биты склеиваются в единую последовательность бит и уже интерпретируются как число. Например, для любого символа, кодируемого двумя байтами, значащие биты я условно помечу символом x: [110x xxxx] [10xx xxxx]

При склейке, как видно, можно получить число, кодируемое 11 битами, то есть вплоть до 0x7FF символа таблицы Юникода. Этого вполне хватает для символов кириллицы, расположенной в пределах от 0x400 до 0x530. При склейке символа Я из примера получится код: 1 0000 10 1111

Как раз 0x42F — код символа Я в таблице символов Юникода.

Другими словами, если не работать с символами в строке, заменяя их другими символами из таблицы Юникода, то можно использовать кодировку UTF-8, она надежна, компактна и совместима с типом char в том плане, что элементы строк совпадают по размеру с байтом, но не обязательно являются при этом символами.

Собственно, именно эффективностью и популярностью кодировки UTF-8 и обусловлено насильственное введение однобайтового wchar_t в Android NDK, разработчики призывают использовать UTF-8, а «широкие» строки не признают как жизнеспособный вид. С другой стороны, Google не так давно отрицал даже исключения в C++, однако весь мир не переспоришь, будь ты хоть трижды Google, и обработку исключений пришлось поддержать. Что касается wchar_t символов с размером в один байт, то множество библиотек уже привыкло к мытарствам с типом wchar_t и дублируют «широкий» функционал обработкой обычных байтовых строк.

UTF (Unicode Transformation Format) — по сути байтовое представление текста, использующее коды символов из таблицы Юникода, запакованные в байтовый массив согласно стандартизированным правилам. Наиболее популярны UTF-8 и UTF-16, которые представляют символы элементами по 8 бит и по 16 бит соответственно. В обоих случаях символ совершенно необязательно занимает ровно 8 или 16 бит, например, в UTF-16 используются суррогатные пары, по сути пары 16-битных значений, используемых вместе. В результате значащих битов становится меньше (20 в случае суррогатной пары), чем битов в группе представляющих символ, но возможности кодировать символы начинают превышать ограничения в 256 или 65 536 значений, и можно закодировать любой символ из таблицы Юникода. Выгодно отличающийся от собратьев UTF-32 менее популярен, ввиду избыточности представления данных, что критично при большом объеме текста.

Пишем по-русски в коде

Беды и дискриминация по языковому признаку начинаются, когда мы пытаемся использовать в коде строку на языке, отличном от ASCII. Так, Visual Studio под Windows создает все файлы в кодировке файловой системы по умолчанию (1251), и при попытке открыть код со строками по-русски в том же Linux с кодировкой по умолчанию UTF-8 получим кучу непонятных символов вместо исходного текста.

Ситуацию частично спасает пересохранение исходников в кодировке UTF-8 с обязательным символом BOM, без него Visual Studio начинает интерпретировать «широкие» строки с кириллицей весьма своеобразно. Однако, указав BOM (Byte Order Mark — метка порядка байтов) кодировки UTF-8 — символ, кодируемый тремя байтами 0xEF, 0xBB и 0xBF, мы получаем узнавание кодировки UTF-8 в любой системе.

BOM — стандартный заголовочный набор байтов, нужный для распознавания кодировке текста в Юникоде, для каждой из кодировок UTF он выглядит по-разному. Не стесняйся использовать родной язык в программе. Даже если тебе придется локализовывать ее в другие страны, механизмы интернационализации помогут превратить любую строку на одном языке в любую строку на другом. Разумеется, это в случае, если продукт разрабатывается в русскоязычном сегменте.

Старайся использовать «широкие» строки как для строковых констант, так и для хранения и обработки промежуточных текстовых значений. Эффективная замена символов, а также совпадение количества элементов в строке с количеством символов дорогого стоит. Да, до сих пор не все библиотеки научились работать с «широкими» символами, даже в Boost попадается целый ряд библиотек, где поддержка широких строк сделана небрежно, но ситуация исправляется, во многом благодаря разработчикам, пишущим ошибки в трекер библиотеки, не стесняйся и ты фиксировать ошибки на сайте разработчика библиотеки.

Писать константы и переменные, а также названия функций кириллицей все же не нужно. Одно дело — выводить константы на родном языке, совсем другое — писать код, постоянно переключая раскладку. Не самый лучший вариант.

Различаем тип «байты» и тип «текст»

Главное, что нужно уметь и иметь в виду, — что тип «текст» в корне отличается от типа «набор байтов». Если мы говорим о строке сообщения, то это текст, а если о текстовом файле в некоторой кодировке, то это набор байтов, который можно вычитать как текст. Если по сети нам приходят текстовые данные, то они приходят к нам именно байтами, вместе с указанием кодировки, как из этих байтов получить текст.

Если посмотреть на Python 3 в сравнении с Python 2, то третья версия совершила по-настоящему серьезный скачок в развитии, разделив эти два понятия. Крайне рекомендую даже опытному C/C++ разработчику поработать немного в Python 3, чтобы ощутить всю глубину, с которой произошло разделение текста и байтов на уровне языка в Python. Фактически текст в Python 3 отделен от понятия кодировки, что для разработчика C/C++ звучит крайне непривычно, строки в Python 3 отображаются одинаково в любой точке мира, и если мы хотим работать с представлением этой строки в какой-либо кодировке, то придется преобразовать текст в набор байтов, с указанием кодировки. При этом внутреннее представление объекта типа str, по сути, не так важно, как понимание, что внутреннее представление сохранено в Юникоде и готово к преобразованию в любую кодировку, но уже в виде набора байтов типа bytes.

В C/C++ подобный механизм нам мешает ввести отсутствие такой роскоши, как потеря обратной совместимости, которую позволил себе Python 3 относительно второй версии. Одно лишь разделение типа char на аналог wchar_t и byte в одной из следующих редакций стандарта приведет к коллапсу языка и потере совместимости с непомерным количеством уже написанного кода на С/С++. Точнее, всего, на чем ты сейчас работаешь.

Веселые перекодировки

Итак, исходная проблема осталась нерешенной. У нас по-прежнему есть однобайтовые кодировки, как UTF-8, так и старые и недобрые однобайтовые кодировки вроде кодировки Windows 1251. С другой стороны, мы задаем строковые константы широкими строками и обрабатываем текст через wchar_t — «широкие» символы. 

Здесь нам на помощь придет механизм перекодировок. Ведь, зная кодировку набора байтов, мы всегда сможем преобразовать его в набор символов wchar_t и обратно. Не спеши только самостоятельно создавать свою библиотеку перекодировки, я понимаю, что коды символов любой кодировки сейчас можно найти за минуту, как и всю таблицу кодов Юникода последней редакции. Однако библиотек перекодировки достаточно и без этого. Есть кросс-платформенная библиотека libiconv, под лицензией LGPL, самая популярная на сегодняшний день для кросс-платформенной разработки. Перекодировка сводится к нескольким инструкциям:

iconv_t conv = iconv_open("UTF-8","CP1251");
iconv(conv, &src_ptr, &src_len, &dst_ptr, &dst_len);
iconv_close(conv);

Соответственно, сначала создание обработчика перекодировки из одной кодировки в другую, затем сама операция перекодировки одного набора байтов в другой (даже если один из наборов байтов на самом деле байты массива wchar_t), после чего обязательное закрытие созданного обработчика перекодировки. Есть также и более амбициозная библиотека ICU, которая предоставляет как C++ интерфейс для работы с перекодировкой, так и специальный тип icu::UnicodeString для хранения непосредственно текста в представлении Юникода. Библиотека ICU также является кросс-платформенной, и вариантов ее использования предоставляется на порядок больше. Приятно, что библиотека сама заботится о создании, кешировании и применении обработчиков для перекодировки, если использовать C++ API библиотеки.

Например, чтобы создать строку в Юникоде, предлагается использовать обычный конструктор класса icu::UnicodeString:

icu::UnicodeString text(source_bytes, source_encoding);

Таким образом, предлагается полностью отказаться от типа wchar_t. Проблема, однако, в том, что внутреннее представление Юникода для такой строки установлено в два байта, что влечет за собой проблему в случае, когда код за эти два байта выходит. Кроме того, интерфейс icu::UnicodeString полностью несовместим со стандартным wstring, однако использование ICU — хороший вариант для С++ разработчика.

Кроме того, есть пара стандартных функций mbstowcs и wcstombs. В общем и целом при правильно заданной локали они, соответственно, преобразуют (мульти-) байтовую строку в «широкую» и наоборот. Расшифровываются сокращения mbs и wcs как Multi-Byte String и Wide Character String соответственно. Кстати, большинство привычных разработчику на языке си функций работы со строками дублируются именно функциями, в которых в названии str заменено на wcs, например wcslen вместо strlen или wcscpy вместо strcpy.

Нельзя не вспомнить и о Windows-разработке. Счастливых обладателей WinAPI ждет очередная пара функций с кучей параметров: WideCharToMultiByte и MultiByteToWideChar. Делают эти функции ровно то, что говорят их названия. Указываем кодировку, параметры входного и выходного массива и флаги и получаем результат. Несмотря на то что функции эти внешне страшненькие, работу свою делают быстро и эффективно. Правда, не всегда точно: могут попытаться преобразовать символ в похожий, поэтому осторожнее с флагами, которые передаются вторым параметром в функцию, лучше указать WC_NO_BEST_FIT_CHARS. 

Пример использования:

WideCharToMultiByte( CP_UTF8,
    WC_NO_BEST_FIT_CHARS,
    pszWideSource, nWideLength,
    pszByteSource, nByteLength,
    NULL, NULL );

Разумеется, этот код не переносим на любую платформу, кроме Windows, поэтому крайне рекомендую пользоваться кросс-платформенными библиотеками ICU4C или libiconv.

Наиболее популярная библиотека — именно libiconv, однако в ней используются исключительно параметры char*. Это не должно пугать, в любом случае массив чисел любой битности — это всего лишь набор байтов. Следует, однако, помнить про направление двубайтовых и более чисел. То есть в каком порядке в байтовом массиве представлены байты — компоненты числа. Различают Big-endian и Little-endian соответственно. Общепринятый порядок представления чисел в подавляющем большинстве машин — Little-endian: сначала идет младший байт, а в конце старший байт числа. Big-endian знаком тем, кто работает с протоколами передачи данных по сети, где числа принято передавать начиная со старшего байта (часто содержащего служебную информацию) и кончая младшим. Следует быть аккуратным и помнить, что UTF-16, UTF-16BE и UTF-16LE — не одно и то же.

Класс текста

Давай теперь аккумулируем полученные знания и решим исходную задачу: нам нужно создать сущность, по сути класс, инициализируемый строкой, либо «широкой», либо байтовой, с указанием кодировки, и предоставляющий интерфейс привычного контейнера строки std::string, с возможностью обращения к элементам-символам, изменяя их, удаляя, преобразуя экземпляр текста в строке как «широкой», так и байтовой с указанием кодировки. В общем, нам нужно значительно упростить работу с Юникодом, с одной стороны, и получить совместимость с прежде написанным кодом, с другой стороны.

Класс текста, таким образом, получит следующие конструкторы:

text(char const* byte_string, char const* encoding);
text(wchar_t const* wide_string);

Стоит перегрузить также от std::string и std::wstring вариантов, а также от итераторов начала и конца контейнера-источника.

Доступ к элементу, очевидно, должен быть открыт, но в качестве результата нельзя использовать байтовый char или платформозависимый wchar_t, мы должны использовать абстракцию над целочисленным кодом в таблице Юникода: symbol.

symbol& operator [] (int index);
symbol const& operator [] (int index) const;

Таким образом, становится очевидно, что мы не можем сохранять строку Юникода в виде char или wchar_t строки. Нам нужно как минимум std::basic_string<int32_t>, поскольку на данный момент кодировки UTF-8 и UTF-16 кодируют символы в пределах int32_t, не говоря про UTF-32.

С другой стороны, за пределами класса text никому не нужен наш `std::basic_string<int32_t>`, назовем его `unicode_string`. Все библиотеки любят работать с `std::string` и `std::wstring` или `char const*`` и `wchar_t const*`. Таким образом, лучше всего кешировать как входящий std::string или std::wstring, так и результат перекодировки текста в кодировку байт-строки. Мало того, часто наш класс text понадобится лишь как временное хранилище для путешествующей строки, например байтовой в UTF-8 из базы данных в JSON-строку, то есть перекодирование в unicode_string нам понадобится лишь по требованию обратиться к элементам — символам текста. Текст и его внутреннее представление — это тот класс, который должен быть оптимизирован по максимуму, так как предполагает интенсивное использование, а также не допускать перекодировок без причины и до первого требования. Пользователь API класса text должен явно указать, что хочет преобразовать текст в байтовую строку в определенной кодировке либо получить специфичную для системы «широкую» строку:

std::string const& byte_string(std::string const& encoding) const;
std::wstring const& wide_string() const;

Как видно выше, мы возвращаем ссылку на строку, которую мы высчитали и сохранили в поле класса. Разумеется, нам нужно будет почистить кеш с `std::string` и `std::wstring` при первом же изменении значения хотя бы одного символа, здесь нам поможет operator -> от неконстантного this класса данных `text::data`. Как это делать, смотри предыдущие два урока академии C++.

Нужно не забыть также и о получении char const* и wchar_t const*, что несложно делается, учитывая то, что std::string и std::wstring кешируются полями класса text.

char const* byte_c_str(char const* encoding) const;
wchar_t const* wide_c_str() const;

Реализация сводится к вызову `c_str()`` у результатов byte_string и wide_string соответственно.

Можно считать кодировкой по умолчанию для байтовых строк UTF-8, это гораздо лучше, чем пытаться работать с системной кодировкой по умолчанию, так код в зависимости от системы будет работать по-разному. Введя ряд дополнительных перегрузок без указания кодировки при работе с байтовыми строками, мы также получаем возможность переопределить оператор присвоения:

text& operator = (std::string const& byte_string); // в кодировке ”UTF-8”
text& operator = (std::wstring const& wide_string);

Нужно также не забыть о перегрузке операторов + и +=, но в целом остальные операции можно уже сводить к аргументу и результату типа text, универсальному значению, предоставляющему текст вне зависимости от кодировки.

Разумеется, Академия C++ не была бы академией, если бы я не предложил тебе теперь реализовать класс текста самостоятельно. Попробуй создать класс text на основе материала этой статьи. Реализация должна удовлетворять двум простым свойствам:

Классом должно быть удобнее пользоваться, чем стандартными строками, вдобавок класс предоставляет совместимость либо взаимное преобразование с типами `std::string`, `std::wstring`, `char const*`` и `wchar_t const*`.
Класс подразумевает максимальную оптимизацию, работа со строками не должна быть дороже, чем при работе со стандартными std::string и std::wstring. То есть никаких неявных перекодировок, пока API явно не подразумевает перекодировку содержимого, иначе классом никто не будет пользоваться.

Здесь как раз имеет смысл обработать дополнительно неконстантный `operator ->`` для сброса кеша со строками, однако оставляю это на усмотрение разработчика. То есть тебя. Удачи!

Разумеется, в реализации не обойтись без класса `copy_on_write` из предыдущих статей. Как обычно, на всякий случай напоминаю его упрощенный вид:

template <class data_type>
class copy_on_write
{
public:
   copy_on_write(data_type* data)
       : m_data(data) {
    }
   data_type const* operator -> () const {
       return m_data.get();
    }
   data_type* operator -> () {
       if (!m_data.unique())
           m_data.reset(new data_type(*m_data));
       return m_data.get();
    }
private:
   std::shared_ptr<data_type> m_data;
};

Что мы получаем

Реализовав класс text, мы получим абстракцию от множества кодировок, все, что нам потребуется, — одна перегрузка от класса text. Например, так:

text to_json() const;
void from_json(text const& source);

Нам больше не нужно множество перегрузок от `std::string` и `std::wstring`, не нужно будет переходить на поддержку «широких» строк, достаточно заменить в API ссылки на строки на text, и получаем Юникод автоматом. Вдобавок мы получаем отличное кросс-платформенное поведение, вне зависимости от того, какую библиотеку мы выбрали в качестве движка перекодировки, — ICU4C или libiconv, ввиду того, что внутреннее представление у нас всегда UTF-32 при распаковке символов и мы нигде не завязаны на платформозависимый wchar_t.

Итого: у нас есть совместимость либо взаимоконвертация со стандартными типами, а значит, и упрощение поддержки Юникода на стороне кода, написанного на С++. Ведь если мы пишем высокоуровневую логику на C++, меньше всего нам хочется получить проблемы при использовании wchar_t символов и кучи однообразного кода при обработке и перекодировке текста.

При том что сама перекодировка уже реализована в тех же ICU4C и libiconv, алгоритм для внутренней работы класса text довольно прост. Дерзай, и, может, уже завтра именно твоя библиотека работы с текстом будет использоваться повсюду в качестве высокоуровневой абстракции при обработке любых текстовых данных, от простого JSON с клиента до сложных текстовых структур со стороны различных баз данных.
}//Конец области "Статья с хабрахабра: Грустная история забытых символов. Как не сойти с ума при работе с кодировками в C++"

wchar_t — -Он используется для обозначения символьного типа данных, который шире традиционных 8-битных символов. Это не то же самое, что Юникод -это тип данных стандарта ANSI/ISO C (а также использующийся в других языках программирования) для представления широких символов.
ВАЖНО: размер типа wchar_t определяется компилятором, вплоть до минимальных 8 бит. Соответственно, приложения, которым требуется сохранять переносимость на различных C и C++ компиляторах, не должны использовать wchar_t для хранения Unicode-текста. Тип wchar_t предназначен для хранения широких символов в том виде, в котором их понимают конкретные компиляторы, и это может не соответствовать Юникоду
В Windows API тип wchar_t именуется как WCHAR и имеет фиксированный размер 16 бит, что не позволяет кодировать весь набор символов Unicode (больше 1 миллиона). 
В GNU/Linux тип wchar_t имеет размер 32 бита.
Итог- кириллицу в char пихать нельзя. Что с ней делать непонятно.
}//Конец области "char, кодировки, utf-8, wchar_t, биты,байты"

git{
git config --global user.name "Lady-Emporio"
git config --global user.email "godod4@gmail.com"


git init
git add README.md
git commit -m "first commit"
git remote add origin https://github.com/Lady-Emporio/Save.git
git push -u origin master

remote add [сокращение] [url] //Добавление удалённых репозиториев
git remote  //список имён-сокращений для всех уже указанных удалённых дескрипторов.
//origin — это имя по умолчанию, которое Git присваивает серверу, с которого вы склонировали
git remote -v // какому URL соответствует сокращённое имя в Git
	
git push [удал. сервер] [ветка]

git branch testing   //создадим новую ветку под названием testing
//Команда git branch только создала новую ветку, она не переключила вас на неё 
git checkout testing	//перейдём на новую ветку testing

git branch //Получаем список веток, с которыми работаем: звездочкой отмечена текущая ветвь

.gitignore кидать в папку с проектом, там из которой создавал git, где файлы проекта лежат.
git rm --cached <file-name>    //Аргумент --cached заставляет Git удалить файл из индекса, но не трогать рабочую область. То есть он буквально индексирует удаление файла, хотя этого удаления не было. 
git rm -r --cached <path> //Если нужно убрать целую игнорируемую папку, добавляем ключ -r:
}//Конец области "git"

Стандартная библиотека С++{


Библиотеки потока-вывода не учитывал.
Библиотека <iomanip>{ //IO Manipulators
#include <iomanip>  
	setiosflags		- Set format flags (function )
	resetiosflags	- Reset format flags (function )
	setbase			- Set basefield flag (function )
	setfill			- Set fill character (function )//заполнит пустоту от setw символом
	setprecision 	- Set decimal precision (function )
	setw	  		- Set field width (function ) //установит минимульную длину.
	get_money 		- Get monetary value (function )
	put_money 		- Put monetary value (function )
	get_time 		- Get date and time (function )
	put_time 		- Put date and time (function )	
Пример setw and setfill{	
std::cout << std::setfill ('x') << std::setw (10);
std::cout << 77 << std::endl;
}//Конец области "setw and setfill"

}//Конец области "<iomanip>"

C Language Library:
	<cassert> (assert.h)	- C Diagnostics Library (header)
	<cctype> (ctype.h)	- Character handling functions (header)
	<cerrno> (errno.h)	- C Errors (header)
	<cfloat> (float.h)	- Characteristics of floating-point types (header)
	<ciso646> (iso646.h)	- ISO 646 Alternative operator spellings (header)
	<climits> (limits.h)	- Sizes of integral types (header)
	<clocale> (locale.h)	- C localization library (header)
	<cmath> (math.h)	- C numerics library (header){
		Functions:
Trigonometric functions:
cos		- Compute cosine (function )
sin		- Compute sine (function )
tan		- Compute tangent (function )
acos	- Compute arc cosine (function )
asin	- Compute arc sine (function )
atan	- Compute arc tangent (function )
atan2	- Compute arc tangent with two parameters (function )

Hyperbolic functions
cosh	- Compute hyperbolic cosine (function )
sinh	- Compute hyperbolic sine (function )
tanh	- Compute hyperbolic tangent (function )
acosh	- Compute area hyperbolic cosine (function )
asinh	- Compute area hyperbolic sine (function )
atanh	- Compute area hyperbolic tangent (function )

Exponential and logarithmic functions
exp		- Compute exponential function (function )
frexp	- Get significand and exponent (function )
ldexp	- Generate value from significand and exponent (function )
log		- Compute natural logarithm (function )
log10	- Compute common logarithm (function )
modf	- Break into fractional and integral parts (function )
exp2	- Compute binary exponential function (function )
expm1	- Compute exponential minus one (function )
ilogb	- Integer binary logarithm (function )
log1p	- Compute logarithm plus one (function )
log2	- Compute binary logarithm (function )
logb	- Compute floating-point base logarithm (function )
scalbn	- Scale significand using floating-point base exponent (function )
scalbln	- Scale significand using floating-point base exponent (long) (function )

Power functions
pow		- Raise to power (function )
sqrt	- Compute square root (function )
cbrt	- Compute cubic root (function )
hypot 	- Compute hypotenuse (function )

Error and gamma functions
erf	- Compute error function (function )
erfc	- Compute complementary error function (function )
tgamma	- Compute gamma function (function )
lgamma	- Compute log-gamma function (function )

Rounding and remainder functions
ceil	- Round up value (function )
floor	- Round down value (function )
fmod	- Compute remainder of division (function )
trunc	- Truncate value (function )
round	- Round to nearest (function )
lround	- Round to nearest and cast to long integer (function )
llround	- Round to nearest and cast to long long integer (function )
rint	- Round to integral value (function )
lrint	- Round and cast to long integer (function )
llrint	- Round and cast to long long integer (function )
nearbyint	- Round to nearby integral value (function )
remainder	- Compute remainder (IEC 60559) (function )
remquo	- Compute remainder and quotient (function )

Floating-point manipulation functions
copysign	- Copy sign (function )
nan			- Generate quiet NaN (function )
nextafter	- Next representable value (function )
nexttoward	- Next representable value toward precise value (function )

Minimum, maximum, difference functions
fdim	- Positive difference (function )
fmax	- Maximum value (function )
fmin	- Minimum value (function )

Other functions
fabs	- Compute absolute value (function )
abs		- Compute absolute value (function )
fma		- Multiply-add (function )

Macros / Functions
These are implemented as macros in C and as functions in C++:
Classification macro / functions:
fpclassify	- Classify floating-point value (macro/function )
isfinite	- Is finite value (macro )
isinf		- Is infinity (macro/function )
isnan		- Is Not-A-Number (macro/function )
isnormal	- Is normal (macro/function )
signbit		- Sign bit (macro/function )

Comparison macro / functions
isgreater		- Is greater (macro )
isgreaterequal	- Is greater or equal (macro )
isless			- Is less (macro )
islessequal		- Is less or equal (macro )
islessgreater	- Is less or greater (macro )
isunordered		- Is unordered (macro )

Macro constants
math_errhandling- Error handling (macro )
INFINITY		- Infinity (constant )
NAN				- Not-A-Number (constant )
HUGE_VAL		- Huge value (constant )
HUGE_VALF		- Huge float value
HUGE_VALL		- Huge long double value (constant )
}//Конец области "C numerics library <cmath> (math.h)"
	<csetjmp> (setjmp.h)	- Non local jumps (header)
	<csignal> (signal.h)	- C library to handle signals (header)
	<cstdarg> (stdarg.h)	- Variable arguments handling (header)
	<cstdbool> (stdbool.h)	- Boolean type (header)
	<cstddef> (stddef.h)	- C Standard definitions (header)
	<cstdint> (stdint.h)	- Integer types (header)
	<cstdio> (stdio.h)	- C library to perform Input/Output operations (header)
	<cstdlib> (stdlib.h)	- C Standard General Utilities Library (header){
		
		//http://www.cplusplus.com/reference/cstdlib/
Functions:
String conversion:
atof	- Convert string to double (function )
atoi	- Convert string to integer (function )
atol	- Convert string to long integer (function )
atoll 	- Convert string to long long integer (function )
strtod	- Convert string to double (function )
strtof 	- Convert string to float (function )
strtol	- Convert string to long integer (function )
strtold	- Convert string to long double (function )
strtoll	- Convert string to long long integer (function )
strtoul	- Convert string to unsigned long integer (function )
strtoull- Convert string to unsigned long long integer (function )

Pseudo-random sequence generation
rand	- Generate random number (function )
srand	- Initialize random number generator (function )

Dynamic memory management
calloc	- Allocate and zero-initialize array (function )
free	- Deallocate memory block (function )
malloc	- Allocate memory block (function )
realloc	- Reallocate memory block (function )

Environment
abort	- Abort current process (function )
atexit	- Set function to be executed on exit (function )
at_quick_exit	- Set function to be executed on quick exit (function )
exit	- Terminate calling process (function ){ //void exit (int status);
завершит приложение со statuc кодом возврата.
}//exit
getenv	- Get environment string (function )
quick_exit	- Terminate calling process quick (function )
system	- Execute system command (function )
_Exit	- Terminate calling process (function )

Searching and sorting
bsearch	- Binary search in array (function )
qsort	- Sort elements of array (function )

Integer arithmetics
abs	- Absolute value (function )
div	- Integral division (function )
labs	- Absolute value (function )
ldiv	- Integral division (function )
llabs	- Absolute value (function )
lldiv	- Integral division (function )

Multibyte characters
mblen	- Get length of multibyte character (function )
mbtowc	- Convert multibyte sequence to wide character (function )
wctomb	- Convert wide character to multibyte sequence (function )

Multibyte strings
mbstowcs	- Convert multibyte string to wide-character string (function )
wcstombs	- Convert wide-character string to multibyte string (function )

Macro constants
EXIT_FAILURE	- Failure termination code (macro )
EXIT_SUCCESS	- Success termination code (macro )
MB_CUR_MAX	- Maximum size of multibyte characters (macro )
NULL	- Null pointer (macro )
RAND_MAX	- Maximum value returned by rand (macro )

Types
div_t	- Structure returned by div (type )
ldiv_t	- Structure returned by ldiv (type )
lldiv_t	- Structure returned by lldiv (type )
size_t	- Unsigned integral type (type )

}//Конец области "C Standard General Utilities Library: <cstdlib> (stdlib.h)"
	<cstring> (string.h)	- C Strings (header)
	<ctime> (time.h)	- C Time Library (header){
Functions
Time manipulation:
clock	- Clock program (function )
difftime- Return difference between two times (function )
mktime	- Convert tm structure to time_t (function )
time	- Get current time (function )

Conversion
asctime	- Convert tm structure to string (function )
ctime	- Convert time_t value to string (function )
gmtime	- Convert time_t to tm as UTC time (function )
localtime- Convert time_t to tm as local time (function )
strftime- Format time as string (function )

Macro constants
CLOCKS_PER_SEC	- Clock ticks per second (macro )
NULL	- Null pointer (macro )

types
clock_t	- Clock type (type )
size_t	- Unsigned integral type (type )
time_t	- Time type (type )
struct tm	- Time structure (type )		
		
	}//C Time Library <ctime> (time.h)
	<cuchar> (uchar.h)	- Unicode characters (header)
	<cwchar> (wchar.h)	- Wide characters (header)
	<cwctype> (wctype.h)	- Wide character type (header)
library Containers- Standard Containers:
	Container class templates
	Sequence containers:
	array	- Array class (class template )
	vector	- Vector (class template )
	deque	- Double ended queue (class template )
	forward_list	- Forward list (class template )
	list	- List (class template )

	Container adaptors:
	stack	- LIFO stack (class template )
	queue	- FIFO queue (class template )
	priority_queue	- Priority queue (class template )

	Associative containers:
	set	- Set (class template )
	multiset	- Multiple-key set (class template )
	map	- Map (class template )
	multimap	- Multiple-key map (class template )

	Unordered associative containers:
	unordered_set	- Unordered Set (class template )
	unordered_multiset	- Unordered Multiset (class template )
	unordered_map	- Unordered Map (class template )
	unordered_multimap	- Unordered Multimap (class template )

library Multi-threading - Atomic and thread support
	<atomic>	- Atomic (header)
	<thread>	- Thread (header)
	<mutex>		- Mutex (header)
	<condition_variable>	- Condition variable (header)
	<future>	- Future (header)

library Other -Standard Library - Miscellaneous headers
	<algorithm>	- Standard Template Library: Algorithms (library ){
	//http://www.cplusplus.com/reference/algorithm/	
Non-modifying sequence operations:
all_of -	Test condition on all elements in range (function template )
any_of -	Test if any element in range fulfills condition (function template )
none_of -	Test if no elements fulfill condition (function template )
for_each -	Apply function to range (function template )
find -		Find value in range (function template )
find_if -	Find element in range (function template )
find_if_not -	Find element in range (negative condition) (function template )
find_end -	Find last subsequence in range (function template )
find_first_of -	Find element from set in range (function template )
adjacent_find -	Find equal adjacent elements in range (function template )
count -	Count appearances of value in range (function template )
count_if -	Return number of elements in range satisfying condition (function template )
mismatch -	Return first position where two ranges differ (function template )
equal -	Test whether the elements in two ranges are equal (function template )
is_permutation -	Test whether range is permutation of another (function template )
search -	Search range for subsequence (function template )
search_n -	Search range for elements (function template )

Modifying sequence operations:
copy -		Copy range of elements (function template )
copy_n -	Copy elements (function template )
copy_if -	Copy certain elements of range (function template )
copy_backward -	Copy range of elements backward (function template )
move -	Move range of elements (function template )
move_backward -	Move range of elements backward (function template )
swap -	Exchange values of two objects (function template )
swap_ranges -	Exchange values of two ranges (function template )
iter_swap -	Exchange values of objects pointed to by two iterators (function template )
transform -	Transform range (function template )
replace -	Replace value in range (function template )
replace_if -	Replace values in range (function template )
replace_copy -	Copy range replacing value (function template )
replace_copy_if -	Copy range replacing value (function template )
fill -	Fill range with value (function template )
fill_n -	Fill sequence with value (function template )
generate -	Generate values for range with function (function template )
generate_n -	Generate values for sequence with function (function template )
remove -	Remove value from range (function template )
remove_if -	Remove elements from range (function template )
remove_copy -	Copy range removing value (function template )
remove_copy_if -	Copy range removing values (function template )
unique -	Remove consecutive duplicates in range (function template )
unique_copy -	Copy range removing duplicates (function template )
reverse -	Reverse range (function template )
reverse_copy -	Copy range reversed (function template )
rotate -	Rotate left the elements in range (function template )
rotate_copy -	Copy range rotated left (function template )
random_shuffle -	Randomly rearrange elements in range (function template )
shuffle  -	Randomly rearrange elements in range using generator (function template )

Partitions:
is_partitioned -	Test whether range is partitioned (function template )
partition -	Partition range in two (function template )
stable_partition -	Partition range in two - stable ordering (function template )
partition_copy -	Partition range into two (function template )
partition_point -	Get partition point (function template )

Sorting:
sort -	Sort elements in range (function template )
stable_sort -	Sort elements preserving order of equivalents (function template )
partial_sort -	Partially sort elements in range (function template )
partial_sort_copy -	Copy and partially sort range (function template )
is_sorted -	Check whether range is sorted (function template )
is_sorted_until -	Find first unsorted element in range (function template )
nth_element -	Sort element in range (function template )

Binary search (operating on partitioned/sorted ranges):
lower_bound -	Return iterator to lower bound (function template )
upper_bound -	Return iterator to upper bound (function template )
equal_range -	Get subrange of equal elements (function template )
binary_search -	Test if value exists in sorted sequence (function template )

Merge (operating on sorted ranges):
merge -	Merge sorted ranges (function template )
inplace_merge -	Merge consecutive sorted ranges (function template )
includes -	Test whether sorted range includes another sorted range (function template )
set_union -	Union of two sorted ranges (function template )
set_intersection -	Intersection of two sorted ranges (function template )
set_difference -	Difference of two sorted ranges (function template )
set_symmetric_difference -	Symmetric difference of two sorted ranges (function template )

Heap:
push_heap -	Push element into heap range (function template )
pop_heap -	Pop element from heap range (function template )
make_heap -	Make heap from range (function template )
sort_heap -	Sort elements of heap (function template )
is_heap -	Test if range is heap (function template )
is_heap_until -	Find first element not in heap order (function template )

Min/max:
min -	Return the smallest (function template )
max -	Return the largest (function template )
minmax -	Return smallest and largest elements (function template )
min_element -	Return smallest element in range (function template )
max_element -	Return largest element in range (function template )
minmax_element -	Return smallest and largest elements in range (function template )

Other:
lexicographical_compare -	Lexicographical less-than comparison (function template )
next_permutation -	Transform range to next permutation (function template )
prev_permutation -	Transform range to previous permutation (function template )

	}//<algorithm>
	<chrono>	- Time library (header)
	<complex>	- Complex numbers library (header)
	<exception>	- Standard exceptions (header)
	<functional>- Function objects (header)
	<initializer_list>	- Initializer list (header)
	<iterator>	- Iterator definitions (header)
	<limits>	- Numeric limits (header)
	<locale>	- Localization library (header)
	<memory>	- Memory elements (header)
	<new>	- Dynamic memory (header)
	<numeric>	- Generalized numeric operations (header)
	<random>	- Random (header)
	<ratio>	- Ratio header (header)
	<regex>	- Regular Expressions (header){
		Regex operations
Regex operations are performed using either functions or special iterator adaptors:

Functions:
regex_match		- Match sequence (function template )
regex_search	- Search sequence (function template )
regex_replace	- Replace matched sequence (function template )

Iterator types:
regex_iterator	- Regex iterator (class template )
regex_token_iterator	- Regex token iterator (class template )

Classes
The regex functions and iterators make heavy use of a set of supporting types as arguments and return values:

Basic types:
basic_regex	- Regular expression (class template )
match_results- Match results (class template )
sub_match	- Sub-expression match (class template )
regex_traits- Regex traits (class template )
regex_error	- Regex exception (class )

Some of these types are templates, and have aliases for their most common instantiations:

basic_regex instantiations:
regex	- Regex (class )
wregex	- Regex for wchar_t (class )
match_results instantiations:
cmatch	- match_results for string literals (class )
wcmatch	- match_results for wide string literals (class )
smatch	- match_results for string objects (class )
wsmatch	- match_results for wide string objects (class )
sub_match instantiations:
csub_match	- sub_match for string literals (class )
wcsub_match	- sub_match for wide string literals (class )
ssub_match	- sub_match for strings (class )
wssub_match	- sub_match for wide strings (class )

Namespaces
This header also defines a namespace, regex_constants, under which all constant values to be used by the library are located:
regex_constants	- regex constants (namespace )

Grammar
Regular expressions follow very strict grammars. By default, the functions in this library use the ECMAScript grammar:
ECMAScript syntax	- ECMAScript regular expressions pattern syntax (syntax specifications )

Other functions
begin	- Iterator to beginning (function template )
end	- Iterator to end (function template )	
}//Конец области "Regular Expressions <regex>!C11"
	<stdexcept>	- Exception classes (header)
	<string>	- Strings (header)
	<system_error>	- System errors (header)
	<tuple>	- Tuple library (header)
	<typeinfo>	- Type information (header)
	<type_traits>	- type_traits (header)
	<utility>	- Utility components (header)
	<valarray>	- Library for arrays of numeric values (header)

}//Конец области "стандартная библитека С++"

gcc. Настальная книга пользователей, программистов и системных аднимистраторов: 32 СТРАНИЦА.

Язык программирования С++. Базовый курс, пятое издание. '2014г 1120 страниц. Липпман, Стенли Б, Лажойе, Жоли.
Остановился на 215 СТРАНИЦА.

'Qt5.3 Профессиональное программирование на С++. 2015г 928 страниц
Макс Шлее.
Остановился на 53

Объектно-ориентированное программирование в С++.
Р. Лафоре '2004 год. 4 издание 924 стр.
Остановился на 149 СТРАНИЦА.

Системное программирование в среде Windows
Харт Джонсон М
